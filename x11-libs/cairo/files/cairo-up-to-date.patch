diff --git a/Makefile.am b/Makefile.am
index 03fa35236..04990f524 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -55,6 +55,32 @@ EXTRA_DIST += \
 	cairo-version.h \
 	$(NULL)
 
+# Meson build system files
+EXTRA_DIST += \
+	meson.build \
+	meson_options.txt \
+	boilerplate/make-cairo-boilerplate-constructors.py \
+	boilerplate/meson.build \
+	src/meson.build \
+	test/make-cairo-test-constructors.py \
+	test/meson.build \
+	test/pdiff/meson.build \
+	util/cairo-fdr/meson.build \
+	util/cairo-gobject/meson.build \
+	util/cairo-missing/meson.build \
+	util/cairo-script/meson.build \
+	util/cairo-sphinx/meson.build \
+	util/cairo-trace/meson.build \
+	util/meson.build \
+	meson-cc-tests/atomic-ops-cxx11.c \
+	meson-cc-tests/ipc_rmid_deferred_release.c \
+	meson-cc-tests/ft_has_color.c \
+	meson-cc-tests/mkdir-variant-1.c \
+	meson-cc-tests/pthread.c \
+	meson-cc-tests/atomic-ops-gcc-legacy.c \
+	meson-cc-tests/mkdir-variant-2.c \
+	$(NULL)
+
 DISTCLEANFILES += config.cache
 
 MAINTAINERCLEANFILES += \
diff --git a/boilerplate/cairo-boilerplate-cogl.c b/boilerplate/cairo-boilerplate-cogl.c
index e39ad333d..2339dd883 100644
--- a/boilerplate/cairo-boilerplate-cogl.c
+++ b/boilerplate/cairo-boilerplate-cogl.c
@@ -31,27 +31,23 @@
  */
 
 #include "cairo-boilerplate-private.h"
+#include "cairo-malloc-private.h"
 
 #include <cairo-cogl.h>
 #include <cogl/cogl2-experimental.h>
 
 typedef struct _cogl_closure {
     cairo_device_t *device;
-    CoglFramebuffer *fb;
     cairo_surface_t *surface;
 } cogl_closure_t;
 
 static const cairo_user_data_key_t cogl_closure_key;
 
-static CoglContext *context = NULL;
-
 static void
 _cairo_boilerplate_cogl_cleanup (void *abstract_closure)
 {
     cogl_closure_t *closure = abstract_closure;
 
-    cogl_object_unref (closure->fb);
-
     cairo_device_finish (closure->device);
     cairo_device_destroy (closure->device);
 
@@ -68,35 +64,30 @@ _cairo_boilerplate_cogl_create_offscreen_color_surface (const char		*name,
 							cairo_boilerplate_mode_t mode,
 							void		       **abstract_closure)
 {
+    CoglContext *context;
     cairo_device_t *device;
-    CoglTexture *tex;
-    CoglHandle offscreen;
-    CoglFramebuffer *fb;
     cogl_closure_t *closure;
     cairo_status_t status;
 
-    if (!context)
-	context = cogl_context_new (NULL, NULL);
+    if (width < 1)
+        width = 1;
+    if (height < 1)
+        height = 1;
+
+    context = cogl_context_new (NULL, NULL);
 
     device = cairo_cogl_device_create (context);
-    tex = cogl_texture_new_with_size (width, height,
-				      COGL_TEXTURE_NO_SLICING,
-				      COGL_PIXEL_FORMAT_BGRA_8888_PRE);
-    offscreen = cogl_offscreen_new_to_texture (tex);
-    fb = COGL_FRAMEBUFFER (offscreen);
-
-    cogl_framebuffer_allocate (fb, NULL);
-    cogl_push_framebuffer (fb);
-    cogl_ortho (0, cogl_framebuffer_get_width (fb),
-                cogl_framebuffer_get_height (fb), 0,
-                -1, 100);
-    cogl_pop_framebuffer ();
-
-    closure = malloc (sizeof (cogl_closure_t));
+
+    /* The device will take a reference on the context */
+    cogl_object_unref (context);
+
+    closure = _cairo_malloc (sizeof (cogl_closure_t));
     *abstract_closure = closure;
     closure->device = device;
-    closure->fb = fb;
-    closure->surface = cairo_cogl_surface_create (device, fb);
+    closure->surface = cairo_cogl_offscreen_surface_create (device,
+                                                            content,
+                                                            width,
+                                                            height);
 
     status = cairo_surface_set_user_data (closure->surface,
 					  &cogl_closure_key, closure, NULL);
@@ -117,32 +108,57 @@ _cairo_boilerplate_cogl_create_onscreen_color_surface (const char	       *name,
 						       cairo_boilerplate_mode_t mode,
 						       void		      **abstract_closure)
 {
+    CoglContext *context;
     cairo_device_t *device;
-    CoglOnscreen *onscreen;
-    CoglFramebuffer *fb;
     cogl_closure_t *closure;
     cairo_status_t status;
 
-    if (!context)
-	context = cogl_context_new (NULL, NULL);
+    if (width < 1)
+        width = 1;
+    if (height < 1)
+        height = 1;
+
+    if (content & CAIRO_CONTENT_ALPHA) {
+	/* A hackish way to ensure that we get a framebuffer with
+	 * an alpha component */
+	CoglSwapChain *swap_chain;
+	CoglOnscreenTemplate *onscreen_template;
+	CoglRenderer *renderer;
+	CoglDisplay *display;
+
+        swap_chain = cogl_swap_chain_new ();
+        cogl_swap_chain_set_has_alpha (swap_chain, TRUE);
+
+        onscreen_template = cogl_onscreen_template_new (swap_chain);
+        renderer = cogl_renderer_new ();
+        display = cogl_display_new (renderer, onscreen_template);
+
+        /* References will be taken on the swap chain, renderer, and
+         * onscreen template by the constructors */
+        cogl_object_unref (swap_chain);
+        cogl_object_unref (renderer);
+        cogl_object_unref (onscreen_template);
+
+        context = cogl_context_new (display, NULL);
+
+        /* The context will take a reference on the display */
+        cogl_object_unref (display);
+    } else {
+        context = cogl_context_new (NULL, NULL);
+    }
 
     device = cairo_cogl_device_create (context);
-    onscreen = cogl_onscreen_new (context, width, height);
-    fb = COGL_FRAMEBUFFER (onscreen);
 
-    cogl_onscreen_show (onscreen);
+    /* The device will take a reference on the context */
+    cogl_object_unref (context);
 
-    cogl_push_framebuffer (fb);
-    cogl_ortho (0, cogl_framebuffer_get_width (fb),
-                cogl_framebuffer_get_height (fb), 0,
-                -1, 100);
-    cogl_pop_framebuffer ();
-
-    closure = malloc (sizeof (cogl_closure_t));
+    closure = _cairo_malloc (sizeof (cogl_closure_t));
     *abstract_closure = closure;
     closure->device = device;
-    closure->fb = fb;
-    closure->surface = cairo_cogl_surface_create (device, fb);
+    closure->surface = cairo_cogl_onscreen_surface_create (device,
+                                                           content,
+                                                           width,
+                                                           height);
 
     status = cairo_surface_set_user_data (closure->surface,
 					  &cogl_closure_key, closure, NULL);
@@ -154,22 +170,16 @@ _cairo_boilerplate_cogl_create_onscreen_color_surface (const char	       *name,
 }
 
 static cairo_status_t
-_cairo_boilerplate_cogl_finish_onscreen (cairo_surface_t *surface)
+_cairo_boilerplate_cogl_finish (cairo_surface_t *surface)
 {
-    cogl_closure_t *closure = cairo_surface_get_user_data (surface, &cogl_closure_key);
-
-    cairo_cogl_surface_end_frame (surface);
-
-    cogl_framebuffer_swap_buffers (closure->fb);
-
-    return CAIRO_STATUS_SUCCESS;
+    return cairo_cogl_surface_end_frame (surface);
 }
 
 static void
 _cairo_boilerplate_cogl_synchronize (void *abstract_closure)
 {
     cogl_closure_t *closure = abstract_closure;
-    cogl_framebuffer_finish (closure->fb);
+    cairo_cogl_surface_synchronize (closure->surface);
 }
 
 static const cairo_boilerplate_target_t targets[] = {
@@ -179,7 +189,8 @@ static const cairo_boilerplate_target_t targets[] = {
 	"cairo_cogl_device_create",
 	_cairo_boilerplate_cogl_create_offscreen_color_surface,
 	cairo_surface_create_similar,
-	NULL, NULL,
+	NULL,
+        _cairo_boilerplate_cogl_finish,
 	_cairo_boilerplate_get_image_surface,
 	cairo_surface_write_to_png,
 	_cairo_boilerplate_cogl_cleanup,
@@ -194,7 +205,7 @@ static const cairo_boilerplate_target_t targets[] = {
 	_cairo_boilerplate_cogl_create_onscreen_color_surface,
 	cairo_surface_create_similar,
 	NULL,
-	_cairo_boilerplate_cogl_finish_onscreen,
+	_cairo_boilerplate_cogl_finish,
 	_cairo_boilerplate_get_image_surface,
 	cairo_surface_write_to_png,
 	_cairo_boilerplate_cogl_cleanup,
diff --git a/boilerplate/make-cairo-boilerplate-constructors.py b/boilerplate/make-cairo-boilerplate-constructors.py
new file mode 100644
index 000000000..8e02fa500
--- /dev/null
+++ b/boilerplate/make-cairo-boilerplate-constructors.py
@@ -0,0 +1,38 @@
+# IMPORTANT: Keep in sync with make-cairo-boilerplate-constructors.sh
+#            and test/make-cairo-test-constructors.py!
+import argparse
+import sys
+import re
+
+if __name__=='__main__':
+    parser = argparse.ArgumentParser()
+    parser.add_argument('output')
+    parser.add_argument('input', nargs='+')
+    args = parser.parse_args()
+
+    boilerplate_names = []
+
+    match_boilerplate_line = re.compile(r'^CAIRO_BOILERPLATE.*')
+    match_boilerplate_name = re.compile(r'^CAIRO_BOILERPLATE.*\((.*),.*')
+
+    for fname in args.input:
+        with open(fname, 'r') as f:
+            for l in f.readlines():
+                if match_boilerplate_line.match(l):
+                    boilerplate_names.append(match_boilerplate_name.match(l).group(1))
+
+    with open(args.output, 'w') as f:
+        f.write('/* WARNING: Autogenerated file - see %s! */\n\n' % sys.argv[0])
+        f.write('#include "cairo-boilerplate-private.h"\n\n')
+        f.write('void _cairo_boilerplate_register_all (void);\n\n')
+
+        for boilerplate_name in boilerplate_names:
+            f.write('extern void _register_%s (void);\n' % boilerplate_name)
+
+        f.write('\nvoid\n')
+        f.write('_cairo_boilerplate_register_all (void)\n')
+        f.write('{\n')
+
+        for boilerplate_name in boilerplate_names:
+            f.write('    _register_%s ();\n' % boilerplate_name)
+        f.write('}\n')
diff --git a/boilerplate/make-cairo-boilerplate-constructors.sh b/boilerplate/make-cairo-boilerplate-constructors.sh
index 09716ca9e..1503e9970 100644
--- a/boilerplate/make-cairo-boilerplate-constructors.sh
+++ b/boilerplate/make-cairo-boilerplate-constructors.sh
@@ -1,4 +1,6 @@
 #! /bin/sh
+#
+# IMPORTANT: Keep in sync with make-cairo-boilerplate-constructors.py!
 
 if test $# -eq 0; then
     echo "$0: no input files." >&2
diff --git a/boilerplate/meson.build b/boilerplate/meson.build
new file mode 100644
index 000000000..325396d6e
--- /dev/null
+++ b/boilerplate/meson.build
@@ -0,0 +1,43 @@
+cairo_boilerplate_sources = [
+  'cairo-boilerplate-getopt.c',
+  'cairo-boilerplate-system.c',
+  'cairo-boilerplate.c',
+]
+
+cairo_boilerplate_feature_sources = {
+  'cairo-xlib': ['cairo-boilerplate-xlib.c'],
+  'cairo-qt': ['cairo-boilerplate-qt.cpp'],
+  'cairo-quartz': ['cairo-boilerplate-quartz.c'],
+  'cairo-xcb': ['cairo-boilerplate-xcb.c'],
+  'cairo-win32': ['cairo-boilerplate-win32.c', 'cairo-boilerplate-win32-printing.c'],
+  'cairo-drm': ['cairo-boilerplate-drm.c'],
+  'cairo-cogl': ['cairo-boilerplate-cogl.c'],
+  'cairo-directfb': ['cairo-boilerplate-directfb.c'],
+  'cairo-pdf': ['cairo-boilerplate-pdf.c'],
+  'cairo-ps': ['cairo-boilerplate-ps.c'],
+  'cairo-svg': ['cairo-boilerplate-svg.c'],
+  'cairo-vg': ['cairo-boilerplate-vg.c'],
+  'cairo-script': ['cairo-boilerplate-script.c'],
+  # All tests crash with FPE
+  # 'cairo-egl': ['cairo-boilerplate-egl.c'],
+  # cairo-glx: ['cairo-boilerplate-glx.c'],
+  'cairo-wgl': ['cairo-boilerplate-wgl.c'],
+}
+
+foreach feature: built_features
+  source_key = feature.get('source-key', feature.get('name'))
+  cairo_boilerplate_sources += cairo_boilerplate_feature_sources.get(source_key, [])
+endforeach
+
+cairo_boilerplate_constructors = custom_target('cairo-boilerplate-constructors.c',
+  input: files(cairo_boilerplate_sources),
+  output: 'cairo-boilerplate-constructors.c',
+  command: [python3, files('make-cairo-boilerplate-constructors.py')[0], '@OUTPUT@', '@INPUT@'])
+
+libcairoboilerplate = static_library('cairoboilerplate', cairo_boilerplate_sources + [cairo_boilerplate_constructors],
+  c_args: ['-DHAVE_CONFIG_H'],
+  cpp_args: ['-DHAVE_CONFIG_H'],
+  include_directories: [incbase, incsrc],
+  dependencies: deps,
+  link_with: [libcairo],
+)
diff --git a/build/aclocal.float.m4 b/build/aclocal.float.m4
index f92db03e6..d9728c123 100644
--- a/build/aclocal.float.m4
+++ b/build/aclocal.float.m4
@@ -31,10 +31,13 @@ int main() { return 0; }
 
 ]])], [
 
-if strings -a conftest$ac_exeext | grep noonsees >/dev/null ; then
+# allow users to override default 'strings' with 'llvm-strings'
+# or ${CHOST}-strings.
+AC_CHECK_TOOL(STRINGS, strings)
+if $STRINGS -a conftest$ac_exeext | grep noonsees >/dev/null ; then
   ax_cv_c_float_words_bigendian=yes
 fi
-if strings -a conftest$ac_exeext | grep seesnoon >/dev/null ; then
+if $STRINGS -a conftest$ac_exeext | grep seesnoon >/dev/null ; then
   if test "$ax_cv_c_float_words_bigendian" = unknown; then
     ax_cv_c_float_words_bigendian=no
   else
diff --git a/build/configure.ac.system b/build/configure.ac.system
index def75cdc1..383f28d46 100644
--- a/build/configure.ac.system
+++ b/build/configure.ac.system
@@ -88,7 +88,7 @@ AC_CHECK_HEADERS([stdint.h inttypes.h sys/int_types.h])
 AC_CHECK_TYPES([uint64_t, uint128_t, __uint128_t])
 
 dnl Check for socket support for any2ppm daemon
-AC_CHECK_HEADERS([fcntl.h unistd.h signal.h sys/stat.h sys/socket.h sys/poll.h sys/un.h])
+AC_CHECK_HEADERS([fcntl.h unistd.h signal.h poll.h sys/stat.h sys/socket.h sys/poll.h sys/un.h])
 
 dnl Check for infinite loops
 AC_CHECK_FUNCS([alarm])
diff --git a/cairo-version.h b/cairo-version.h
index 890ff5890..605ec1a7c 100644
--- a/cairo-version.h
+++ b/cairo-version.h
@@ -3,6 +3,6 @@
 
 #define CAIRO_VERSION_MAJOR 1
 #define CAIRO_VERSION_MINOR 17
-#define CAIRO_VERSION_MICRO 2
+#define CAIRO_VERSION_MICRO 3
 
 #endif
diff --git a/configure.ac b/configure.ac
index 2f3eed746..8d23ae0c1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -136,6 +136,7 @@ CAIRO_ENABLE_SURFACE_BACKEND(xlib_xrender, Xlib Xrender, auto, [
   else
     dnl Check for Xrender header files if the Xrender package is not installed:
     xlib_xrender_BASE=cairo-xlib
+    dnl Keep in sync with meson.build!
     xlib_xrender_REQUIRES="xrender >= 0.6"
     PKG_CHECK_MODULES(xlib_xrender, $xlib_xrender_REQUIRES, ,
 		      [xlib_xrender_REQUIRES=""
@@ -162,6 +163,7 @@ CAIRO_ENABLE_SURFACE_BACKEND(xlib_xrender, Xlib Xrender, auto, [
 dnl ===========================================================================
 
 CAIRO_ENABLE_SURFACE_BACKEND(xcb, XCB, auto, [
+  dnl Keep in sync with meson.build!
   xcb_REQUIRES="xcb >= 1.6 xcb-render >= 1.6"
   PKG_CHECK_MODULES(xcb, $xcb_REQUIRES, ,
 		    [use_xcb="no (requires $xcb_REQUIRES https://xcb.freedesktop.org)"])
@@ -190,6 +192,7 @@ CAIRO_ENABLE_FUNCTIONS(xcb_shm, XCB/SHM, auto, [
 dnl ===========================================================================
 
 CAIRO_ENABLE_SURFACE_BACKEND(qt, Qt, no, [
+  dnl Keep in sync with meson.build!
   qt_REQUIRES="QtGui >= 4.4.0"
   PKG_CHECK_MODULES(qt, $qt_REQUIRES, ,
 		    [qt_REQUIRES=""
@@ -279,6 +282,7 @@ CAIRO_ENABLE_SURFACE_BACKEND(beos, BeOS/Zeta, no, [
 dnl ===========================================================================
 
 CAIRO_ENABLE_SURFACE_BACKEND(drm, DRM, no, [
+  dnl Keep in sync with meson.build!
   drm_REQUIRES="libudev >= 136, libdrm >= 2.4"
   PKG_CHECK_MODULES(drm, $drm_REQUIRES, ,
    [use_drm="no (requires $drm_REQUIRES, udev is available from git://git.kernel.org/pub/scm/linux/hotplug/udev.git)"])
@@ -396,7 +400,7 @@ CAIRO_ENABLE_SURFACE_BACKEND(glesv3, OpenGLESv3, no, [
 
 dnl ===========================================================================
 CAIRO_ENABLE_SURFACE_BACKEND(cogl, Cogl, no, [
-  cogl_REQUIRES="cogl-2.0-experimental"
+  cogl_REQUIRES="cogl-2.0-experimental >= 1.17.2"
   PKG_CHECK_MODULES(cogl, $cogl_REQUIRES,, [use_cogl="no"])
 ])
 
@@ -504,6 +508,7 @@ dnl ===========================================================================
 # release number - for information only
 FREETYPE_MIN_RELEASE=2.1.9
 # libtool-specific version - this is what is checked
+# Keep in sync with meson.build!
 FREETYPE_MIN_VERSION=9.7.3
 
 CAIRO_ENABLE_FONT_BACKEND(ft, FreeType, auto, [
@@ -538,6 +543,7 @@ CAIRO_ENABLE_FONT_BACKEND(ft, FreeType, auto, [
   ft_LIBS="$FREETYPE_LIBS"
 ])
 
+# Keep in sync with meson.build!
 FONTCONFIG_MIN_VERSION=2.2.95
 CAIRO_ENABLE_FONT_BACKEND(fc, Fontconfig, auto, [
   use_fc=$use_ft
@@ -587,6 +593,7 @@ CAIRO_ENABLE_SURFACE_BACKEND(ps, PostScript, yes, [
 
 dnl ===========================================================================
 
+# Keep in sync with meson.build!
 SPECTRE_VERSION_REQUIRED=0.2.0
 test_ps=no
 any2ppm_ps=no
@@ -625,6 +632,7 @@ CAIRO_ENABLE_SURFACE_BACKEND(pdf, PDF, yes, [
 dnl ===========================================================================
 
 # poppler-0.17.4 fixes text-pattern and text-transform
+# Keep in sync with meson.build!
 POPPLER_VERSION_REQUIRED=0.17.4
 test_pdf=no
 any2ppm_pdf=no
@@ -656,6 +664,7 @@ CAIRO_ENABLE_SURFACE_BACKEND(svg, SVG, yes, [
   fi
 ])
 
+dnl Keep in sync with meson.build!
 LIBRSVG_VERSION_REQUIRED=2.35.0
 test_svg=no
 any2ppm_svg=no
@@ -685,6 +694,7 @@ CAIRO_ENABLE(test_surfaces, test surfaces, no)
 dnl ===========================================================================
 
 CAIRO_ENABLE_SURFACE_BACKEND(image, image, always, [
+  dnl Keep in sync with meson.build!
   pixman_REQUIRES="pixman-1 >= 0.36.0"
   PKG_CHECK_MODULES(pixman, $pixman_REQUIRES, ,
     [use_image="no (requires $pixman_REQUIRES https://cairographics.org/releases/)"])
@@ -733,6 +743,7 @@ dnl ===========================================================================
 dnl Build gobject integration library
 
 CAIRO_ENABLE_FUNCTIONS(gobject, gobject, auto, [
+  dnl Keep in sync with meson.build!
   gobject_REQUIRES="gobject-2.0 glib-2.0 >= 2.14"
   PKG_CHECK_MODULES(GOBJECT, $gobject_REQUIRES, ,
     [use_gobject="no (requires $gobject_REQUIRES https://download.gnome.org/pub/GNOME/sources/glib/)"])
@@ -828,7 +839,7 @@ CAIRO_ENABLE(symbol_lookup, symbol-lookup, auto, [
 PKG_CHECK_MODULES(glib, glib-2.0, have_glib=yes, have_glib=no)
 AC_SUBST(glib_CFLAGS)
 AC_SUBST(glib_LIBS)
-AM_CONDITIONAL(BUILD_SPHINX, test "x$have_glib" = "xyes" -a "x$have_windows" = "xno")
+AM_CONDITIONAL(BUILD_SPHINX, test "x$have_glib" = "xyes" -a "x$have_windows" = "xno" -a "x$have_png" = "xyes")
 
 save_LIBS="$LIBS"
 AC_CHECK_LIB(rt, shm_open, shm_LIBS="-lrt")
diff --git a/meson-cc-tests/atomic-ops-cxx11.c b/meson-cc-tests/atomic-ops-cxx11.c
new file mode 100644
index 000000000..aeef0d849
--- /dev/null
+++ b/meson-cc-tests/atomic-ops-cxx11.c
@@ -0,0 +1,3 @@
+int atomic_add(int i) { return __atomic_fetch_add(&i, 1, __ATOMIC_SEQ_CST); }
+int atomic_cmpxchg(int i, int j, int k) { return __atomic_compare_exchange_n(&i, &j, k, 0, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST); }
+int main(void) { return 0; }
diff --git a/meson-cc-tests/atomic-ops-gcc-legacy.c b/meson-cc-tests/atomic-ops-gcc-legacy.c
new file mode 100644
index 000000000..99331968d
--- /dev/null
+++ b/meson-cc-tests/atomic-ops-gcc-legacy.c
@@ -0,0 +1,3 @@
+int atomic_add(int i) { return __sync_fetch_and_add (&i, 1); }
+int atomic_cmpxchg(int i, int j, int k) { return __sync_val_compare_and_swap (&i, j, k); }
+int main(void) { return 0; }
diff --git a/meson-cc-tests/ft_has_color.c b/meson-cc-tests/ft_has_color.c
new file mode 100644
index 000000000..daeed7f35
--- /dev/null
+++ b/meson-cc-tests/ft_has_color.c
@@ -0,0 +1,7 @@
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+int main(void) {
+  FT_Long has_color = FT_HAS_COLOR(((FT_Face)NULL));
+  return 0;
+}
diff --git a/meson-cc-tests/ipc_rmid_deferred_release.c b/meson-cc-tests/ipc_rmid_deferred_release.c
new file mode 100644
index 000000000..2c9290d25
--- /dev/null
+++ b/meson-cc-tests/ipc_rmid_deferred_release.c
@@ -0,0 +1,18 @@
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+int main()
+{
+    char *shmaddr;
+    int id = shmget (IPC_PRIVATE, 4, IPC_CREAT | 0600);
+    if (id == -1) return 2;
+    shmaddr = shmat (id, 0, 0);
+    shmctl (id, IPC_RMID, 0);
+    if ((char*) shmat (id, 0, 0) == (char*) -1) {
+  shmdt (shmaddr);
+  return 1;
+    }
+    shmdt (shmaddr);
+    shmdt (shmaddr);
+    return 0;
+}
diff --git a/meson-cc-tests/mkdir-variant-1.c b/meson-cc-tests/mkdir-variant-1.c
new file mode 100644
index 000000000..88910d107
--- /dev/null
+++ b/meson-cc-tests/mkdir-variant-1.c
@@ -0,0 +1,12 @@
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#ifdef HAVE_IO_H
+#include <io.h>
+#endif
+
+int main(int ac, char **av)
+{
+  mkdir("hello.world");
+  return 0;
+}
diff --git a/meson-cc-tests/mkdir-variant-2.c b/meson-cc-tests/mkdir-variant-2.c
new file mode 100644
index 000000000..d0ab7b298
--- /dev/null
+++ b/meson-cc-tests/mkdir-variant-2.c
@@ -0,0 +1,12 @@
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#ifdef HAVE_IO_H
+#include <io.h>
+#endif
+
+int main(int ac, char **av)
+{
+  mkdir("hello.world", 0777);
+  return 0;
+}
diff --git a/meson-cc-tests/pthread.c b/meson-cc-tests/pthread.c
new file mode 100644
index 000000000..035cb3a94
--- /dev/null
+++ b/meson-cc-tests/pthread.c
@@ -0,0 +1,35 @@
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE /* for PTHREAD_MUTEX_INITIALIZER under linux */
+#endif
+#include <pthread.h>
+
+pthread_mutex_t test_mutex_initializer = PTHREAD_MUTEX_INITIALIZER;
+int test_mutex (void)
+{
+	int x = 0;
+	pthread_mutex_t mutex;
+	x |= pthread_mutex_init (&mutex, NULL);
+	x |= pthread_mutex_lock (&mutex);
+	x |= pthread_mutex_unlock (&mutex);
+	x |= pthread_mutex_destroy (&mutex);
+	return 0;
+}
+
+int test_mutex_attr (void)
+{
+	int x = 0;
+	pthread_mutexattr_t attr;
+	pthread_mutex_t mutex;
+	x |= pthread_mutexattr_init (&attr);
+	x |= pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);
+	x |= pthread_mutex_init (&mutex, &attr);
+	x |= pthread_mutex_lock (&mutex);
+	x |= pthread_mutex_unlock (&mutex);
+	x |= pthread_mutex_destroy (&mutex);
+	x |= pthread_mutexattr_destroy (&attr);
+	return x;
+}
+
+int main(void) {
+  return 0;
+}
diff --git a/meson.build b/meson.build
new file mode 100644
index 000000000..13c5482b6
--- /dev/null
+++ b/meson.build
@@ -0,0 +1,990 @@
+project('cairo', 'c', 'cpp',
+  meson_version: '>= 0.50.0',
+  version: '1.17.3',
+)
+
+cc = meson.get_compiler('c')
+
+# Keep in sync with configure.ac!
+freetype_required_version = '>= 9.7.3'
+fontconfig_required_version = '>= 2.2.95'
+xrender_required_version = '>= 0.6'
+xcb_required_version = '>= 1.6'
+xcb_render_required_version = '>= 1.6'
+qtgui_required_version = '>= 4.4.0'
+libudev_required_version = '>= 136'
+libdrm_required_version = '>= 2.4'
+glib_required_version = '>= 2.14'
+
+if cc.get_id() == 'msvc'
+  # Basic usage in the cairo type system that causes spammy and useless warnings
+  add_project_arguments('/wd4244', '/wd4146',
+                        # Don't warn about double -> float truncation
+                        '/wd4305',
+                        language : 'c')
+endif
+
+# Make sure source directory hasn't been configured with autotools
+if meson.version().version_compare('>= 0.53')
+  fs = import('fs')
+  if fs.exists('config.h') or fs.exists('src/cairo-features.h') or fs.exists('src/cairo-supported-features.h')
+    error('''
+          The source directory '@0@' appears to contain
+          autotools configuration artifacts. This can cause difficult to
+          debug build problems. Please clean it up and then re-run meson.
+          '''.format(meson.source_root()))
+  endif
+endif
+
+pkgmod = import('pkgconfig')
+python3 = import('python').find_installation()
+
+check_sizeofs = [
+  ['void *', {'conf-name': 'SIZEOF_VOID_P'}],
+  ['int'],
+  ['long'],
+  ['long long'],
+  ['size_t'],
+]
+
+check_headers = [
+  ['stdint.h'],
+  ['inttypes.h'],
+  ['sys/int_types.h'],
+  ['fcntl.h'],
+  ['unistd.h'],
+  ['signal.h'],
+  ['sys/stat.h'],
+  ['sys/socket.h'],
+  ['poll.h'],
+  ['sys/poll.h'],
+  ['sys/un.h'],
+  ['sched.h', {'check-funcs': ['sched_getaffinity']}],
+  ['sys/mman.h', {'check-funcs': ['mmap']}],
+  ['time.h', {'check-funcs': ['clock_gettime']}],
+  ['libgen.h'],
+  ['byteswap.h'],
+  ['signal.h'],
+  ['setjmp.h'],
+  ['fenv.h'],
+  ['sys/wait.h'],
+  ['sys/stat.h'],
+  ['io.h'],
+  ['fenv.h', {'check-funcs': ['feenableexcept', 'fedisableexcept', 'feclearexcept']}],
+  ['xlocale.h'],
+  ['sys/ioctl.h'],
+]
+
+check_types = [
+  ['uint64_t', {'headers': ['stdint.h']}],
+  ['uint128_t', {'headers': ['stdint.h']}],
+  ['__uint128_t']
+]
+
+check_funcs = [
+  'alarm',
+  'ctime_r',
+  'localtime_r',
+  'gmtime_r',
+  'drand48',
+  'flockfile',
+  'funlockfile',
+  'getline',
+  'link',
+  'strndup',
+  'fork',
+  'waitpid',
+  'raise',
+  'newlocale',
+  'strtod_l',
+]
+
+check_thread_flags = [
+  [['-D_REENTRANT'], ['-lpthread']],
+  [['-pthread'], []],
+  [['-D_REENTRANT'], [], {'real': false}],
+]
+
+m_dep = cc.find_library('m', required: false)
+# Used in util
+gtk_dep = dependency('gtk+-2.0', required: get_option('gtk2-utils'))
+
+deps = [m_dep]
+test_deps = []
+internal_deps = []
+extra_link_args = []
+
+conf = configuration_data()
+
+lzo_dep = dependency('lzo2', required: false)
+if lzo_dep.found()
+  deps += [lzo_dep]
+  conf.set('HAVE_LZO', 1)
+endif
+
+dl_dep = cc.find_library('dl', required: false)
+if dl_dep.found() and cc.has_function('dlsym', dependencies: [dl_dep])
+  deps += [dl_dep]
+  conf.set('CAIRO_HAS_DLSYM', 1)
+elif cc.has_function('dlsym')
+  conf.set('CAIRO_HAS_DLSYM', 1)
+elif cc.has_function('dlsym', prefix: '#include <dlfcn.h>')
+  conf.set('CAIRO_HAS_DLSYM', 1)
+endif
+
+feature_conf = configuration_data()
+
+# Array of dictionaries, used to generate per-feature pc files
+# Mandatory keys: name, description
+# Optional keys: requires, libs
+built_features = []
+
+zlib_dep = dependency('zlib',
+  required: get_option('zlib'),
+  fallback : ['zlib', 'zlib_dep'],
+)
+if zlib_dep.found()
+  if zlib_dep.type_name() == 'internal'
+    internal_deps += [zlib_dep]
+  else
+    deps += [zlib_dep]
+  endif
+  conf.set('HAVE_ZLIB', 1)
+endif
+
+png_dep = dependency('libpng',
+  required: get_option('png'),
+  fallback: ['libpng', 'png_dep']
+)
+if png_dep.found()
+  feature_conf.set('CAIRO_HAS_SVG_SURFACE', 1)
+  feature_conf.set('CAIRO_HAS_PNG_FUNCTIONS', 1)
+  built_features += [
+    {
+      'name': 'cairo-png',
+      'description': 'PNG functions',
+      'requires': 'libpng',
+    },
+    {
+      'name': 'cairo-svg',
+      'description': 'SVG surface backend',
+      'requires': 'libpng',
+    }
+  ]
+
+  if png_dep.type_name() == 'internal'
+    internal_deps += [png_dep]
+  else
+    deps += [png_dep]
+  endif
+endif
+
+freetype_dep = dependency('freetype2',
+  required: get_option('freetype'),
+  version: freetype_required_version,
+  fallback: ['freetype2', 'freetype_dep'],
+)
+if freetype_dep.found()
+  feature_conf.set('CAIRO_HAS_FT_FONT', 1)
+  built_features += [{
+    'name': 'cairo-ft',
+    'description': 'Freetype font backend',
+    'requires': 'freetype2 @0@'.format(freetype_required_version)
+  }]
+
+  ft_check_funcs = [
+    'FT_Get_X11_Font_Format',
+    'FT_GlyphSlot_Embolden',
+    'FT_GlyphSlot_Oblique',
+    'FT_Load_Sfnt_Table',
+    'FT_Library_SetLcdFilter',
+    'FT_Get_Var_Design_Coordinates',
+    'FT_Done_MM_Var',
+  ]
+
+  if freetype_dep.type_name() == 'internal'
+    foreach func : ft_check_funcs
+      conf.set('HAVE_@0@'.format(func.to_upper()), 1)
+    endforeach
+    internal_deps += [freetype_dep]
+  else
+    if not cc.links(files('meson-cc-tests/ft_has_color.c'), dependencies: freetype_dep, name: 'FT has color')
+      conf.set('FT_HAS_COLOR', '(0)')
+    endif
+    check_funcs += ft_check_funcs
+    deps += [freetype_dep]
+  endif
+endif
+
+fontconfig_dep = dependency('fontconfig',
+  required: get_option('fontconfig'),
+  version: fontconfig_required_version,
+  fallback: ['fontconfig', 'fontconfig_dep'],
+)
+if fontconfig_dep.found()
+  fc_check_funcs = [
+    'FcInit',
+    'FcFini'
+  ]
+
+  if fontconfig_dep.type_name() == 'internal'
+    foreach func : fc_check_funcs
+      conf.set('HAVE_@0@'.format(func.to_upper()), 1)
+    endforeach
+    internal_deps += [fontconfig_dep]
+  else
+    check_funcs += fc_check_funcs
+    deps += [fontconfig_dep]
+  endif
+
+  feature_conf.set('CAIRO_HAS_FC_FONT', 1)
+  built_features += [{
+    'name': 'cairo-fc',
+    'description': 'Fontconfig font backend',
+    'requires': 'fontconfig @0@'.format(fontconfig_required_version)
+  }]
+endif
+
+x11_dep = dependency('x11', required: get_option('xlib'))
+xext_dep = dependency('xext', required: get_option('xlib'))
+if x11_dep.found() and xext_dep.found()
+  feature_conf.set('CAIRO_HAS_XLIB_SURFACE', 1)
+  built_features += [{
+    'name': 'cairo-xlib',
+    'description': 'Xlib surface backend',
+    'requires': 'x11 xext',
+  }]
+
+  extra_headers = ['X11/Xlibint.h', 'X11/Xproto.h']
+  check_headers += [
+    ['X11/extensions/XShm.h', {'extra-headers': extra_headers}],
+    ['X11/extensions/shmproto.h', {'extra-headers': extra_headers}],
+    ['X11/extensions/shmstr.h', {'extra-headers': extra_headers}],
+  ]
+  deps += [x11_dep, xext_dep]
+  res = cc.run(files('meson-cc-tests/ipc_rmid_deferred_release.c'),
+    dependencies: [x11_dep, xext_dep],
+    name: 'shmctl IPC_RMID allowes subsequent attaches')
+
+  if res.returncode() == 0
+    conf.set('IPC_RMID_DEFERRED_RELEASE', 1)
+  endif
+endif
+
+if feature_conf.get('CAIRO_HAS_XLIB_SURFACE', 0) == 1
+  xrender_dep = dependency('xrender', required: get_option('xlib'),
+                           version: xrender_required_version)
+
+  if xrender_dep.found()
+    check_funcs += [
+      'XRenderCreateSolidFill',
+      'XRenderCreateLinearGradient',
+      'XRenderCreateRadialGradient',
+      'XRenderCreateConicalGradient',
+    ]
+
+    deps += [xrender_dep]
+
+    built_features += [{
+      'name': 'cairo-xlib-xrender',
+      'description': 'Xlib Xrender surface backend',
+      'requires': 'xrender @0@'.format(xrender_required_version),
+    }]
+    feature_conf.set('CAIRO_HAS_XLIB_XRENDER_SURFACE', 1)
+  endif
+endif
+
+xcb_dep = dependency('xcb', required: get_option('xcb'),
+                     version: xcb_required_version)
+xcb_render_dep = dependency('xcb-render', required: get_option('xcb'),
+                            version: xcb_render_required_version)
+if xcb_dep.found() and xcb_render_dep.found()
+  feature_conf.set('CAIRO_HAS_XCB_SURFACE', 1)
+  built_features += [{
+    'name': 'cairo-xcb',
+    'description': 'XCB surface backend',
+    'requires': 'xcb @0@ xcb-render @1@'.format(xcb_required_version, xcb_render_required_version),
+  }]
+
+  deps += [xcb_dep, xcb_render_dep]
+endif
+
+if feature_conf.get('CAIRO_HAS_XCB_SURFACE', 0) == 1 and feature_conf.get('CAIRO_HAS_XLIB_SURFACE', 0) == 1
+  # FIXME: automagic
+  x11xcb_dep = dependency('x11-xcb', required: false)
+  if x11xcb_dep.found()
+    deps += [x11xcb_dep]
+    feature_conf.set('CAIRO_HAS_XLIB_XCB_FUNCTIONS', 1)
+    built_features += [{
+      'name': 'cairo-xlib-xcb',
+      'description': 'Xlib/XCB functions',
+      'requires': 'x11-xcb',
+    }]
+  endif
+endif
+
+if feature_conf.get('CAIRO_HAS_XCB_SURFACE', 0) == 1
+  xcbshm_dep = dependency('xcb-shm', required: get_option('xcb'))
+  if xcbshm_dep.found()
+    feature_conf.set('CAIRO_HAS_XCB_SHM_FUNCTIONS', 1)
+    deps += [xcbshm_dep]
+    built_features += [{
+      'name': 'cairo-xcb-shm',
+      'description': 'XCB/SHM functions',
+      'requires': 'xcb-shm',
+    }]
+  endif
+endif
+
+# Tests crash and burn
+qtgui_dep = dependency('QtGui', required: get_option('qt'),
+                       version: qtgui_required_version)
+if qtgui_dep.found() and false
+  feature_conf.set('CAIRO_HAS_QT_SURFACE', 1)
+  built_features += [{
+    'name': 'cairo-qt',
+    'description': 'Qt surface backend',
+    'requires': 'QtGui @0@'.format(qtgui_required_version),
+    'libs': qtgui_extra_libs,
+  }]
+
+  deps += [qtgui_dep]
+  qtgui_extra_libs = ['-lstdc++']
+  extra_link_args += qtgui_extra_libs
+endif
+
+# Untested
+if cc.has_header('ApplicationServices/ApplicationServices.h')
+  if cc.has_header('CoreGraphics/CoreGraphics.h')
+    quartz_extra_libs = ['-Xlinker', '-framework', '-Xlinker', 'CoreGraphics']
+  else
+    quartz_extra_libs = ['-Xlinker', '-framework', '-Xlinker', 'ApplicationServices']
+  endif
+
+  extra_link_args += quartz_extra_libs
+
+  feature_conf.set('CAIRO_HAS_QUARTZ_SURFACE', 1)
+  feature_conf.set('CAIRO_HAS_QUARTZ_FONT', 1)
+  feature_conf.set('CAIRO_HAS_QUARTZ_IMAGE_SURFACE', 1)
+
+  built_features += [
+    {
+      'name': 'cairo-quartz',
+      'description': 'Quartz surface backend',
+      'libs': quartz_extra_libs,
+    },
+    {
+      'name': 'cairo-quartz-image',
+      'description': 'Quartz Image surface backend',
+      'libs': quartz_extra_libs,
+    },
+    {
+      'name': 'cairo-quartz-font',
+      'description': 'Quartz font backend',
+      'libs': quartz_extra_libs,
+    },
+  ]
+endif
+
+if host_machine.system() == 'windows'
+  win32_extra_libs = []
+  foreach libname: ['gdi32', 'msimg32']
+    deps += [cc.find_library(libname)]
+    win32_extra_libs += ['-l' + libname]
+  endforeach
+
+  feature_conf.set('CAIRO_HAS_WIN32_SURFACE', 1)
+  built_features += [{
+    'name': 'cairo-win32',
+    'description': 'Microsoft Windows surface backend',
+    'libs': win32_extra_libs,
+  }]
+endif
+
+if feature_conf.get('CAIRO_HAS_WIN32_SURFACE', 0) == 1
+  feature_conf.set('CAIRO_HAS_WIN32_FONT', 1)
+  built_features += [{
+    'name': 'cairo-win32-font',
+    'description': 'Microsoft Windows font backend',
+    'libs': win32_extra_libs,
+  }]
+endif
+
+# FIXME: Doesn't build since at least 2011
+libudev_dep = dependency('libudev', required: get_option('drm'),
+                         version: libudev_required_version)
+libdrm_dep = dependency('libdrm', required: get_option('drm'),
+                        version: libdrm_required_version)
+if libudev_dep.found() and libdrm_dep.found() and false
+  deps += [libudev_dep, libdrm_dep]
+
+  feature_conf.set('CAIRO_HAS_DRM_SURFACE', 1)
+  built_features += [{
+    'name': 'cairo-drm',
+    'description': 'DRM surface backend',
+    'requires': 'libudev @0@ libdrm @1@'.format(libudev_required_version, libdrm_required_version),
+  }]
+endif
+
+# Not even trying to port gallium as it depends on drm
+
+# Not porting BEOS or OS/2 backends either, meson doesn't support those
+
+# GL / GLESV2 / GLESV3 are mutually exclusive
+gl_backend = get_option('gl-backend')
+use_gl = false
+need_egl_functions = false
+need_wgl_functions = false
+need_glx_functions = false
+
+if gl_backend in ['auto', 'gl']
+  gl_dep = dependency('gl', required: gl_backend == 'gl')
+  if not gl_dep.found()
+    if cc.has_header('GL/gl.h')
+      gl_extra_libs = ['-lGL']
+      gl_requires = ''
+      extra_link_args += gl_extra_libs
+      use_gl = true
+    endif
+  elif cc.has_header('GL/gl.h', dependencies: gl_dep) and cc.has_header('GL/glext.h', dependencies: gl_dep)
+    use_gl = true
+    gl_extra_libs = []
+    gl_requires = 'gl'
+    deps += [gl_dep]
+  endif
+endif
+
+
+if use_gl
+  need_egl_functions = true
+  need_wgl_functions = true
+  need_glx_functions = true
+
+  feature_conf.set('CAIRO_HAS_GL_SURFACE', 1)
+  built_features += [{
+    'name': 'cairo-gl',
+    'description': 'OpenGL surface backend',
+    'requires': gl_requires,
+    'libs': gl_extra_libs,
+  }]
+endif
+
+if feature_conf.get('CAIRO_HAS_GL_SURFACE', 0) == 0 and ['auto', 'glesv2'].contains(gl_backend)
+  use_glesv2 = false
+  glesv2_dep = dependency('glesv2', required: gl_backend == 'glesv2')
+  if not glesv2_dep.found()
+    if cc.has_header('GLES2/gl2.h')
+      use_glesv2 = true
+      glesv2_extra_libs = ['-lGLESv2']
+      glesv2_requires = ''
+      extra_link_args += glesv2_extra_libs
+    endif
+  else
+    glesv2_extra_libs = []
+    glesv2_requires = 'glesv2'
+    use_glesv2 = true
+    deps += [glesv2_dep]
+  endif
+
+  if use_glesv2
+    need_egl_functions = true
+
+    feature_conf.set('CAIRO_HAS_GLESV2_SURFACE', 1)
+    built_features += [{
+      'name': 'cairo-glesv2',
+      'source-key': 'cairo-gl',
+      'description': 'OpenGLESv2 surface backend',
+      'requires': glesv2_requires,
+      'libs': glesv2_extra_libs,
+    }]
+  endif
+endif
+
+if feature_conf.get('CAIRO_HAS_GL_SURFACE', 0) == 0 and feature_conf.get('CAIRO_HAS_GLESV2_SURFACE', 0) == 0 and ['auto', 'glesv3'].contains(gl_backend)
+  use_glesv3 = false
+  # glesv3 is provided via libGLESv2.so (there is no libGLESv3, nor glesv3.pc)
+  glesv3_dep = dependency('glesv2', required: gl_backend == 'glesv3')
+  if cc.has_header('GLES3/gl3.h', dependencies: glesv3_dep)
+    use_glesv3 = true
+    if not glesv3_dep.found()
+      glesv3_extra_libs = ['-lGLESv2']
+      extra_link_args += glesv3_extra_libs
+      glesv3_requires = ''
+    else
+      glesv3_extra_libs = []
+      glesv3_requires = 'glesv2'
+      deps += [glesv3_dep]
+    endif
+  endif
+
+  if use_glesv3
+    need_egl_functions = true
+
+    feature_conf.set('CAIRO_HAS_GLESV3_SURFACE', 1)
+    built_features += [{
+      'name': 'cairo-glesv3',
+      'source-key': 'cairo-gl',
+      'description': 'OpenGLESv3 surface backend',
+      'requires': glesv3_requires,
+      'libs': glesv3_extra_libs,
+    }]
+  endif
+endif
+
+cogl_dep = dependency('cogl-2.0-experimental',
+  version: '>= 1.17.2',
+  required: get_option('cogl'),
+)
+if cogl_dep.found()
+  deps += [cogl_dep]
+
+  feature_conf.set('CAIRO_HAS_COGL_SURFACE', 1)
+  built_features += [{
+    'name': 'cairo-cogl',
+    'description': 'Cogl surface backend',
+    'requires': 'cogl-2.0-experimental',
+  }]
+endif
+
+# Untested
+directfb_dep = dependency('directfb', required: get_option('directfb'))
+if directfb_dep.found()
+  deps += [directfb_dep]
+
+  feature_conf.set('CAIRO_HAS_DIRECTFB_SURFACE', 1)
+  built_features += [{
+    'name': 'cairo-directfb',
+    'description': 'directfb surface backend',
+    'requires': 'directfb',
+  }]
+endif
+
+# Untested
+openvg_dep = cc.find_library('OpenVG', has_headers: 'VG/openvg.h', required: get_option('openvg'))
+if openvg_dep.found()
+  # can we use the dep here somehow instead?
+  openvg_extra_libs = ['-lOpenVG']
+  extra_link_args += openvg_extra_libs
+  need_egl_functions = true
+  need_glx_functions = true
+
+  feature_conf.set('CAIRO_HAS_VG_SURFACE', 1)
+  built_features += [{
+    'name': 'cairo-vg',
+    'description': 'OpenVG surface backend',
+    'libs': openvg_extra_libs,
+  }]
+endif
+
+if need_egl_functions
+  # FIXME: automagic
+  egl_dep = dependency('egl', required: false)
+  use_egl = false
+  egl_extra_libs = []
+  egl_requires = ''
+
+  if not egl_dep.found()
+    if cc.has_header('EGL/egl.h')
+      egl_extra_deps = []
+      csi_dep = cc.find_library('csi', required: false)
+      if csi_dep.found() and cc.has_function('csi_stream_attachresource', dependencies: [csi_dep])
+        egl_extra_deps = [csi_dep]
+        egl_extra_libs = ['-lcsi']
+      endif
+
+      foreach libname : ['EGL', 'egl13', 'egl12', 'egl11']
+        dep = cc.find_library(libname, required: false)
+        if dep.found() and cc.has_function('eglGetError', dependencies: [dep])
+          deps += [dep] + egl_extra_deps
+          egl_extra_libs += ['-l@0@'.format(libname)]
+          use_egl = true
+          break
+        endif
+      endforeach
+    endif
+  else
+    use_egl = true
+    egl_requires = 'egl'
+    deps += [egl_dep]
+  endif
+
+  if use_egl
+    feature_conf.set('CAIRO_HAS_EGL_FUNCTIONS', 1)
+    built_features += [{
+      'name': 'cairo-egl',
+      'description': 'EGL functions',
+      'libs': egl_extra_libs,
+      'requires': egl_requires,
+    }]
+  endif
+endif
+
+if need_glx_functions
+  # FIXME: automagic
+  if cc.has_header('GL/glx.h')
+    feature_conf.set('CAIRO_HAS_GLX_FUNCTIONS', 1)
+    built_features += [{
+      'name': 'cairo-glx',
+      'description': 'GLX functions',
+      'libs': ['-lGL'],
+    }]
+  endif
+endif
+
+# Untested
+if need_wgl_functions
+  # FIXME: automagic
+  if cc.has_header('windows.h')
+    feature_conf.set('CAIRO_HAS_WGL_FUNCTIONS', 1)
+    built_features += [{
+      'name': 'cairo-wgl',
+      'description': 'WGL functions',
+    }]
+  endif
+endif
+
+gobject_dep = dependency('gobject-2.0',
+  required: get_option('glib'),
+  fallback: ['glib', 'libgobject_dep']
+)
+glib_dep = dependency('glib-2.0',
+  required: get_option('glib'),
+  version: glib_required_version,
+  fallback: ['glib', 'libglib_dep'],
+)
+if gobject_dep.found() and glib_dep.found()
+  feature_conf.set('CAIRO_HAS_GOBJECT_FUNCTIONS', 1)
+  built_features += [{
+    'name': 'cairo-gobject',
+    'description': 'gobject functions',
+    'requires': 'gobject-2.0 glib-2.0 @0@'.format(glib_required_version),
+    'libs': ['-lcairo-gobject'],
+  }]
+endif
+
+if zlib_dep.found()
+  feature_conf.set('CAIRO_HAS_SCRIPT_SURFACE', 1)
+  built_features += [{
+    'name': 'cairo-script',
+    'description': 'script surface backend',
+    'requires': 'zlib',
+  }]
+endif
+
+if zlib_dep.found()
+  feature_conf.set('CAIRO_HAS_PS_SURFACE', 1)
+  built_features += [{
+    'name': 'cairo-ps',
+    'description': 'PostScript surface backend',
+    'requires': 'zlib',
+  }]
+endif
+
+if zlib_dep.found()
+  feature_conf.set('CAIRO_HAS_PDF_SURFACE', 1)
+  built_features += [{
+    'name': 'cairo-pdf',
+    'description': 'PDF surface backend',
+    'requires': 'zlib',
+  }]
+endif
+
+if zlib_dep.found()
+  feature_conf.set('CAIRO_HAS_INTERPRETER', 1)
+endif
+
+# TODO: add xml option and disable by default
+if zlib_dep.found() and png_dep.found()
+  feature_conf.set('CAIRO_HAS_XML_SURFACE', 1)
+  built_features += [{
+    'name': 'cairo-xml',
+    'description': 'XML surface backend',
+    'requires': 'zlib',
+  }]
+endif
+
+# Untested, libiberty.h is in a libiberty subfolder for me
+# FIXME: automagic
+bfd_dep = cc.find_library('bfd', required: false)
+if bfd_dep.found() and cc.has_function('bfd_openr', dependencies: [bfd_dep])
+  if cc.has_header('libiberty.h')
+    conf.set('HAVE_BFD', 1)
+    deps += [bfd_dep]
+  endif
+endif
+
+# Untested, see above
+if conf.get('HAVE_BFD', 0) == 1
+  conf.set('CAIRO_HAS_SYMBOL_LOOKUP', 1)
+endif
+
+if feature_conf.get('CAIRO_HAS_PS_SURFACE', 0) == 1
+  gs = find_program('gs', required: get_option('tests'))
+  libspectre_dep = dependency('libspectre', version: '>= 0.2.0',
+                              required: get_option('spectre'))
+  if gs.found() and libspectre_dep.found()
+    conf.set('CAIRO_CAN_TEST_PS_SURFACE', 1)
+  endif
+
+  if libspectre_dep.found()
+    conf.set('CAIRO_HAS_SPECTRE', 1)
+    deps += [libspectre_dep]
+  endif
+endif
+
+if feature_conf.get('CAIRO_HAS_PDF_SURFACE', 0) == 1
+  poppler_dep = dependency('poppler-glib', version: '>= 0.17.4',
+                           required: get_option('tests'))
+  if poppler_dep.found() and cc.has_function('poppler_page_render', dependencies: [poppler_dep])
+    conf.set('CAIRO_CAN_TEST_PDF_SURFACE', 1)
+    test_deps += [poppler_dep]
+  endif
+endif
+
+if feature_conf.get('CAIRO_HAS_SVG_SURFACE', 0) == 1
+  librsvg_dep = dependency('librsvg-2.0', version: '>= 2.35.0',
+                           required: get_option('tests'))
+  if librsvg_dep.found()
+    conf.set('CAIRO_CAN_TEST_SVG_SURFACE', 1)
+    test_deps += [librsvg_dep]
+  endif
+endif
+
+pixman_dep = dependency('pixman-1',
+  version: '>= 0.36.0',
+  fallback: ['pixman', 'idep_pixman'],
+)
+if pixman_dep.found()
+  feature_conf.set('CAIRO_HAS_IMAGE_SURFACE', 1)
+  conf.set('HAS_PIXMAN_GLYPHS', 1)
+  if pixman_dep.type_name() == 'internal'
+    internal_deps += [pixman_dep]
+  else
+    deps += [pixman_dep]
+  endif
+endif
+
+feature_conf.set('CAIRO_FEATURES_H', true)
+feature_conf.set('CAIRO_HAS_USER_FONT', 1)
+
+feature_conf.set('CAIRO_HAS_MIME_SURFACE', 1)
+feature_conf.set('CAIRO_HAS_RECORDING_SURFACE', 1)
+feature_conf.set('CAIRO_HAS_OBSERVER_SURFACE', 1)
+
+if not get_option('tee').disabled()
+  feature_conf.set('CAIRO_HAS_TEE_SURFACE', 1)
+  built_features += [{
+    'name': 'cairo-tee',
+    'description': 'Tee surface backend',
+  }]
+endif
+
+incbase = include_directories('.')
+
+foreach check : check_sizeofs
+  type = check[0]
+  opts = check.length() > 1 ? check[1] : {}
+
+  conf_name = opts.get('conf-name', 'SIZEOF_@0@'.format(type.underscorify().to_upper()))
+
+  conf.set(conf_name, cc.sizeof(type))
+endforeach
+
+foreach check : check_headers
+  name = check[0]
+  opts = check.length() > 1 ? check[1] : {}
+  prefix = ''
+
+  foreach header : opts.get('extra-headers', [])
+    prefix += '#include <@0@>\n'.format(header)
+  endforeach
+
+  if cc.has_header(name, prefix: prefix)
+    conf.set('HAVE_@0@'.format(name.to_upper().underscorify()), 1)
+    check_funcs += check.length() > 1 ? check[1].get('check-funcs', []) : []
+  endif
+endforeach
+
+foreach check : check_types
+  name = check[0]
+  opts = check.length() > 1 ? check[1] : {}
+  prefix = ''
+
+  foreach header : opts.get('headers', [])
+    prefix += '#include <@0@>\n'.format(header)
+  endforeach
+
+  if cc.has_type(name, prefix: prefix)
+    conf.set('HAVE_@0@'.format(name.to_upper()), 1)
+  endif
+endforeach
+
+foreach name : check_funcs
+  if cc.has_function(name, dependencies: deps)
+    conf.set('HAVE_@0@'.format(name.to_upper()), 1)
+  endif
+endforeach
+
+pthread_c_args = []
+pthread_link_args = []
+
+foreach thread_flags : check_thread_flags
+  if not conf.has('CAIRO_HAS_PTHREAD')
+    cflags = thread_flags[0]
+    lflags = thread_flags[1]
+    real_pthread = thread_flags.length() > 2 ? thread_flags[2].get('real', true) : true
+
+    if cc.links(files('meson-cc-tests/pthread.c'), args: cflags + lflags, name: 'pthreads')
+      conf.set('CAIRO_HAS_PTHREAD', 1)
+      if real_pthread
+        conf.set('CAIRO_HAS_REAL_PTHREAD', 1)
+      endif
+      pthread_c_args = cflags
+      pthread_link_args = lflags
+    endif
+  endif
+endforeach
+
+extra_link_args += pthread_link_args
+
+if cc.links(files('meson-cc-tests/atomic-ops-cxx11.c'), name: 'Atomic ops: cxx11')
+  conf.set('HAVE_CXX11_ATOMIC_PRIMITIVES', 1)
+elif cc.links(files('meson-cc-tests/atomic-ops-gcc-legacy.c'), name: 'Atomic ops: gcc legacy')
+  conf.set('HAVE_GCC_LEGACY_ATOMICS', 1)
+elif cc.has_header('atomic_ops.h')
+  conf.set('HAVE_LIB_ATOMIC_OPS', 1)
+elif cc.has_header('libkern/OSAtomic.h')
+  conf.set('HAVE_OS_ATOMIC_OPS', 1)
+endif
+
+test_mkdir_c_args = []
+if conf.get('HAVE_SYS_STAT_H', 0) == 1
+  test_mkdir_c_args += ['-DHAVE_SYS_STAT_H']
+endif
+
+if conf.get('HAVE_IO_H', 0) == 1
+  test_mkdir_c_args += ['-DHAVE_IO_H']
+endif
+
+if cc.links(files('meson-cc-tests/mkdir-variant-1.c'), args: test_mkdir_c_args)
+  conf.set('HAVE_MKDIR', 1)
+elif cc.links(files('meson-cc-tests/mkdir-variant-2.c'), args: test_mkdir_c_args)
+  conf.set('HAVE_MKDIR', 2)
+else
+  conf.set('HAVE_MKDIR', 0)
+endif
+
+if not ['x86', 'x86_64'].contains(host_machine.cpu_family())
+  conf.set('ATOMIC_OP_NEEDS_MEMORY_BARRIER', 1)
+endif
+
+have_ld_preload = ['linux', 'freebsd', 'darwin', 'dragonfly'].contains(host_machine.system())
+
+if have_ld_preload and zlib_dep.found() and conf.get('CAIRO_HAS_REAL_PTHREAD', 0) == 1 and conf.get('CAIRO_HAS_DLSYM', 0) == 1
+  conf.set('CAIRO_HAS_TRACE', 1)
+endif
+
+rt_dep = cc.find_library('rt', required: false)
+have_shm = false
+if rt_dep.found() and cc.has_function('shm_open', dependencies: [rt_dep])
+  have_shm = true
+endif
+
+# This to make sure we don't run checks against internal deps
+deps += internal_deps
+
+subdir('src')
+
+incboilerplate = include_directories('boilerplate')
+if feature_conf.get('CAIRO_HAS_PNG_FUNCTIONS', 0) == 1
+  subdir('boilerplate')
+else
+  libcairoboilerplate = []
+endif
+
+subdir('util')
+
+if not get_option('tests').disabled() and feature_conf.get('CAIRO_HAS_PNG_FUNCTIONS', 0) == 1
+  subdir('test')
+endif
+
+configure_file(output: 'config.h', configuration: conf)
+
+foreach feature: built_features
+  fconf = configuration_data()
+  fconf.set('prefix', get_option('prefix'))
+  fconf.set('exec_prefix', '${prefix}')
+  fconf.set('libdir', '${exec_prefix}/@0@'.format(get_option('libdir')))
+  fconf.set('includedir', '${prefix}/@0@'.format(get_option('includedir')))
+  fconf.set('FEATURE_PC', feature['name'])
+  fconf.set('FEATURE_NAME', feature['description'])
+  fconf.set('VERSION', meson.project_version())
+  fconf.set('FEATURE_BASE', meson.project_name())
+  fconf.set('FEATURE_REQUIRES', feature.get('requires', ''))
+  fconf.set('FEATURE_NONPKGCONFIG_LIBS', ' '.join(feature.get('libs', [])))
+  fconf.set('FEATURE_NONPKGCONFIG_EXTRA_LIBS', '')
+  fconf.set('FEATURE_NONPKGCONFIG_CFLAGS', '')
+
+  configure_file(input: 'src/cairo-features.pc.in',
+    output: '@0@.pc'.format(feature['name']),
+    configuration: fconf,
+    install: true,
+    install_dir: join_paths(get_option('prefix'), get_option('libdir'), 'pkgconfig')
+  )
+endforeach
+
+install_headers('cairo-version.h', subdir: 'cairo')
+
+# summary
+if meson.version().version_compare('>= 0.53')
+  summary({
+          'Image': true,
+          'Recording': true,
+          'Observer': true,
+          'Mime': true,
+          'Tee': feature_conf.get('CAIRO_HAS_TEE_SURFACE', 0) == 1,
+          'XML': feature_conf.get('CAIRO_HAS_XML_SURFACE', 0) == 1,
+          'Xlib': feature_conf.get('CAIRO_HAS_XLIB_SURFACE', 0) == 1,
+          'Xlib Xrender': feature_conf.get('CAIRO_HAS_XLIB_XRENDER_SURFACE', 0) == 1,
+          'Qt': feature_conf.get('CAIRO_HAS_QT_SURFACE', 0) == 1,
+          'Quartz': feature_conf.get('CAIRO_HAS_QUARTZ_SURFACE', 0) == 1,
+          'Quartz-image': feature_conf.get('CAIRO_HAS_QUARTZ_IMAGE_SURFACE', 0) == 1,
+          'XCB': feature_conf.get('CAIRO_HAS_XCB_SURFACE', 0) == 1,
+          'Win32': feature_conf.get('CAIRO_HAS_WIN32_SURFACE', 0) == 1,
+          'OS2': false,
+          'CairoScript': feature_conf.get('CAIRO_HAS_SCRIPT_SURFACE', 0) == 1,
+          'PostScript':  feature_conf.get('CAIRO_HAS_PS_SURFACE', 0) == 1,
+          'PDF':  feature_conf.get('CAIRO_HAS_PDF_SURFACE', 0) == 1,
+          'SVG':  feature_conf.get('CAIRO_HAS_SVG_SURFACE', 0) == 1,
+          'OpenGL': feature_conf.get('CAIRO_HAS_GL_SURFACE', 0) == 1,
+          'OpenGL ES 2.0': feature_conf.get('CAIRO_HAS_GLESV2_SURFACE', 0) == 1,
+          'OpenGL ES 3.0': feature_conf.get('CAIRO_HAS_GLESV3_SURFACE', 0) == 1,
+          'BeOS': false,
+          'DirectFB': feature_conf.get('CAIRO_HAS_DIRECTFB_SURFACE', 0) == 1,
+          'OpenVG': feature_conf.get('CAIRO_HAS_VG_SURFACE', 0) == 1,
+          'DRM': feature_conf.get('CAIRO_HAS_DRM_SURFACE', 0) == 1,
+          'Cogl': feature_conf.get('CAIRO_HAS_COGL_SURFACE', 0) == 1,
+          }, section: 'Surface Backends', bool_yn: true)
+
+  summary({
+          'User': true,
+          'FreeType': feature_conf.get('CAIRO_HAS_FT_FONT', 0) == 1,
+          'Fontconfig': feature_conf.get('CAIRO_HAS_FC_FONT', 0) == 1,
+          'Win32': feature_conf.get('CAIRO_HAS_WIN32_FONT', 0) == 1,
+          'Quartz': feature_conf.get('CAIRO_HAS_QUARTZ_FONT', 0) == 1,
+          }, section: 'Font Backends', bool_yn: true)
+
+  summary({
+          'PNG functions': feature_conf.get('CAIRO_HAS_PNG_FUNCTIONS', 0) == 1,
+          'GLX functions': feature_conf.get('CAIRO_HAS_GLX_FUNCTIONS', 0) == 1,
+          'WGL functions': feature_conf.get('CAIRO_HAS_WGL_FUNCTIONS', 0) == 1,
+          'EGL functions': feature_conf.get('CAIRO_HAS_EGL_FUNCTIONS', 0) == 1,
+          'X11-xcb': feature_conf.get('CAIRO_HAS_XLIB_XCB_FUNCTIONS', 0) == 1,
+          'XCB-shm': feature_conf.get('CAIRO_HAS_XCB_SHM_FUNCTIONS', 0) == 1,
+          }, section: 'Functions', bool_yn: true)
+
+  summary({
+          'cairo-trace:': conf.get('CAIRO_HAS_TRACE', 0) == 1,
+          'cairo-script-interpreter': feature_conf.get('CAIRO_HAS_INTERPRETER', 0) == 1,
+          }, section: 'Features and Utilities', bool_yn: true)
+endif
diff --git a/meson_options.txt b/meson_options.txt
new file mode 100644
index 000000000..a52b6e2f3
--- /dev/null
+++ b/meson_options.txt
@@ -0,0 +1,36 @@
+# Cairo font backends
+option('fontconfig', type : 'feature', value : 'auto')
+option('freetype', type : 'feature', value : 'auto')
+
+# Cairo surface backends
+option('cogl', type : 'feature', value : 'disabled')
+option('directfb', type : 'feature', value : 'disabled')
+option('gl-backend', type : 'combo', value : 'auto',
+       # FIXME: https://github.com/mesonbuild/meson/issues/4566
+       choices : ['auto', 'gl', 'glesv2', 'glesv3', 'disabled'])
+option('glesv2', type : 'feature', value : 'auto')
+option('glesv3', type : 'feature', value : 'auto')
+option('drm', type : 'feature', value : 'disabled')
+option('openvg', type : 'feature', value : 'disabled')
+option('png', type : 'feature', value : 'auto') # png and svg surfaces
+option('qt', type : 'feature', value : 'disabled')
+option('tee', type : 'feature', value : 'disabled')
+option('xcb', type : 'feature', value : 'auto')
+option('xlib', type : 'feature', value : 'auto')
+#option('xml', type : 'feature', value : 'disabled')
+option('zlib', type : 'feature', value : 'auto') # script, ps, pdf, xml surfaces
+
+# Tests
+option('tests', type : 'feature', value : 'auto')
+
+# Util deps
+option('gtk2-utils', type : 'feature', value : 'disabled')
+
+# Misc deps
+option('glib', type : 'feature', value : 'auto')
+option('spectre', type : 'feature', value : 'auto')
+
+# FIXME: implement these to avoid automagic
+#option('egl', type : 'feature', value : 'auto')
+#option('glx', type : 'feature', value : 'auto')
+#option('wgl', type : 'feature', value : 'auto')
diff --git a/src/Makefile.sources b/src/Makefile.sources
index 096a3bcfa..5e84cbfc6 100644
--- a/src/Makefile.sources
+++ b/src/Makefile.sources
@@ -467,10 +467,6 @@ cairo_vg_sources = cairo-vg-surface.c
 
 cairo_cogl_headers = cairo-cogl.h
 cairo_cogl_private = cairo-cogl-private.h \
-		     cairo-cogl-gradient-private.h \
-		     cairo-cogl-context-private.h \
-		     cairo-cogl-utils-private.h
+		     cairo-cogl-gradient-private.h
 cairo_cogl_sources = cairo-cogl-surface.c \
-		     cairo-cogl-gradient.c \
-		     cairo-cogl-context.c \
-		     cairo-cogl-utils.c
+		     cairo-cogl-gradient.c
diff --git a/src/cairo-analysis-surface.c b/src/cairo-analysis-surface.c
index c4f9a6d35..d113c5fac 100644
--- a/src/cairo-analysis-surface.c
+++ b/src/cairo-analysis-surface.c
@@ -777,8 +777,8 @@ _cairo_analysis_surface_tag (void	                *abstract_surface,
 					   ctm,
 					   ctm_inverse,
 					   clip);
-	if (_cairo_int_status_is_error (backend_status))
-	    return backend_status;
+        if (backend_status == CAIRO_INT_STATUS_SUCCESS)
+            surface->has_supported = TRUE;
     }
 
     return backend_status;
diff --git a/src/cairo-clip-boxes.c b/src/cairo-clip-boxes.c
index d6e29fa3a..aaddeb7f7 100644
--- a/src/cairo-clip-boxes.c
+++ b/src/cairo-clip-boxes.c
@@ -524,6 +524,7 @@ _cairo_clip_reduce_to_boxes (cairo_clip_t *clip)
     cairo_clip_path_t *clip_path;
     cairo_status_t status;
 
+	return clip;
     if (clip->path == NULL)
 	return clip;
 
diff --git a/src/cairo-clip-inline.h b/src/cairo-clip-inline.h
index a9f232692..d52afd313 100644
--- a/src/cairo-clip-inline.h
+++ b/src/cairo-clip-inline.h
@@ -68,7 +68,14 @@ _cairo_clip_copy_intersect_clip (const cairo_clip_t *clip,
 static inline void
 _cairo_clip_steal_boxes (cairo_clip_t *clip, cairo_boxes_t *boxes)
 {
-    _cairo_boxes_init_for_array (boxes, clip->boxes, clip->num_boxes);
+    cairo_box_t *array = clip->boxes;
+
+    if (array == &clip->embedded_box) {
+	assert (clip->num_boxes == 1);
+	boxes->boxes_embedded[0] = clip->embedded_box;
+	array = &boxes->boxes_embedded[0];
+    }
+    _cairo_boxes_init_for_array (boxes, array, clip->num_boxes);
     clip->boxes = NULL;
     clip->num_boxes = 0;
 }
@@ -76,7 +83,13 @@ _cairo_clip_steal_boxes (cairo_clip_t *clip, cairo_boxes_t *boxes)
 static inline void
 _cairo_clip_unsteal_boxes (cairo_clip_t *clip, cairo_boxes_t *boxes)
 {
-    clip->boxes = boxes->chunks.base;
+    if (boxes->chunks.base == &boxes->boxes_embedded[0]) {
+	assert(boxes->num_boxes == 1);
+	clip->embedded_box = *boxes->chunks.base;
+	clip->boxes = &clip->embedded_box;
+    } else {
+	clip->boxes = boxes->chunks.base;
+    }
     clip->num_boxes = boxes->num_boxes;
 }
 
diff --git a/src/cairo-cogl-context-private.h b/src/cairo-cogl-context-private.h
deleted file mode 100644
index 0a7185ef1..000000000
--- a/src/cairo-cogl-context-private.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright  2011 Intel Corporation.
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335, USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.og/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * Contributor(s):
- *      Robert Bragg <robert@linux.intel.com>
- */
-
-#ifndef CAIRO_COGL_CONTEXT_PRIVATE_H
-#define CAIRO_COGL_CONTEXT_PRIVATE_H
-
-#include "cairo-default-context-private.h"
-#include "cairo-cogl-private.h"
-
-typedef struct _cairo_cogl_context {
-    cairo_default_context_t base;
-
-    cairo_cogl_device_t *dev;
-    int path_ctm_age;
-    cairo_path_fixed_t user_path;
-
-    cairo_bool_t path_is_rectangle;
-    double x, y, width, height;
-} cairo_cogl_context_t;
-
-cairo_t *
-_cairo_cogl_context_create (void *target);
-
-#endif /* CAIRO_COGL_CONTEXT_PRIVATE_H */
diff --git a/src/cairo-cogl-context.c b/src/cairo-cogl-context.c
deleted file mode 100644
index c32278057..000000000
--- a/src/cairo-cogl-context.c
+++ /dev/null
@@ -1,822 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright  2011 Intel Corporation.
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335, USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.og/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * Contributor(s):
- *      Robert Bragg <robert@linux.intel.com>
- */
-
-/* so long as we can verify that the ctm doesn't change multiple times
- * during the construction of a path we can build a shadow
- * #cairo_path_fixed_t in user coordinates that we can use to create a
- * hash value for caching tessellations of that path.
- *
- * We need to hook into all the points where the ctm can be changed
- * so we can bump a cr->path_ctm_age counter.
- *
- * We need to hook into all the points where the path can be modified
- * so we can catch the start of a path and reset the cr->path_ctm_age
- * counter at that point.
- *
- * When a draw operation is hit we can then check that the
- * path_ctm_age == 0 and if so we create a hash of the path.
- *
- * We use this hash to lookup a #cairo_cogl_path_meta_t struct which
- * may contain tessellated triangles for the path or may just contain
- * a count of how many times the path has been re-seen (we only cache
- * tessellated triangles if there is evidence that the path is being
- * used multiple times because there is a cost involved in allocating
- * a separate buffer for the triangles).
- */
-
-#include "cairoint.h"
-
-#include "cairo-cogl-context-private.h"
-#include "cairo-freed-pool-private.h"
-#include "cairo-arc-private.h"
-#include "cairo-path-fixed-private.h"
-
-#include <glib.h>
-
-static freed_pool_t context_pool;
-
-void
-_cairo_cogl_context_reset_static_data (void)
-{
-    _freed_pool_reset (&context_pool);
-}
-
-static cairo_status_t
-_cairo_cogl_context_rectangle_real (cairo_cogl_context_t *cr,
-				    double x, double y,
-				    double width, double height)
-{
-    cairo_status_t status;
-    status = cr->dev->backend_parent.rectangle (cr, x, y, width, height);
-    if (unlikely (status))
-	return status;
-
-    return _cairo_cogl_path_fixed_rectangle (&cr->user_path,
-					     _cairo_fixed_from_double (x),
-					     _cairo_fixed_from_double (y),
-					     _cairo_fixed_from_double (width),
-					     _cairo_fixed_from_double (height));
-}
-
-/* The idea here is that we have a simplified way of tracking rectangle paths
- * because rectangles are perhaps the most common shape drawn with cairo.
- *
- * Basically we have a speculative store for a rectangle path that doesn't
- * need to use the #cairo_path_fixed_t api to describe a rectangle in terms of
- * (move_to,rel_line_to,rel_line_to,_rel_line_to,close) because if you profile
- * heavy rectangle drawing with Cairo that process can be overly expensive.
- *
- * If the user asks to add more than just a rectangle to their current path
- * then we "flush" any speculative rectangle stored into the current path
- * before continuing to append their operations.
- *
- * In addition to the speculative store cairo-cogl also has a fast-path
- * fill_rectangle drawing operation that further aims to minimize the cost
- * of drawing rectangles.
- */
-static cairo_status_t
-_flush_cr_rectangle (cairo_cogl_context_t *cr)
-{
-    if (!cr->path_is_rectangle)
-	return CAIRO_STATUS_SUCCESS;
-
-    cr->path_is_rectangle = FALSE;
-    return _cairo_cogl_context_rectangle_real (cr, cr->x, cr->y, cr->width, cr->height);
-}
-
-static cairo_status_t
-_cairo_cogl_context_restore (void *abstract_cr)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-
-    if (cr->path_is_rectangle) {
-	cairo_status_t status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    cr->path_ctm_age++;
-    return cr->dev->backend_parent.restore (abstract_cr);
-}
-
-static cairo_status_t
-_cairo_cogl_context_translate (void *abstract_cr, double tx, double ty)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-
-    if (cr->path_is_rectangle) {
-	cairo_status_t status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    cr->path_ctm_age++;
-    return cr->dev->backend_parent.translate (abstract_cr, tx, ty);
-}
-
-static cairo_status_t
-_cairo_cogl_context_scale (void *abstract_cr, double sx, double sy)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-
-    if (cr->path_is_rectangle) {
-	cairo_status_t status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    cr->path_ctm_age++;
-    return cr->dev->backend_parent.scale (abstract_cr, sx, sy);
-}
-
-static cairo_status_t
-_cairo_cogl_context_rotate (void *abstract_cr, double theta)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-
-    if (cr->path_is_rectangle) {
-	cairo_status_t status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    cr->path_ctm_age++;
-    return cr->dev->backend_parent.rotate (abstract_cr, theta);
-}
-
-static cairo_status_t
-_cairo_cogl_context_transform (void *abstract_cr, const cairo_matrix_t *matrix)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-
-    if (cr->path_is_rectangle) {
-	cairo_status_t status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    cr->path_ctm_age++;
-    return cr->dev->backend_parent.transform (abstract_cr, matrix);
-}
-
-static cairo_status_t
-_cairo_cogl_context_set_matrix (void *abstract_cr, const cairo_matrix_t *matrix)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-
-    if (cr->path_is_rectangle) {
-	cairo_status_t status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    cr->path_ctm_age++;
-    return cr->dev->backend_parent.set_matrix (abstract_cr, matrix);
-}
-
-static cairo_status_t
-_cairo_cogl_context_set_identity_matrix (void *abstract_cr)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-
-    if (cr->path_is_rectangle) {
-	cairo_status_t status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    cr->path_ctm_age++;
-    return cr->dev->backend_parent.set_identity_matrix (abstract_cr);
-}
-
-static cairo_status_t
-_cairo_cogl_context_new_path (void *abstract_cr)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-
-    if (cr->path_is_rectangle) {
-	status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    status = cr->dev->backend_parent.new_path (abstract_cr);
-    if (unlikely (status))
-	return status;
-
-    _cairo_path_fixed_fini (&cr->user_path);
-    _cairo_path_fixed_init (&cr->user_path);
-    cr->path_is_rectangle = FALSE;
-
-    return CAIRO_STATUS_SUCCESS;
-}
-
-static cairo_status_t
-_cairo_cogl_context_new_sub_path (void *abstract_cr)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-
-    if (cr->path_is_rectangle) {
-	status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    status = cr->dev->backend_parent.new_sub_path (abstract_cr);
-    if (unlikely (status))
-	return status;
-
-    _cairo_path_fixed_new_sub_path (&cr->user_path);
-
-    return CAIRO_STATUS_SUCCESS;
-}
-
-static cairo_status_t
-_cairo_cogl_context_move_to (void *abstract_cr, double x, double y)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-    cairo_fixed_t x_fixed, y_fixed;
-
-    if (cr->path_is_rectangle) {
-	status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    status = cr->dev->backend_parent.move_to (abstract_cr, x, y);
-    if (unlikely (status))
-	return status;
-
-    x_fixed = _cairo_fixed_from_double (x);
-    y_fixed = _cairo_fixed_from_double (y);
-
-    return _cairo_path_fixed_move_to (&cr->user_path, x_fixed, y_fixed);
-}
-
-static cairo_status_t
-_cairo_cogl_context_line_to (void *abstract_cr, double x, double y)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-    cairo_fixed_t x_fixed, y_fixed;
-
-    if (cr->path_is_rectangle) {
-	status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    status = cr->dev->backend_parent.line_to (abstract_cr, x, y);
-    if (unlikely (status))
-	return status;
-
-    x_fixed = _cairo_fixed_from_double (x);
-    y_fixed = _cairo_fixed_from_double (y);
-
-    if (cr->user_path.buf.base.num_ops == 0)
-	cr->path_ctm_age = 0;
-
-    return _cairo_path_fixed_line_to (&cr->user_path, x_fixed, y_fixed);
-}
-
-static cairo_status_t
-_cairo_cogl_context_curve_to (void *abstract_cr,
-			       double x1, double y1,
-			       double x2, double y2,
-			       double x3, double y3)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-    cairo_fixed_t x1_fixed, y1_fixed;
-    cairo_fixed_t x2_fixed, y2_fixed;
-    cairo_fixed_t x3_fixed, y3_fixed;
-
-    if (cr->path_is_rectangle) {
-	status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    status = cr->dev->backend_parent.curve_to (abstract_cr, x1, y1, x2, y2, x3, y3);
-    if (unlikely (status))
-	return status;
-
-    x1_fixed = _cairo_fixed_from_double (x1);
-    y1_fixed = _cairo_fixed_from_double (y1);
-
-    x2_fixed = _cairo_fixed_from_double (x2);
-    y2_fixed = _cairo_fixed_from_double (y2);
-
-    x3_fixed = _cairo_fixed_from_double (x3);
-    y3_fixed = _cairo_fixed_from_double (y3);
-
-    if (cr->user_path.buf.base.num_ops == 0)
-	cr->path_ctm_age = 0;
-
-    return _cairo_path_fixed_curve_to (&cr->user_path,
-				       x1_fixed, y1_fixed,
-				       x2_fixed, y2_fixed,
-				       x3_fixed, y3_fixed);
-}
-
-static cairo_status_t
-_cairo_cogl_context_arc (void *abstract_cr,
-			  double xc, double yc, double radius,
-			  double angle1, double angle2,
-			  cairo_bool_t forward)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-
-    if (cr->path_is_rectangle) {
-	status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    status = cr->dev->backend_parent.arc (abstract_cr, xc, yc, radius, angle1, angle2, forward);
-    if (unlikely (status))
-	return status;
-
-    if (cr->user_path.buf.base.num_ops == 0)
-	cr->path_ctm_age = 0;
-
-    /* Do nothing, successfully, if radius is <= 0 */
-    if (radius <= 0.0) {
-	cairo_fixed_t x_fixed, y_fixed;
-
-	x_fixed = _cairo_fixed_from_double (xc);
-	y_fixed = _cairo_fixed_from_double (yc);
-	status = _cairo_path_fixed_line_to (&cr->user_path, x_fixed, y_fixed);
-	if (unlikely (status))
-	    return status;
-
-	status = _cairo_path_fixed_line_to (&cr->user_path, x_fixed, y_fixed);
-	if (unlikely (status))
-	    return status;
-
-	return CAIRO_STATUS_SUCCESS;
-    }
-
-    status = _cairo_cogl_context_line_to (cr,
-					  xc + radius * cos (angle1),
-					  yc + radius * sin (angle1));
-
-    if (unlikely (status))
-	return status;
-
-    if (forward)
-	_cairo_arc_path (&cr->base.base, xc, yc, radius, angle1, angle2);
-    else
-	_cairo_arc_path_negative (&cr->base.base, xc, yc, radius, angle1, angle2);
-
-    return CAIRO_STATUS_SUCCESS; /* any error will have already been set on cr */
-}
-
-static cairo_status_t
-_cairo_cogl_context_rel_move_to (void *abstract_cr, double dx, double dy)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-    cairo_fixed_t dx_fixed, dy_fixed;
-
-    if (cr->path_is_rectangle) {
-	status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    status = cr->dev->backend_parent.rel_move_to (abstract_cr, dx, dy);
-    if (unlikely (status))
-	return status;
-
-    dx_fixed = _cairo_fixed_from_double (dx);
-    dy_fixed = _cairo_fixed_from_double (dy);
-
-    return _cairo_path_fixed_rel_move_to (&cr->user_path, dx_fixed, dy_fixed);
-}
-
-static cairo_status_t
-_cairo_cogl_context_rel_line_to (void *abstract_cr, double dx, double dy)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-    cairo_fixed_t dx_fixed, dy_fixed;
-
-    if (cr->path_is_rectangle) {
-	status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    status = cr->dev->backend_parent.rel_line_to (abstract_cr, dx, dy);
-    if (unlikely (status))
-	return status;
-
-    dx_fixed = _cairo_fixed_from_double (dx);
-    dy_fixed = _cairo_fixed_from_double (dy);
-
-    if (cr->user_path.buf.base.num_ops == 0)
-	cr->path_ctm_age = 0;
-
-    return _cairo_path_fixed_rel_line_to (&cr->user_path, dx_fixed, dy_fixed);
-}
-
-
-static cairo_status_t
-_cairo_cogl_context_rel_curve_to (void *abstract_cr,
-				   double dx1, double dy1,
-				   double dx2, double dy2,
-				   double dx3, double dy3)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-    cairo_fixed_t dx1_fixed, dy1_fixed;
-    cairo_fixed_t dx2_fixed, dy2_fixed;
-    cairo_fixed_t dx3_fixed, dy3_fixed;
-
-    if (cr->path_is_rectangle) {
-	status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    status = cr->dev->backend_parent.rel_curve_to (abstract_cr, dx1, dy1, dx2, dy2, dx3, dy3);
-    if (unlikely (status))
-	return status;
-
-    dx1_fixed = _cairo_fixed_from_double (dx1);
-    dy1_fixed = _cairo_fixed_from_double (dy1);
-
-    dx2_fixed = _cairo_fixed_from_double (dx2);
-    dy2_fixed = _cairo_fixed_from_double (dy2);
-
-    dx3_fixed = _cairo_fixed_from_double (dx3);
-    dy3_fixed = _cairo_fixed_from_double (dy3);
-
-    if (cr->user_path.buf.base.num_ops == 0)
-	cr->path_ctm_age = 0;
-
-    return _cairo_path_fixed_rel_curve_to (&cr->user_path,
-					   dx1_fixed, dy1_fixed,
-					   dx2_fixed, dy2_fixed,
-					   dx3_fixed, dy3_fixed);
-}
-
-#if 0
-static cairo_status_t
-_cairo_cogl_context_arc_to (void *abstract_cr,
-			    double x1, double y1,
-			    double x2, double y2,
-			    double radius)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-
-    if (cr->path_is_rectangle) {
-	status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    status = cr->dev->backend_parent.arc_to (abstract_cr, x1, y1, x2, y2, radius);
-    if (unlikely (status))
-	return status;
-#warning "FIXME"
-}
-
-static cairo_status_t
-_cairo_cogl_rel_arc_to (void *cr,
-			double dx1, double dy1,
-			double dx2, double dy2,
-			double radius)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-
-    if (cr->path_is_rectangle) {
-	status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    status = cr->dev->backend_parent.rel_arc_to (abstract_cr, dx1, dy2, dx2, dy2, radius);
-    if (unlikely (status))
-	return status;
-#warning "FIXME"
-}
-#endif
-
-static cairo_status_t
-_cairo_cogl_context_close_path (void *abstract_cr)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-
-    if (cr->path_is_rectangle) {
-	status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    status = cr->dev->backend_parent.close_path (abstract_cr);
-    if (unlikely (status))
-	return status;
-
-    if (cr->user_path.buf.base.num_ops == 0)
-	cr->path_ctm_age = 0;
-
-    return _cairo_path_fixed_close_path (&cr->user_path);
-}
-
-static cairo_status_t
-_cairo_cogl_context_rectangle (void *abstract_cr,
-			       double x, double y,
-			       double width, double height)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-
-    if (cr->user_path.buf.base.num_ops == 0) {
-	cr->path_ctm_age = 0;
-
-#if 1
-	/* XXX: Since drawing rectangles is so common we have a
-	 * fast-path for drawing a single rectangle. */
-	cr->x = x;
-	cr->y = y;
-	cr->width = width;
-	cr->height = height;
-	cr->path_is_rectangle = TRUE;
-	return CAIRO_STATUS_SUCCESS;
-#endif
-    }
-
-    if (cr->path_is_rectangle) {
-	cairo_status_t status = _flush_cr_rectangle (cr);
-	if (unlikely (status))
-	    return status;
-    }
-
-    return _cairo_cogl_context_rectangle_real (cr, x, y, width, height);
-}
-
-/* Since the surface backend drawing operator functions don't get
- * passed the current #cairo_t context we don't have a good way
- * to get our user-coordinates path into our surface operator
- * functions.
- *
- * For now we use this function to set side band data on the surface
- * itself.
- */
-static void
-_cairo_cogl_surface_set_side_band_state (cairo_cogl_surface_t *surface,
-					 cairo_cogl_context_t *cr)
-{
-
-    if (cr->path_ctm_age <= 1) {
-	surface->user_path = &cr->user_path;
-	surface->ctm = &cr->base.gstate->ctm;
-	surface->ctm_inverse = &cr->base.gstate->ctm_inverse;
-	surface->path_is_rectangle = cr->path_is_rectangle;
-	if (surface->path_is_rectangle) {
-	    surface->path_rectangle_x = cr->x;
-	    surface->path_rectangle_y = cr->y;
-	    surface->path_rectangle_width = cr->width;
-	    surface->path_rectangle_height = cr->height;
-	}
-    } else {
-	surface->user_path = NULL;
-	surface->path_is_rectangle = FALSE;
-    }
-}
-
-static cairo_status_t
-_cairo_cogl_context_fill (void *abstract_cr)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-    cairo_cogl_surface_t *surface = (cairo_cogl_surface_t *)cr->base.gstate->target;
-
-    if (cr->path_is_rectangle) {
-	status = _cairo_cogl_surface_fill_rectangle (cr->base.gstate->target,
-						     cr->base.gstate->op,
-						     cr->base.gstate->source,
-						     cr->x,
-						     cr->y,
-						     cr->width,
-						     cr->height,
-						     &cr->base.gstate->ctm,
-						     cr->base.gstate->clip);
-	if (status == CAIRO_STATUS_SUCCESS)
-	    goto DONE;
-	_flush_cr_rectangle (cr);
-    }
-
-    _cairo_cogl_surface_set_side_band_state (surface, cr);
-
-    status = cr->dev->backend_parent.fill (abstract_cr);
-    if (unlikely (status))
-	return status;
-
-DONE:
-    _cairo_path_fixed_fini (&cr->user_path);
-    _cairo_path_fixed_init (&cr->user_path);
-    cr->path_is_rectangle = FALSE;
-
-    return CAIRO_STATUS_SUCCESS;
-}
-
-static cairo_status_t
-_cairo_cogl_context_fill_preserve (void *abstract_cr)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-    cairo_cogl_surface_t *surface = (cairo_cogl_surface_t *)cr->base.gstate->target;
-
-    _cairo_cogl_surface_set_side_band_state (surface, cr);
-
-    status = cr->dev->backend_parent.fill_preserve (abstract_cr);
-    if (unlikely (status))
-	return status;
-
-    return CAIRO_STATUS_SUCCESS;
-}
-
-static cairo_status_t
-_cairo_cogl_context_stroke (void *abstract_cr)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-    cairo_cogl_surface_t *surface = (cairo_cogl_surface_t *)cr->base.gstate->target;
-
-    _cairo_cogl_surface_set_side_band_state (surface, cr);
-
-    status = cr->dev->backend_parent.stroke (abstract_cr);
-    if (unlikely (status))
-	return status;
-
-    _cairo_path_fixed_fini (&cr->user_path);
-    _cairo_path_fixed_init (&cr->user_path);
-    cr->path_is_rectangle = FALSE;
-
-    return CAIRO_STATUS_SUCCESS;
-}
-
-static cairo_status_t
-_cairo_cogl_context_stroke_preserve (void *abstract_cr)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-    cairo_cogl_surface_t *surface = (cairo_cogl_surface_t *)cr->base.gstate->target;
-
-    _cairo_cogl_surface_set_side_band_state (surface, cr);
-
-    status = cr->dev->backend_parent.stroke_preserve (abstract_cr);
-    if (unlikely (status))
-	return status;
-
-    return CAIRO_STATUS_SUCCESS;
-}
-
-static cairo_status_t
-_cairo_cogl_context_clip (void *abstract_cr)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-    cairo_status_t status;
-
-    status = cr->dev->backend_parent.clip (abstract_cr);
-    if (unlikely (status))
-	return status;
-
-    _cairo_path_fixed_fini (&cr->user_path);
-    _cairo_path_fixed_init (&cr->user_path);
-    cr->path_is_rectangle = FALSE;
-
-    return CAIRO_STATUS_SUCCESS;
-}
-
-static void
-_cairo_cogl_context_destroy (void *abstract_cr)
-{
-    cairo_cogl_context_t *cr = abstract_cr;
-
-    _cairo_default_context_fini (&cr->base);
-
-    _cairo_path_fixed_fini (&cr->user_path);
-
-    /* mark the context as invalid to protect against misuse */
-    cr->base.base.status = CAIRO_STATUS_NULL_POINTER;
-    _freed_pool_put (&context_pool, cr);
-}
-
-/* We want to hook into the frontend of the path construction APIs so
- * we can build up a path description in user coordinates instead of
- * backend coordinates so that we can recognize user coordinate
- * rectangles and so we can hash a user path independent of its
- * transform. (With some care to catch unusual cases where the ctm
- * changes mid-path) */
-cairo_t *
-_cairo_cogl_context_create (void *target)
-{
-    cairo_cogl_surface_t *surface = target;
-    cairo_cogl_context_t *cr;
-    cairo_status_t status;
-
-    cr = _freed_pool_get (&context_pool);
-    if (unlikely (cr == NULL)) {
-	cr = _cairo_malloc (sizeof (cairo_cogl_context_t));
-	if (unlikely (cr == NULL))
-	    return _cairo_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
-    }
-
-    status = _cairo_default_context_init (&cr->base, target);
-    if (unlikely (status)) {
-	_freed_pool_put (&context_pool, cr);
-	return _cairo_create_in_error (status);
-    }
-
-    cr->dev = (cairo_cogl_device_t *)surface->base.device;
-
-    if (unlikely (cr->dev->backend_vtable_initialized == FALSE)) {
-	cairo_backend_t *backend = &cr->dev->backend;
-	memcpy (backend, cr->base.base.backend, sizeof (cairo_backend_t));
-	memcpy (&cr->dev->backend_parent, cr->base.base.backend, sizeof (cairo_backend_t));
-
-	backend->destroy = _cairo_cogl_context_destroy;
-
-	backend->restore = _cairo_cogl_context_restore;
-	backend->translate = _cairo_cogl_context_translate;
-	backend->scale = _cairo_cogl_context_scale;
-	backend->rotate = _cairo_cogl_context_rotate;
-	backend->transform = _cairo_cogl_context_transform;
-	backend->set_matrix = _cairo_cogl_context_set_matrix;
-	backend->set_identity_matrix = _cairo_cogl_context_set_identity_matrix;
-
-	backend->new_path = _cairo_cogl_context_new_path;
-	backend->new_sub_path = _cairo_cogl_context_new_sub_path;
-	backend->move_to = _cairo_cogl_context_move_to;
-	backend->rel_move_to = _cairo_cogl_context_rel_move_to;
-	backend->line_to = _cairo_cogl_context_line_to;
-	backend->rel_line_to = _cairo_cogl_context_rel_line_to;
-	backend->curve_to = _cairo_cogl_context_curve_to;
-	backend->rel_curve_to = _cairo_cogl_context_rel_curve_to;
-#if 0
-	backend->arc_to = _cairo_cogl_context_arc_to;
-	backend->rel_arc_to = _cairo_cogl_context_rel_arc_to;
-#endif
-	backend->close_path = _cairo_cogl_context_close_path;
-	//backend->arc = _cairo_cogl_context_arc;
-	backend->rectangle = _cairo_cogl_context_rectangle;
-
-	/* Try to automatically catch if any new path APIs are added that mean
-	 * we may need to overload more functions... */
-	assert (((char *)&backend->path_extents - (char *)&backend->device_to_user_distance)
-		== (sizeof (void *) * 14));
-
-	backend->fill = _cairo_cogl_context_fill;
-	backend->fill_preserve = _cairo_cogl_context_fill_preserve;
-	backend->stroke = _cairo_cogl_context_stroke;
-	backend->stroke_preserve = _cairo_cogl_context_stroke_preserve;
-	backend->clip = _cairo_cogl_context_clip;
-
-	cr->dev->backend_vtable_initialized = TRUE;
-    }
-
-    cr->base.base.backend = &cr->dev->backend;
-
-    _cairo_path_fixed_init (&cr->user_path);
-    cr->path_is_rectangle = FALSE;
-
-    return &cr->base.base;
-}
diff --git a/src/cairo-cogl-gradient-private.h b/src/cairo-cogl-gradient-private.h
index fa684d2c6..9367044f3 100644
--- a/src/cairo-cogl-gradient-private.h
+++ b/src/cairo-cogl-gradient-private.h
@@ -67,15 +67,16 @@ typedef struct _cairo_cogl_linear_gradient {
 } cairo_cogl_linear_gradient_t;
 
 cairo_int_status_t
-_cairo_cogl_get_linear_gradient (cairo_cogl_device_t *context,
-				 cairo_extend_t extend_mode,
-				 int n_stops,
-				 const cairo_gradient_stop_t *stops,
+_cairo_cogl_get_linear_gradient (cairo_cogl_device_t           *context,
+				 cairo_extend_t                 extend_mode,
+				 int                            n_stops,
+				 const cairo_gradient_stop_t   *stops,
+				 const cairo_bool_t             need_mirrored_gradient,
 				 cairo_cogl_linear_gradient_t **gradient_out);
 
 cairo_cogl_linear_texture_entry_t *
 _cairo_cogl_linear_gradient_texture_for_extend (cairo_cogl_linear_gradient_t *gradient,
-						cairo_extend_t extend_mode);
+						cairo_extend_t                extend_mode);
 
 cairo_cogl_linear_gradient_t *
 _cairo_cogl_linear_gradient_reference (cairo_cogl_linear_gradient_t *gradient);
diff --git a/src/cairo-cogl-gradient.c b/src/cairo-cogl-gradient.c
index 0923e3b6d..cdb4cae82 100644
--- a/src/cairo-cogl-gradient.c
+++ b/src/cairo-cogl-gradient.c
@@ -37,7 +37,7 @@
 #include <cogl/cogl2-experimental.h>
 #include <glib.h>
 
-#define DUMP_GRADIENTS_TO_PNG
+//#define DUMP_GRADIENTS_TO_PNG
 
 static unsigned long
 _cairo_cogl_linear_gradient_hash (unsigned int                  n_stops,
@@ -48,7 +48,7 @@ _cairo_cogl_linear_gradient_hash (unsigned int                  n_stops,
 }
 
 static cairo_cogl_linear_gradient_t *
-_cairo_cogl_linear_gradient_lookup (cairo_cogl_device_t         *ctx,
+_cairo_cogl_linear_gradient_lookup (cairo_cogl_device_t          *ctx,
 				    unsigned long                 hash,
 				    unsigned int                  n_stops,
 				    const cairo_gradient_stop_t  *stops)
@@ -116,7 +116,8 @@ _cairo_cogl_util_next_p2 (int a)
 }
 
 static float
-get_max_color_component_range (const cairo_color_stop_t *color0, const cairo_color_stop_t *color1)
+get_max_color_component_range (const cairo_color_stop_t *color0,
+                               const cairo_color_stop_t *color1)
 {
     float range;
     float max = 0;
@@ -197,24 +198,24 @@ _cairo_cogl_linear_gradient_width_for_stops (cairo_extend_t		  extend,
 
 /* Aim to create gradient textures without an alpha component so we can avoid
  * needing to use blending... */
-static CoglPixelFormat
-_cairo_cogl_linear_gradient_format_for_stops (cairo_extend_t		   extend,
-					      unsigned int                 n_stops,
-					      const cairo_gradient_stop_t *stops)
+static CoglTextureComponents
+_cairo_cogl_linear_gradient_components_for_stops (cairo_extend_t               extend,
+					          unsigned int                 n_stops,
+					          const cairo_gradient_stop_t *stops)
 {
     unsigned int n;
 
     /* We have to add extra transparent texels to the end of the gradient to
      * handle CAIRO_EXTEND_NONE... */
     if (extend == CAIRO_EXTEND_NONE)
-	return COGL_PIXEL_FORMAT_BGRA_8888_PRE;
+	return COGL_TEXTURE_COMPONENTS_RGBA;
 
     for (n = 1; n < n_stops; n++) {
 	if (stops[n].color.alpha != 1.0)
-	    return COGL_PIXEL_FORMAT_BGRA_8888_PRE;
+	    return COGL_TEXTURE_COMPONENTS_RGBA;
     }
 
-    return COGL_PIXEL_FORMAT_BGR_888;
+    return COGL_TEXTURE_COMPONENTS_RGBA;
 }
 
 static cairo_cogl_gradient_compatibility_t
@@ -238,7 +239,7 @@ _cairo_cogl_compatibility_from_extend_mode (cairo_extend_t extend_mode)
 
 cairo_cogl_linear_texture_entry_t *
 _cairo_cogl_linear_gradient_texture_for_extend (cairo_cogl_linear_gradient_t *gradient,
-						cairo_extend_t extend_mode)
+						cairo_extend_t                extend_mode)
 {
     GList *l;
     cairo_cogl_gradient_compatibility_t compatibility =
@@ -351,10 +352,11 @@ dump_gradient_to_png (CoglTexture *texture)
 #endif
 
 cairo_int_status_t
-_cairo_cogl_get_linear_gradient (cairo_cogl_device_t *device,
-				 cairo_extend_t extend_mode,
-				 int n_stops,
-				 const cairo_gradient_stop_t *stops,
+_cairo_cogl_get_linear_gradient (cairo_cogl_device_t           *device,
+				 cairo_extend_t                 extend_mode,
+				 int                            n_stops,
+				 const cairo_gradient_stop_t   *stops,
+				 const cairo_bool_t             need_mirrored_gradient,
 				 cairo_cogl_linear_gradient_t **gradient_out)
 {
     unsigned long hash;
@@ -366,15 +368,15 @@ _cairo_cogl_get_linear_gradient (cairo_cogl_device_t *device,
     int n;
     cairo_cogl_gradient_compatibility_t compatibilities;
     int width;
+    int tex_width;
     int left_padding = 0;
     cairo_color_stop_t left_padding_color;
     int right_padding = 0;
     cairo_color_stop_t right_padding_color;
-    CoglPixelFormat format;
+    CoglTextureComponents components;
     CoglTexture2D *tex;
-    GError *error = NULL;
     int un_padded_width;
-    CoglHandle offscreen;
+    CoglFramebuffer *offscreen = NULL;
     cairo_int_status_t status;
     int n_quads;
     int n_vertices;
@@ -383,6 +385,7 @@ _cairo_cogl_get_linear_gradient (cairo_cogl_device_t *device,
     CoglVertexP2C4 *vertices;
     CoglVertexP2C4 *p;
     CoglPrimitive *prim;
+    CoglPipeline *pipeline;
 
     hash = _cairo_cogl_linear_gradient_hash (n_stops, stops);
 
@@ -410,11 +413,12 @@ _cairo_cogl_get_linear_gradient (cairo_cogl_device_t *device,
 	gradient->n_stops = n_stops;
 	gradient->stops = gradient->stops_embedded;
 	memcpy (gradient->stops_embedded, stops, sizeof (cairo_gradient_stop_t) * n_stops);
-    } else
+    } else {
 	_cairo_cogl_linear_gradient_reference (gradient);
+    }
 
     entry = _cairo_malloc (sizeof (cairo_cogl_linear_texture_entry_t));
-    if (!entry) {
+    if (unlikely (!entry)) {
 	status = CAIRO_INT_STATUS_NO_MEMORY;
 	goto BAIL;
     }
@@ -450,7 +454,7 @@ _cairo_cogl_get_linear_gradient (cairo_cogl_device_t *device,
      * interpolate premultiplied colors so we premultiply all the double
      * components now. (skipping any extra stops added for repeat/reflect)
      *
-     * Anothing thing to note is that by premultiplying the colors
+     * Another thing to note is that by premultiplying the colors
      * early we'll also reduce the range of colors to interpolate
      * which can result in smaller gradient textures.
      */
@@ -553,24 +557,30 @@ _cairo_cogl_get_linear_gradient (cairo_cogl_device_t *device,
 
     width = _cairo_cogl_util_next_p2 (width);
     width = MIN (4096, width); /* lets not go too stupidly big! */
-    format = _cairo_cogl_linear_gradient_format_for_stops (extend_mode, n_stops, stops);
+
+    if (!device->has_npots)
+        width = pow (2, ceil (log2 (width)));
+
+    if (need_mirrored_gradient)
+        tex_width = width * 2;
+    else
+        tex_width = width;
+
+    components = _cairo_cogl_linear_gradient_components_for_stops (extend_mode, n_stops, stops);
 
     do {
 	tex = cogl_texture_2d_new_with_size (device->cogl_context,
-					     width,
-					     1,
-					     format,
-					     &error);
-	if (!tex)
-	    g_error_free (error);
-    } while (tex == NULL && width >> 1);
-
-    if (!tex) {
+	                                     tex_width, 1);
+    } while (tex == NULL && width >> 1 && tex_width >> 1);
+
+    if (unlikely (!tex)) {
 	status = CAIRO_INT_STATUS_NO_MEMORY;
 	goto BAIL;
     }
 
-    entry->texture = COGL_TEXTURE (tex);
+    cogl_texture_set_components (tex, components);
+
+    entry->texture = tex;
     entry->compatibility = compatibilities;
 
     un_padded_width = width - left_padding - right_padding;
@@ -582,16 +592,22 @@ _cairo_cogl_get_linear_gradient (cairo_cogl_device_t *device,
     if (left_padding)
 	entry->translate_x += (entry->scale_x / (float)un_padded_width) * (float)left_padding;
 
-    offscreen = cogl_offscreen_new_to_texture (tex);
-    cogl_push_framebuffer (COGL_FRAMEBUFFER (offscreen));
-    cogl_ortho (0, width, 1, 0, -1, 100);
-    cogl_framebuffer_clear4f (COGL_FRAMEBUFFER (offscreen),
-			      COGL_BUFFER_BIT_COLOR,
-			      0, 0, 0, 0);
+    offscreen = cogl_offscreen_new_with_texture (tex);
+    cogl_framebuffer_orthographic (offscreen, 0, 0,
+                                              tex_width, 1,
+                                              -1, 100);
+    cogl_framebuffer_clear4f (offscreen,
+                              COGL_BUFFER_BIT_COLOR,
+                              0, 0, 0, 0);
 
     n_quads = n_stops - 1 + !!left_padding + !!right_padding;
     n_vertices = 6 * n_quads;
-    vertices = alloca (sizeof (CoglVertexP2C4) * n_vertices);
+    vertices = _cairo_malloc_ab (n_vertices, sizeof (CoglVertexP2C4));
+    if (unlikely (!vertices)) {
+        status = CAIRO_INT_STATUS_NO_MEMORY;
+        goto BAIL;
+    }
+
     p = vertices;
     if (left_padding)
 	emit_stop (&p, 0, left_padding, &left_padding_color, &left_padding_color);
@@ -604,22 +620,40 @@ _cairo_cogl_get_linear_gradient (cairo_cogl_device_t *device,
     if (right_padding)
 	emit_stop (&p, prev, width, &right_padding_color, &right_padding_color);
 
-    prim = cogl_primitive_new_p2c4 (COGL_VERTICES_MODE_TRIANGLES,
-				    n_vertices,
-				    vertices);
-    /* Just use this as the simplest way to setup a default pipeline... */
-    cogl_set_source_color4f (0, 0, 0, 0);
-    cogl_primitive_draw (prim);
+    prim = cogl_primitive_new_p2c4 (device->cogl_context,
+                                    COGL_VERTICES_MODE_TRIANGLES,
+                                    n_vertices,
+                                    vertices);
+    free (vertices);
+    pipeline = cogl_pipeline_new (device->cogl_context);
+    cogl_primitive_draw (prim, offscreen, pipeline);
+
+    if (need_mirrored_gradient) {
+        /* In order to use a reflected gradient on hardware that
+         * doesn't have a mirrored repeating texture wrap mode, we
+         * render two reflected images to a double-length linear
+         * texture and reflect that */
+        CoglMatrix transform;
+
+        cogl_matrix_init_identity (&transform);
+        cogl_matrix_translate (&transform, tex_width, 0.0f, 0.0f);
+        cogl_matrix_scale (&transform, -1.0f, 1.0f, 1.0f);
+
+        cogl_framebuffer_transform (offscreen, &transform);
+        cogl_primitive_draw (prim, offscreen, pipeline);
+    }
+
     cogl_object_unref (prim);
+    cogl_object_unref (pipeline);
 
-    cogl_pop_framebuffer ();
     cogl_object_unref (offscreen);
+    offscreen = NULL;
 
     gradient->textures = g_list_prepend (gradient->textures, entry);
     gradient->cache_entry.size = _cairo_cogl_linear_gradient_size (gradient);
 
 #ifdef DUMP_GRADIENTS_TO_PNG
-    dump_gradient_to_png (COGL_TEXTURE (tex));
+    dump_gradient_to_png (tex);
 #endif
 
 #warning "FIXME:"
@@ -638,5 +672,7 @@ BAIL:
     free (entry);
     if (gradient)
 	_cairo_cogl_linear_gradient_destroy (gradient);
+    if (offscreen)
+        cogl_object_unref (offscreen);
     return status;
 }
diff --git a/src/cairo-cogl-private.h b/src/cairo-cogl-private.h
index 13fe5a8dc..b0be2661e 100644
--- a/src/cairo-cogl-private.h
+++ b/src/cairo-cogl-private.h
@@ -37,53 +37,68 @@
 #include "cairo-backend-private.h"
 #include "cairo-default-context-private.h"
 #include "cairo-surface-private.h"
+#include "cairo-freelist-private.h"
 
 #include <cogl/cogl2-experimental.h>
 
 typedef enum _cairo_cogl_template_type {
+	/* solid source */
     CAIRO_COGL_TEMPLATE_TYPE_SOLID,
+    /* solid source with solid mask */
+    CAIRO_COGL_TEMPLATE_TYPE_SOLID_MASK_SOLID,
+    /* solid source with texture mask */
+    CAIRO_COGL_TEMPLATE_TYPE_TEXTURE_MASK_SOLID,
+    /* texture source */
     CAIRO_COGL_TEMPLATE_TYPE_TEXTURE,
-    CAIRO_COGL_TEMPLATE_TYPE_MASK_SOLID,
-    CAIRO_COGL_TEMPLATE_TYPE_MASK_TEXTURE,
+    /* texture source with solid mask */
+    CAIRO_COGL_TEMPLATE_TYPE_SOLID_MASK_TEXTURE,
+    /* texture source with texture mask */
+    CAIRO_COGL_TEMPLATE_TYPE_TEXTURE_MASK_TEXTURE,
+    /* texture source with source alpha ignored */
+    CAIRO_COGL_TEMPLATE_TYPE_TEXTURE_IGNORE_ALPHA,
+    /* texture source with solid mask with source alpha ignored */
+    CAIRO_COGL_TEMPLATE_TYPE_SOLID_MASK_TEXTURE_IGNORE_ALPHA,
+    /* texture source with texture mask with source alpha ignored */
+    CAIRO_COGL_TEMPLATE_TYPE_TEXTURE_MASK_TEXTURE_IGNORE_ALPHA,
     CAIRO_COGL_TEMPLATE_TYPE_COUNT
 } cairo_cogl_template_type;
 
 typedef struct _cairo_cogl_device {
     cairo_device_t base;
 
-    cairo_bool_t backend_vtable_initialized;
-    cairo_backend_t backend;
-
-    /* We save a copy of all the original backend methods that we override so
-     * we can chain up...
-     */
-    cairo_backend_t backend_parent;
-
     CoglContext *cogl_context;
 
-    CoglTexture *dummy_texture;
+    cairo_bool_t has_npots;
+    cairo_bool_t has_mirrored_repeat;
 
-    /* This is a sparsely filled set of templates because we don't support
-     * the full range of operators that cairo has. All entries corresponding
-     * to unsupported operators are NULL.
+    CoglAttributeBuffer *buffer_stack;
+    size_t buffer_stack_size;
+    size_t buffer_stack_offset;
+    guint8 *buffer_stack_pointer;
+
+    /* This is a limited set of templates because we don't support the
+     * full range of operators that cairo has. The CAIRO_OPERATOR_ADD
+     * is the operator enum with the highest value that we support so
+     * we cap the size of the array by that.
      *
-     * The CAIRO_OPERATOR_ADD is the operator enum with the highest value that
-     * we support so we at least cap the size of the array by that.
+     * For each operator, we have a template for when we have a solid
+     * source and a non-solid source. For each of those, we also have
+     * additional templates for when we have a solid mask or a
+     * non-solid mask, for a total of six templates per operator.
      *
-     * For each operator we have a template for when we have a solid source
-     * and another for each texture format that could be used as a source.
+     * The templates are set to null at device creation time and only
+     * actually created on their first use.
      */
     CoglPipeline *template_pipelines[CAIRO_OPERATOR_ADD + 1][CAIRO_COGL_TEMPLATE_TYPE_COUNT];
 
-    CoglMatrix identity;
-
     /* Caches 1d linear gradient textures */
     cairo_cache_t linear_cache;
 
-    cairo_cache_t path_fill_staging_cache;
     cairo_cache_t path_fill_prim_cache;
-    cairo_cache_t path_stroke_staging_cache;
     cairo_cache_t path_stroke_prim_cache;
+
+    cairo_freelist_t path_fill_meta_freelist;
+    cairo_freelist_t path_stroke_meta_freelist;
 } cairo_cogl_device_t;
 
 typedef struct _cairo_cogl_clip_primitives {
@@ -94,9 +109,6 @@ typedef struct _cairo_cogl_clip_primitives {
 typedef struct _cairo_cogl_surface {
     cairo_surface_t base;
 
-    CoglPixelFormat cogl_format;
-    cairo_bool_t ignore_alpha;
-
     /* We currently have 3 basic kinds of Cogl surfaces:
      * 1) A light surface simply wrapping a CoglTexture
      * 2) A CoglOffscreen framebuffer that implicitly also wraps a CoglTexture
@@ -111,12 +123,11 @@ typedef struct _cairo_cogl_surface {
     int width;
     int height;
 
-    GQueue *journal;
+    /* Is this a snapshot used for mirrored repeating on hardware which
+     * doesn't have it, consisting of four reflected images? */
+    cairo_bool_t is_mirrored_snapshot;
 
-    CoglAttributeBuffer *buffer_stack;
-    size_t buffer_stack_size;
-    size_t buffer_stack_offset;
-    guint8 *buffer_stack_pointer;
+    GQueue *journal;
 
     cairo_clip_t *last_clip;
 
@@ -134,8 +145,8 @@ typedef struct _cairo_cogl_surface {
      * side band data on the surface...
      */
     cairo_path_fixed_t *user_path;
-    cairo_matrix_t *ctm;
-    cairo_matrix_t *ctm_inverse;
+    cairo_matrix_t ctm;
+    cairo_matrix_t ctm_inverse;
     cairo_bool_t path_is_rectangle;
     double path_rectangle_x;
     double path_rectangle_y;
@@ -150,15 +161,4 @@ _cairo_cogl_path_fixed_rectangle (cairo_path_fixed_t *path,
 				  cairo_fixed_t width,
 				  cairo_fixed_t height);
 
-cairo_int_status_t
-_cairo_cogl_surface_fill_rectangle (void		     *abstract_surface,
-				    cairo_operator_t	      op,
-				    const cairo_pattern_t    *source,
-				    double		      x,
-				    double		      y,
-				    double		      width,
-				    double		      height,
-				    cairo_matrix_t	     *ctm,
-				    const cairo_clip_t	     *clip);
-
 #endif /* CAIRO_COGL_PRIVATE_H */
diff --git a/src/cairo-cogl-surface.c b/src/cairo-cogl-surface.c
index 0c32940e8..36e5f77d8 100644
--- a/src/cairo-cogl-surface.c
+++ b/src/cairo-cogl-surface.c
@@ -34,7 +34,7 @@
 #include "cairo-error-private.h"
 #include "cairo-path-fixed-private.h"
 #include "cairo-recording-surface-private.h"
-#include "cairo-surface-clipper-private.h"
+#include "cairo-recording-surface-inline.h"
 #include "cairo-fixed-private.h"
 #include "cairo-device-private.h"
 #include "cairo-composite-rectangles-private.h"
@@ -43,9 +43,6 @@
 #include "cairo-cogl-gradient-private.h"
 #include "cairo-arc-private.h"
 #include "cairo-traps-private.h"
-#include "cairo-cogl-context-private.h"
-#include "cairo-cogl-utils-private.h"
-#include "cairo-box-inline.h"
 #include "cairo-surface-subsurface-inline.h"
 #include "cairo-surface-fallback-private.h"
 #include "cairo-surface-offset-private.h"
@@ -56,16 +53,8 @@
 #include <glib.h>
 
 #define CAIRO_COGL_DEBUG 0
-//#define FILL_WITH_COGL_PATH
-//#define USE_CAIRO_PATH_FLATTENER
-#define ENABLE_PATH_CACHE
 //#define DISABLE_BATCHING
-#define USE_COGL_RECTANGLE_API
-#define ENABLE_RECTANGLES_FASTPATH
-
-#if defined (USE_COGL_RECTANGLE_API) || defined (ENABLE_PATH_CACHE)
-#define NEED_COGL_CONTEXT
-#endif
+#define MAX_JOURNAL_SIZE 100
 
 #if CAIRO_COGL_DEBUG && __GNUC__
 #define UNSUPPORTED(reason) ({ \
@@ -82,17 +71,34 @@ typedef struct _cairo_cogl_texture_attributes {
     /* nabbed from cairo_surface_attributes_t... */
     cairo_matrix_t	    matrix;
     cairo_extend_t	    extend;
-    cairo_filter_t	    filter;
     cairo_bool_t	    has_component_alpha;
 
+    CoglPipelineFilter      filter;
     CoglPipelineWrapMode    s_wrap;
     CoglPipelineWrapMode    t_wrap;
 } cairo_cogl_texture_attributes_t;
 
+typedef struct _cairo_cogl_pipeline {
+    int n_layers;
+    cairo_operator_t op;
+
+    /* These are not always the same as the operator's, as sometimes
+     * this is a pre-render for a different operator */
+    cairo_bool_t src_bounded;
+    cairo_bool_t mask_bounded;
+
+    cairo_bool_t has_src_tex_clip;
+    cairo_path_fixed_t src_tex_clip;
+    cairo_bool_t has_mask_tex_clip;
+    cairo_path_fixed_t mask_tex_clip;
+    cairo_rectangle_int_t unbounded_extents;
+
+    CoglPipeline *pipeline;
+} cairo_cogl_pipeline_t;
+
 typedef enum _cairo_cogl_journal_entry_type {
     CAIRO_COGL_JOURNAL_ENTRY_TYPE_RECTANGLE,
     CAIRO_COGL_JOURNAL_ENTRY_TYPE_PRIMITIVE,
-    CAIRO_COGL_JOURNAL_ENTRY_TYPE_PATH,
     CAIRO_COGL_JOURNAL_ENTRY_TYPE_CLIP
 } cairo_cogl_journal_entry_type_t;
 
@@ -107,90 +113,50 @@ typedef struct _cairo_cogl_journal_clip_entry {
 
 typedef struct _cairo_cogl_journal_rect_entry {
     cairo_cogl_journal_entry_t base;
-    CoglPipeline *pipeline;
+    cairo_cogl_pipeline_t *pipeline;
+
     float x;
     float y;
     float width;
     float height;
-    int n_layers;
     cairo_matrix_t ctm;
 } cairo_cogl_journal_rect_entry_t;
 
 typedef struct _cairo_cogl_journal_prim_entry {
     cairo_cogl_journal_entry_t base;
-    CoglPipeline *pipeline;
+    cairo_cogl_pipeline_t *pipeline;
+
     CoglPrimitive *primitive;
-    gboolean has_transform;
     cairo_matrix_t transform;
 } cairo_cogl_journal_prim_entry_t;
 
-typedef struct _cairo_cogl_journal_path_entry {
-    cairo_cogl_journal_entry_t base;
-    CoglPipeline *pipeline;
-    CoglPath *path;
-} cairo_cogl_journal_path_entry_t;
-
 typedef struct _cairo_cogl_path_fill_meta {
-    cairo_cache_entry_t	cache_entry;
-    cairo_reference_count_t ref_count;
-    int counter;
-    cairo_path_fixed_t *user_path;
-    cairo_matrix_t ctm_inverse;
-
-    /* TODO */
-#if 0
-    /* A cached path tessellation should be re-usable with different rotations
-     * and translations but not for different scales.
-     *
-     * one idea is to track the diagonal lengths of a unit rectangle
-     * transformed through the original ctm use to tessellate the geometry
-     * so we can check what the lengths are for any new ctm to know if
-     * this geometry is compatible.
-     */
-#endif
+    cairo_cache_entry_t	base;
+    cairo_path_fixed_t path;
+    cairo_fill_rule_t fill_rule;
+    double tolerance;
 
     CoglPrimitive *prim;
+
+    cairo_freelist_t *freelist;
 } cairo_cogl_path_fill_meta_t;
 
 typedef struct _cairo_cogl_path_stroke_meta {
-    cairo_cache_entry_t	cache_entry;
-    cairo_reference_count_t ref_count;
-    int counter;
-    cairo_path_fixed_t *user_path;
-    cairo_matrix_t ctm_inverse;
+    cairo_cache_entry_t	base;
+    cairo_path_fixed_t path;
     cairo_stroke_style_t style;
     double tolerance;
 
-    /* TODO */
-#if 0
-    /* A cached path tessellation should be re-usable with different rotations
-     * and translations but not for different scales.
-     *
-     * one idea is to track the diagonal lengths of a unit rectangle
-     * transformed through the original ctm use to tessellate the geometry
-     * so we can check what the lengths are for any new ctm to know if
-     * this geometry is compatible.
-     */
-#endif
-
     CoglPrimitive *prim;
+
+    cairo_freelist_t *freelist;
 } cairo_cogl_path_stroke_meta_t;
 
 static cairo_surface_t *
 _cairo_cogl_surface_create_full (cairo_cogl_device_t *dev,
-				 cairo_bool_t ignore_alpha,
-				 CoglFramebuffer *framebuffer,
-				 CoglTexture *texture);
-
-static cairo_int_status_t
-_cairo_cogl_surface_fill (void			    *abstract_surface,
-                          cairo_operator_t	     op,
-                          const cairo_pattern_t	    *source,
-                          const cairo_path_fixed_t  *path,
-                          cairo_fill_rule_t	     fill_rule,
-                          double		     tolerance,
-                          cairo_antialias_t	     antialias,
-                          const cairo_clip_t	    *clip);
+				 cairo_content_t      content,
+				 CoglFramebuffer     *framebuffer,
+				 CoglTexture         *texture);
 
 static void
 _cairo_cogl_journal_flush (cairo_cogl_surface_t *surface);
@@ -198,10 +164,13 @@ _cairo_cogl_journal_flush (cairo_cogl_surface_t *surface);
 cairo_private extern const cairo_surface_backend_t _cairo_cogl_surface_backend;
 
 slim_hidden_proto (cairo_cogl_device_create);
-slim_hidden_proto (cairo_cogl_surface_create);
+slim_hidden_proto (cairo_cogl_surface_create_for_fb);
+slim_hidden_proto (cairo_cogl_onscreen_surface_create);
+slim_hidden_proto (cairo_cogl_offscreen_surface_create);
 slim_hidden_proto (cairo_cogl_surface_get_framebuffer);
 slim_hidden_proto (cairo_cogl_surface_get_texture);
 slim_hidden_proto (cairo_cogl_surface_end_frame);
+slim_hidden_proto (cairo_cogl_surface_synchronize);
 
 static cairo_cogl_device_t *
 to_device (cairo_device_t *device)
@@ -229,66 +198,34 @@ _sanitize_trap (cairo_trapezoid_t *t)
 static cairo_status_t
 _cairo_cogl_surface_ensure_framebuffer (cairo_cogl_surface_t *surface)
 {
-    GError *error = NULL;
+    CoglError *error = NULL;
 
     if (surface->framebuffer)
 	return CAIRO_STATUS_SUCCESS;
 
-    surface->framebuffer = COGL_FRAMEBUFFER (cogl_offscreen_new_to_texture (surface->texture));
-    if (!cogl_framebuffer_allocate (surface->framebuffer, &error)) {
-	g_error_free (error);
+    surface->framebuffer =
+        cogl_offscreen_new_with_texture (surface->texture);
+    if (unlikely (!cogl_framebuffer_allocate (surface->framebuffer,
+                                              &error)))
+    {
+        g_warning ("Could not create framebuffer for surface: %s",
+                   error->message);
+        cogl_error_free (error);
 	cogl_object_unref (surface->framebuffer);
 	surface->framebuffer = NULL;
 	return CAIRO_STATUS_NO_MEMORY;
     }
 
-    cogl_push_framebuffer (surface->framebuffer);
-    cogl_ortho (0, surface->width,
-		surface->height, 0,
-		-1, 100);
-    cogl_pop_framebuffer ();
+    cogl_framebuffer_orthographic (surface->framebuffer, 0, 0,
+                                   cogl_texture_get_width (surface->texture),
+                                   cogl_texture_get_height (surface->texture),
+                                   -1, 100);
 
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_surface_t *
-_cairo_cogl_surface_create_similar (void            *abstract_surface,
-				    cairo_content_t  content,
-				    int              width,
-				    int              height)
-{
-    cairo_cogl_surface_t *reference_surface = abstract_surface;
-    cairo_cogl_surface_t *surface;
-    CoglTexture *texture;
-    cairo_status_t status;
-
-    texture = cogl_texture_new_with_size (width, height,
-					  COGL_TEXTURE_NO_SLICING,
-					  (content & CAIRO_CONTENT_COLOR) ?
-					  COGL_PIXEL_FORMAT_BGRA_8888_PRE :
-					  COGL_PIXEL_FORMAT_A_8);
-    if (!texture)
-        return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
-
-    surface = (cairo_cogl_surface_t *)
-	_cairo_cogl_surface_create_full (to_device(reference_surface->base.device),
-					 (content & CAIRO_CONTENT_ALPHA) == 0,
-					 NULL,
-					 texture);
-    if (unlikely (surface->base.status))
-	return &surface->base;
-
-    status = _cairo_cogl_surface_ensure_framebuffer (surface);
-    if (unlikely (status)) {
-	cairo_surface_destroy (&surface->base);
-	return _cairo_surface_create_in_error (status);
-    }
-
-    return &surface->base;
-}
-
 static cairo_bool_t
-_cairo_cogl_surface_get_extents (void *abstract_surface,
+_cairo_cogl_surface_get_extents (void                  *abstract_surface,
                                  cairo_rectangle_int_t *extents)
 {
     cairo_cogl_surface_t *surface = abstract_surface;
@@ -301,62 +238,109 @@ _cairo_cogl_surface_get_extents (void *abstract_surface,
     return TRUE;
 }
 
+/* Taken from cairo-surface-clipper.c */
+static cairo_status_t
+_cairo_path_fixed_add_box (cairo_path_fixed_t *path,
+			   const cairo_box_t *box)
+{
+    cairo_status_t status;
+
+    status = _cairo_path_fixed_move_to (path, box->p1.x, box->p1.y);
+    if (unlikely (status))
+	return status;
+
+    status = _cairo_path_fixed_line_to (path, box->p2.x, box->p1.y);
+    if (unlikely (status))
+	return status;
+
+    status = _cairo_path_fixed_line_to (path, box->p2.x, box->p2.y);
+    if (unlikely (status))
+	return status;
+
+    status = _cairo_path_fixed_line_to (path, box->p1.x, box->p2.y);
+    if (unlikely (status))
+	return status;
+
+    return _cairo_path_fixed_close_path (path);
+}
+
 static void
-_cairo_cogl_journal_free (cairo_cogl_surface_t *surface)
+_cairo_cogl_journal_discard (cairo_cogl_surface_t *surface)
 {
     GList *l;
 
+    if (!surface->journal) {
+	assert (surface->last_clip == NULL);
+	return;
+    }
+
     for (l = surface->journal->head; l; l = l->next) {
 	cairo_cogl_journal_entry_t *entry = l->data;
+	gsize entry_size;
 
-	if (entry->type == CAIRO_COGL_JOURNAL_ENTRY_TYPE_PRIMITIVE) {
+	switch (entry->type)
+	{
+	case CAIRO_COGL_JOURNAL_ENTRY_TYPE_CLIP: {
+	    cairo_cogl_journal_clip_entry_t *clip_entry =
+		(cairo_cogl_journal_clip_entry_t *)entry;
+	    _cairo_clip_destroy (clip_entry->clip);
+	    entry_size = sizeof (cairo_cogl_journal_clip_entry_t);
+	    break;
+	}
+	case CAIRO_COGL_JOURNAL_ENTRY_TYPE_RECTANGLE: {
+	    cairo_cogl_journal_rect_entry_t *rect_entry =
+		(cairo_cogl_journal_rect_entry_t *)entry;
+	    cogl_object_unref (rect_entry->pipeline->pipeline);
+            if (rect_entry->pipeline->has_src_tex_clip)
+                _cairo_path_fixed_fini (&rect_entry->pipeline->src_tex_clip);
+            if (rect_entry->pipeline->has_mask_tex_clip)
+                _cairo_path_fixed_fini (&rect_entry->pipeline->mask_tex_clip);
+            g_free (rect_entry->pipeline);
+	    entry_size = sizeof (cairo_cogl_journal_rect_entry_t);
+	    break;
+	}
+	case CAIRO_COGL_JOURNAL_ENTRY_TYPE_PRIMITIVE: {
 	    cairo_cogl_journal_prim_entry_t *prim_entry =
 		(cairo_cogl_journal_prim_entry_t *)entry;
-	    cogl_object_unref (prim_entry->primitive);
-	} else if (entry->type == CAIRO_COGL_JOURNAL_ENTRY_TYPE_PATH) {
-	    cairo_cogl_journal_path_entry_t *path_entry =
-		(cairo_cogl_journal_path_entry_t *)entry;
-	    cogl_object_unref (path_entry->path);
+	    cogl_object_unref (prim_entry->pipeline->pipeline);
+            if (prim_entry->primitive)
+	        cogl_object_unref (prim_entry->primitive);
+            if (prim_entry->pipeline->has_src_tex_clip)
+                _cairo_path_fixed_fini (&prim_entry->pipeline->src_tex_clip);
+            if (prim_entry->pipeline->has_mask_tex_clip)
+                _cairo_path_fixed_fini (&prim_entry->pipeline->mask_tex_clip);
+            g_free (prim_entry->pipeline);
+	    entry_size = sizeof (cairo_cogl_journal_prim_entry_t);
+	    break;
 	}
+	default:
+	    assert (0); /* not reached! */
+	    entry_size = 0; /* avoid compiler warning */
+	}
+	g_slice_free1 (entry_size, entry);
     }
 
-    g_queue_free (surface->journal);
-    surface->journal = NULL;
+    g_queue_clear (surface->journal);
+
+    if (surface->last_clip) {
+	_cairo_clip_destroy (surface->last_clip);
+	surface->last_clip = NULL;
+    }
 }
 
-#ifdef FILL_WITH_COGL_PATH
 static void
-_cairo_cogl_journal_log_path (cairo_cogl_surface_t *surface,
-			      CoglPipeline *pipeline,
-			      CoglPath *path)
+_cairo_cogl_journal_free (cairo_cogl_surface_t *surface)
 {
-    cairo_cogl_journal_path_entry_t *entry;
-
-    if (unlikely (surface->journal == NULL))
-	surface->journal = g_queue_new ();
-
-    /* FIXME: Instead of a GList here we should stack allocate the journal
-     * entries so it would be cheaper to allocate and they can all be freed in
-     * one go after flushing! */
-    entry = g_slice_new (cairo_cogl_journal_path_entry_t);
-    entry->base.type = CAIRO_COGL_JOURNAL_ENTRY_TYPE_PATH;
-
-    entry->pipeline = cogl_object_ref (pipeline);
-    entry->path = cogl_object_ref (path);
-
-    g_queue_push_tail (surface->journal, entry);
-
-#ifdef DISABLE_BATCHING
-    _cairo_cogl_journal_flush (surface);
-#endif
+    _cairo_cogl_journal_discard (surface);
+    g_queue_free (surface->journal);
+    surface->journal = NULL;
 }
-#endif /* FILL_WITH_COGL_PATH */
 
 static void
-_cairo_cogl_journal_log_primitive (cairo_cogl_surface_t *surface,
-				   CoglPipeline *pipeline,
-				   CoglPrimitive *primitive,
-				   cairo_matrix_t *transform)
+_cairo_cogl_journal_log_primitive (cairo_cogl_surface_t  *surface,
+				   cairo_cogl_pipeline_t *pipeline,
+				   CoglPrimitive         *primitive,
+				   cairo_matrix_t        *transform)
 {
     cairo_cogl_journal_prim_entry_t *entry;
 
@@ -369,32 +353,34 @@ _cairo_cogl_journal_log_primitive (cairo_cogl_surface_t *surface,
     entry = g_slice_new (cairo_cogl_journal_prim_entry_t);
     entry->base.type = CAIRO_COGL_JOURNAL_ENTRY_TYPE_PRIMITIVE;
 
-    entry->pipeline = cogl_object_ref (pipeline);
+    entry->pipeline = pipeline;
 
-    if (transform) {
-	entry->transform = *transform;
-	entry->has_transform = TRUE;
-    } else
-	entry->has_transform = FALSE;
+    entry->primitive = primitive;
+    if (primitive)
+        cogl_object_ref (primitive);
 
-    entry->primitive = cogl_object_ref (primitive);
+    entry->transform = *transform;
 
     g_queue_push_tail (surface->journal, entry);
 
 #ifdef DISABLE_BATCHING
     _cairo_cogl_journal_flush (surface);
+#else
+    /* To avoid consuming too much memory, flush the journal if it gets
+     * to a certain size */
+    if (g_queue_get_length (surface->journal) > MAX_JOURNAL_SIZE)
+        _cairo_cogl_journal_flush (surface);
 #endif
 }
 
 static void
-_cairo_cogl_journal_log_rectangle (cairo_cogl_surface_t *surface,
-				   CoglPipeline *pipeline,
-				   float x,
-				   float y,
-				   float width,
-				   float height,
-				   int n_layers,
-				   cairo_matrix_t *ctm)
+_cairo_cogl_journal_log_rectangle (cairo_cogl_surface_t  *surface,
+				   cairo_cogl_pipeline_t *pipeline,
+				   float                  x,
+				   float                  y,
+				   float                  width,
+				   float                  height,
+				   cairo_matrix_t        *ctm)
 {
     cairo_cogl_journal_rect_entry_t *entry;
 
@@ -407,7 +393,7 @@ _cairo_cogl_journal_log_rectangle (cairo_cogl_surface_t *surface,
     entry = g_slice_new (cairo_cogl_journal_rect_entry_t);
     entry->base.type = CAIRO_COGL_JOURNAL_ENTRY_TYPE_RECTANGLE;
 
-    entry->pipeline = cogl_object_ref (pipeline);
+    entry->pipeline = pipeline;
 
     entry->x = x;
     entry->y = y;
@@ -415,18 +401,21 @@ _cairo_cogl_journal_log_rectangle (cairo_cogl_surface_t *surface,
     entry->height = height;
     entry->ctm = *ctm;
 
-    entry->n_layers = n_layers;
-
     g_queue_push_tail (surface->journal, entry);
 
 #ifdef DISABLE_BATCHING
     _cairo_cogl_journal_flush (surface);
+#else
+    /* To avoid consuming too much memory, flush the journal if it gets
+     * to a certain size */
+    if (g_queue_get_length (surface->journal) > MAX_JOURNAL_SIZE)
+        _cairo_cogl_journal_flush (surface);
 #endif
 }
 
 static void
 _cairo_cogl_journal_log_clip (cairo_cogl_surface_t *surface,
-			      const cairo_clip_t *clip)
+			      const cairo_clip_t   *clip)
 {
     cairo_cogl_journal_clip_entry_t *entry;
 
@@ -443,133 +432,74 @@ _cairo_cogl_journal_log_clip (cairo_cogl_surface_t *surface,
     g_queue_push_tail (surface->journal, entry);
 }
 
-static void
-_cairo_cogl_journal_discard (cairo_cogl_surface_t *surface)
-{
-    GList *l;
-
-    if (!surface->journal) {
-	assert (surface->last_clip == NULL);
-	return;
-    }
-
-    if (surface->buffer_stack && surface->buffer_stack_offset) {
-	cogl_buffer_unmap (COGL_BUFFER (surface->buffer_stack));
-	cogl_object_unref (surface->buffer_stack);
-	surface->buffer_stack = NULL;
-    }
-
-    for (l = surface->journal->head; l; l = l->next) {
-	cairo_cogl_journal_entry_t *entry = l->data;
-	gsize entry_size;
-
-	switch (entry->type)
-	{
-	case CAIRO_COGL_JOURNAL_ENTRY_TYPE_CLIP: {
-	    cairo_cogl_journal_clip_entry_t *clip_entry =
-		(cairo_cogl_journal_clip_entry_t *)entry;
-	    _cairo_clip_destroy (clip_entry->clip);
-	    entry_size = sizeof (cairo_cogl_journal_clip_entry_t);
-	    break;
-	}
-	case CAIRO_COGL_JOURNAL_ENTRY_TYPE_RECTANGLE: {
-	    cairo_cogl_journal_rect_entry_t *rect_entry =
-		(cairo_cogl_journal_rect_entry_t *)entry;
-	    cogl_object_unref (rect_entry->pipeline);
-	    entry_size = sizeof (cairo_cogl_journal_rect_entry_t);
-	    break;
-	}
-	case CAIRO_COGL_JOURNAL_ENTRY_TYPE_PRIMITIVE: {
-	    cairo_cogl_journal_prim_entry_t *prim_entry =
-		(cairo_cogl_journal_prim_entry_t *)entry;
-	    cogl_object_unref (prim_entry->pipeline);
-	    cogl_object_unref (prim_entry->primitive);
-	    entry_size = sizeof (cairo_cogl_journal_prim_entry_t);
-	    break;
-	}
-	case CAIRO_COGL_JOURNAL_ENTRY_TYPE_PATH: {
-	    cairo_cogl_journal_path_entry_t *path_entry =
-		(cairo_cogl_journal_path_entry_t *)entry;
-	    cogl_object_unref (path_entry->pipeline);
-	    cogl_object_unref (path_entry->path);
-	    entry_size = sizeof (cairo_cogl_journal_path_entry_t);
-	    break;
-	}
-	default:
-	    assert (0); /* not reached! */
-	    entry_size = 0; /* avoid compiler warning */
-	}
-	g_slice_free1 (entry_size, entry);
-    }
-
-    g_queue_clear (surface->journal);
-
-    if (surface->last_clip) {
-	_cairo_clip_destroy (surface->last_clip);
-	surface->last_clip = NULL;
-    }
-}
-
 static CoglAttributeBuffer *
-_cairo_cogl_surface_allocate_buffer_space (cairo_cogl_surface_t *surface,
-					   size_t size,
-					   size_t *offset,
-					   void **pointer)
+_cairo_cogl_device_allocate_buffer_space (cairo_cogl_device_t *dev,
+                                          size_t               size,
+                                          size_t              *offset,
+                                          void               **pointer)
 {
     /* XXX: In the Cogl journal we found it more efficient to have a pool of
      * buffers that we re-cycle but for now we simply throw away our stack
      * buffer each time we flush. */
-    if (unlikely (surface->buffer_stack &&
-		  (surface->buffer_stack_size - surface->buffer_stack_offset) < size)) {
-	cogl_buffer_unmap (COGL_BUFFER (surface->buffer_stack));
-	cogl_object_unref (surface->buffer_stack);
-	surface->buffer_stack = NULL;
-	surface->buffer_stack_size *= 2;
+    if (unlikely (dev->buffer_stack &&
+		  (dev->buffer_stack_size - dev->buffer_stack_offset) < size)) {
+	cogl_buffer_unmap (dev->buffer_stack);
+	cogl_object_unref (dev->buffer_stack);
+	dev->buffer_stack = NULL;
+	dev->buffer_stack_size *= 2;
     }
 
-    if (unlikely (surface->buffer_stack_size < size))
-	surface->buffer_stack_size = size * 2;
+    if (unlikely (dev->buffer_stack_size < size))
+	dev->buffer_stack_size = size * 2;
 
-    if (unlikely (surface->buffer_stack == NULL)) {
-	surface->buffer_stack = cogl_attribute_buffer_new (surface->buffer_stack_size, NULL);
-	surface->buffer_stack_pointer =
-	    cogl_buffer_map (COGL_BUFFER (surface->buffer_stack),
+    if (unlikely (dev->buffer_stack == NULL)) {
+	dev->buffer_stack =
+            cogl_attribute_buffer_new (dev->cogl_context,
+                                       dev->buffer_stack_size,
+                                       NULL);
+	dev->buffer_stack_pointer =
+	    cogl_buffer_map (dev->buffer_stack,
 			     COGL_BUFFER_ACCESS_WRITE,
 			     COGL_BUFFER_MAP_HINT_DISCARD);
-	surface->buffer_stack_offset = 0;
+	dev->buffer_stack_offset = 0;
     }
 
-    *pointer = surface->buffer_stack_pointer + surface->buffer_stack_offset;
-    *offset = surface->buffer_stack_offset;
+    *pointer = dev->buffer_stack_pointer + dev->buffer_stack_offset;
+    *offset = dev->buffer_stack_offset;
 
-    surface->buffer_stack_offset += size;
-    return cogl_object_ref (surface->buffer_stack);
+    dev->buffer_stack_offset += size;
+    return cogl_object_ref (dev->buffer_stack);
 }
 
 
 static CoglAttributeBuffer *
 _cairo_cogl_traps_to_triangles_buffer (cairo_cogl_surface_t *surface,
-				       cairo_traps_t *traps,
-				       size_t *offset,
-				       gboolean one_shot)
+				       cairo_traps_t        *traps,
+				       size_t               *offset,
+				       cairo_bool_t          one_shot)
 {
     CoglAttributeBuffer *buffer;
     int n_traps = traps->num_traps;
     int i;
     CoglVertexP2 *triangles;
+    cairo_cogl_device_t *dev = to_device(surface->base.device);
 
     if (one_shot) {
-	buffer = _cairo_cogl_surface_allocate_buffer_space (surface,
-							    n_traps * sizeof (CoglVertexP2) * 6,
-							    offset,
-							    (void **)&triangles);
+	buffer =
+            _cairo_cogl_device_allocate_buffer_space (dev,
+                                                      n_traps * sizeof (CoglVertexP2) * 6,
+                                                      offset,
+                                                      (void **)&triangles);
 	if (!buffer)
 	    return NULL;
     } else {
-	buffer = cogl_attribute_buffer_new (n_traps * sizeof (CoglVertexP2) * 6, NULL);
+	buffer =
+            cogl_attribute_buffer_new (dev->cogl_context,
+                                       n_traps * sizeof (CoglVertexP2) * 6,
+                                       NULL);
 	if (!buffer)
 	    return NULL;
-	triangles = cogl_buffer_map (COGL_BUFFER (buffer),
+	triangles = cogl_buffer_map (buffer,
 				     COGL_BUFFER_ACCESS_WRITE,
 				     COGL_BUFFER_MAP_HINT_DISCARD);
 	if (!triangles)
@@ -589,122 +519,170 @@ _cairo_cogl_traps_to_triangles_buffer (cairo_cogl_surface_t *surface,
 	CoglVertexP2 *p = &triangles[i * 6];
 	cairo_trapezoid_t *trap = &traps->traps[i];
 
-	p[0].x = _cairo_cogl_util_fixed_to_float (trap->left.p1.x);
-	p[0].y = _cairo_cogl_util_fixed_to_float (trap->left.p1.y);
+	p[0].x = _cairo_fixed_to_double (trap->left.p1.x);
+	p[0].y = _cairo_fixed_to_double (trap->left.p1.y);
 
-	p[1].x = _cairo_cogl_util_fixed_to_float (trap->left.p2.x);
-	p[1].y = _cairo_cogl_util_fixed_to_float (trap->left.p2.y);
+	p[1].x = _cairo_fixed_to_double (trap->left.p2.x);
+	p[1].y = _cairo_fixed_to_double (trap->left.p2.y);
 
-	p[2].x = _cairo_cogl_util_fixed_to_float (trap->right.p2.x);
-	p[2].y = _cairo_cogl_util_fixed_to_float (trap->right.p2.y);
+	p[2].x = _cairo_fixed_to_double (trap->right.p2.x);
+	p[2].y = _cairo_fixed_to_double (trap->right.p2.y);
 
-	p[3].x = _cairo_cogl_util_fixed_to_float (trap->left.p1.x);
-	p[3].y = _cairo_cogl_util_fixed_to_float (trap->left.p1.y);
+	p[3].x = p[0].x;
+	p[3].y = p[0].y;
 
-	p[4].x = _cairo_cogl_util_fixed_to_float (trap->right.p2.x);
-	p[4].y = _cairo_cogl_util_fixed_to_float (trap->right.p2.y);
+	p[4].x = p[2].x;
+	p[4].y = p[2].y;
 
-	p[5].x = _cairo_cogl_util_fixed_to_float (trap->right.p1.x);
-	p[5].y = _cairo_cogl_util_fixed_to_float (trap->right.p1.y);
+	p[5].x = _cairo_fixed_to_double (trap->right.p1.x);
+	p[5].y = _cairo_fixed_to_double (trap->right.p1.y);
     }
 
     if (!one_shot)
-	cogl_buffer_unmap (COGL_BUFFER (buffer));
+	cogl_buffer_unmap (buffer);
 
     return buffer;
 }
 
-/* Used for solid fills, in this case we just need a mesh made of
- * a single (2-component) position attribute. */
 static CoglPrimitive *
-_cairo_cogl_traps_to_composite_prim_p2 (cairo_cogl_surface_t *surface,
-					cairo_traps_t *traps,
-					gboolean one_shot)
+_cairo_cogl_traps_to_composite_prim (cairo_cogl_surface_t *surface,
+				     cairo_traps_t        *traps,
+				     cairo_bool_t          one_shot)
 {
+    int n_traps = traps->num_traps;
     size_t offset;
-    CoglAttributeBuffer *buffer = _cairo_cogl_traps_to_triangles_buffer (surface, traps, &offset, one_shot);
-    CoglAttribute *pos = cogl_attribute_new (buffer,
-					     "cogl_position_in",
-					     sizeof (CoglVertexP2),
-					     offset,
-					     2,
-					     COGL_ATTRIBUTE_TYPE_FLOAT);
+    CoglAttributeBuffer *buffer;
     CoglPrimitive *prim;
+    CoglAttribute *attributes[3];
+    const char *attrib_names[3] = {"cogl_position_in",
+                                   "cogl_tex_coord0_in",
+                                   "cogl_tex_coord1_in"};
+    int i;
+
+    /* XXX: Ideally we would skip tessellating to traps entirely since
+     * given their representation, conversion to triangles is quite expensive.
+     *
+     * This simplifies the conversion to triangles by making the end points of
+     * the two side lines actually just correspond to the corners of the
+     * traps.
+     */
+    for (i = 0; i < n_traps; i++)
+	_sanitize_trap (&traps->traps[i]);
+
+    buffer = _cairo_cogl_traps_to_triangles_buffer (surface,
+                                                    traps,
+                                                    &offset,
+                                                    one_shot);
+
+    /* We create the largest used number of texture coordinate
+     * attributes here to ensure that when cached, they can be reused
+     * with any pipeline that we may associate with a given path. If
+     * the corresponding layer for a texture coordinates attribute
+     * doesn't exist, cogl simply ignores it. Since all of the
+     * attributes are aliasing the same attribute buffer, the overhead
+     * of specifying them is minimal. */
+    for (i = 0; i < 3; i++) {
+        attributes[i] = cogl_attribute_new (buffer,
+                                            attrib_names[i],
+                                            sizeof (CoglVertexP2),
+                                            offset,
+                                            2,
+                                            COGL_ATTRIBUTE_TYPE_FLOAT);
+    }
 
-    /* The attribute will have taken a reference on the buffer */
+    /* The attributes will have taken references on the buffer */
     cogl_object_unref (buffer);
 
-    prim = cogl_primitive_new (COGL_VERTICES_MODE_TRIANGLES,
-			       traps->num_traps * 6, pos, NULL);
+    prim =
+        cogl_primitive_new_with_attributes (COGL_VERTICES_MODE_TRIANGLES,
+			                    n_traps * 6, attributes, 3);
 
-    /* The primitive will now keep the attribute alive... */
-    cogl_object_unref (pos);
+    /* The primitive will now keep the attributes alive... */
+    for (i = 0; i < 3; i++)
+        cogl_object_unref (attributes[i]);
 
     return prim;
 }
 
-/* Used for surface fills, in this case we need a mesh made of a single
- * (2-component) position attribute + we also alias the same attribute as
- * (2-component) texture coordinates */
-static CoglPrimitive *
-_cairo_cogl_traps_to_composite_prim_p2t2 (cairo_cogl_surface_t *surface,
-					  cairo_traps_t *traps,
-					  gboolean one_shot)
+/* In order to facilitate path caching, we transform the input path
+ * into a form that will make all translations and rotations of a given
+ * path identical, thereby allowing them to be identified with
+ * conventional path hashing and equivalence functions. A
+ * transformation matrix is also output so that the path can be
+ * transformed back into its original form during rendering. */
+static cairo_int_status_t
+_cairo_cogl_get_untransformed_path (cairo_path_fixed_t       *copy,
+                                    const cairo_path_fixed_t *orig,
+                                    cairo_matrix_t           *transform_out)
 {
-    size_t offset;
-    CoglAttributeBuffer *buffer = _cairo_cogl_traps_to_triangles_buffer (surface, traps, &offset, one_shot);
-    CoglAttribute *pos = cogl_attribute_new (buffer,
-					     "cogl_position_in",
-					     sizeof (CoglVertexP2),
-					     offset,
-					     2,
-					     COGL_ATTRIBUTE_TYPE_FLOAT);
-    CoglAttribute *tex_coords = cogl_attribute_new (buffer,
-						    "cogl_tex_coord0_in",
-						    sizeof (CoglVertexP2),
-						    0,
-						    2,
-						    COGL_ATTRIBUTE_TYPE_FLOAT);
-    CoglPrimitive *prim;
+    cairo_matrix_t transform;
+    cairo_int_status_t status;
 
-    /* The attributes will have taken references on the buffer */
-    cogl_object_unref (buffer);
+    if (orig->buf.base.num_points < 1)
+        return CAIRO_INT_STATUS_NOTHING_TO_DO;
 
-    prim = cogl_primitive_new (COGL_VERTICES_MODE_TRIANGLES,
-			       traps->num_traps * 6, pos, tex_coords, NULL);
+    status = _cairo_path_fixed_init_copy (copy, orig);
+    if (unlikely (status))
+        return status;
+
+    /* First the path is translated so that its first point lies on the
+     * origin. */
+    cairo_matrix_init_translate (&transform,
+                                 -_cairo_fixed_to_double(orig->buf.points[0].x),
+                                 -_cairo_fixed_to_double(orig->buf.points[0].y));
+
+    /* Then the path is rotated so that its second point lies on the
+     * x axis. */
+    if (orig->buf.base.num_points > 1) {
+        double x = _cairo_fixed_to_double(orig->buf.points[1].x) -
+                   _cairo_fixed_to_double(orig->buf.points[0].x);
+        double y = _cairo_fixed_to_double(orig->buf.points[1].y) -
+                   _cairo_fixed_to_double(orig->buf.points[0].y);
+        double hyp = sqrt (x * x + y * y);
+
+        transform.xx = x / hyp;
+        transform.yy = x / hyp;
+        transform.xy = -y / hyp;
+        transform.yx = y / hyp;
+    }
 
-    /* The primitive will now keep the attributes alive... */
-    cogl_object_unref (pos);
-    cogl_object_unref (tex_coords);
+    _cairo_path_fixed_transform (copy, &transform);
 
-    return prim;
+    *transform_out = transform;
+    status = cairo_matrix_invert (transform_out);
+    if (unlikely (status)) {
+        _cairo_path_fixed_fini (copy);
+        return status;
+    }
+
+    return CAIRO_INT_STATUS_SUCCESS;
 }
 
-static CoglPrimitive *
-_cairo_cogl_traps_to_composite_prim (cairo_cogl_surface_t *surface,
-				     cairo_traps_t *traps,
-				     int n_layers,
-				     gboolean one_shot)
+static void
+_cairo_cogl_path_fill_meta_destroy (cairo_cogl_path_fill_meta_t *meta)
 {
-    int n_traps = traps->num_traps;
-    int i;
+    _cairo_path_fixed_fini (&meta->path);
+    cogl_object_unref (meta->prim);
 
-    /* XXX: Ideally we would skip tessellating to traps entirely since
-     * given their representation, conversion to triangles is quite expensive.
-     *
-     * This simplifies the conversion to triangles by making the end points of
-     * the two side lines actually just correspond to the corners of the
-     * traps.
-     */
-    for (i = 0; i < n_traps; i++)
-	_sanitize_trap (&traps->traps[i]);
+    _cairo_freelist_free (meta->freelist, meta);
+}
 
-    if (n_layers == 0)
-	return _cairo_cogl_traps_to_composite_prim_p2 (surface, traps, one_shot);
-    else {
-	assert (n_layers == 1);
-	return _cairo_cogl_traps_to_composite_prim_p2t2 (surface, traps, one_shot);
-    }
+static cairo_bool_t
+_cairo_cogl_path_fill_meta_equal (const void *key_a, const void *key_b)
+{
+    const cairo_cogl_path_fill_meta_t *meta0 = key_a;
+    const cairo_cogl_path_fill_meta_t *meta1 = key_b;
+
+    if (meta0->fill_rule != meta1->fill_rule)
+        return FALSE;
+
+    if (meta0->tolerance != meta1->tolerance)
+        return FALSE;
+
+    if (!_cairo_path_fixed_equal (&meta0->path, &meta1->path))
+        return FALSE;
+
+    return TRUE;
 }
 
 static cairo_int_status_t
@@ -712,16 +690,48 @@ _cairo_cogl_fill_to_primitive (cairo_cogl_surface_t	*surface,
 			       const cairo_path_fixed_t	*path,
 			       cairo_fill_rule_t	 fill_rule,
 			       double			 tolerance,
-			       int			 n_layers,
 			       cairo_bool_t		 one_shot,
 			       CoglPrimitive	       **primitive,
-			       size_t			*size)
+                               cairo_matrix_t           *transform)
 {
     cairo_traps_t traps;
     cairo_int_status_t status;
+    cairo_cogl_path_fill_meta_t meta;
+    cairo_cogl_path_fill_meta_t *acquired_meta;
+    cairo_cogl_path_fill_meta_t *insert_meta = NULL;
+    cairo_cogl_device_t *dev = to_device (surface->base.device);
+    unsigned long hash;
+
+    *primitive = NULL;
+
+    status = _cairo_cogl_get_untransformed_path (&meta.path,
+                                                 path,
+                                                 transform);
+    if (unlikely (status))
+        return status;
+
+    hash = _cairo_path_fixed_hash (&meta.path);
+    hash = _cairo_hash_bytes (hash, &fill_rule, sizeof (fill_rule));
+    hash = _cairo_hash_bytes (hash, &tolerance, sizeof (tolerance));
+    meta.base.hash = hash;
+    meta.tolerance = tolerance;
+    meta.fill_rule = fill_rule;
+
+    acquired_meta = _cairo_cache_lookup (&dev->path_fill_prim_cache,
+                                         &meta.base);
+
+    if (acquired_meta) {
+        // g_print ("fill cache hit");
+        *primitive = cogl_object_ref (acquired_meta->prim);
+        _cairo_path_fixed_fini (&meta.path);
+        return CAIRO_STATUS_SUCCESS;
+    }
 
     _cairo_traps_init (&traps);
-    status = _cairo_path_fixed_fill_to_traps (path, fill_rule, tolerance, &traps);
+    status = _cairo_path_fixed_fill_to_traps (&meta.path,
+                                              fill_rule,
+                                              tolerance,
+                                              &traps);
     if (unlikely (status))
 	goto BAIL;
 
@@ -730,31 +740,538 @@ _cairo_cogl_fill_to_primitive (cairo_cogl_surface_t	*surface,
 	goto BAIL;
     }
 
-    *size = traps.num_traps * sizeof (CoglVertexP2) * 6;
+    *primitive = _cairo_cogl_traps_to_composite_prim (surface,
+                                                      &traps,
+                                                      one_shot);
+    if (unlikely (!*primitive)) {
+	status = CAIRO_INT_STATUS_NO_MEMORY;
+	goto BAIL;
+    }
+
+    insert_meta =
+        _cairo_freelist_alloc (&dev->path_fill_meta_freelist);
+    if (unlikely (!insert_meta)) {
+        status = CAIRO_INT_STATUS_NO_MEMORY;
+        goto BAIL;
+    }
+
+    insert_meta->base.hash = meta.base.hash;
+    insert_meta->base.size =
+        traps.num_traps * sizeof (CoglVertexP2) * 6;
+    insert_meta->tolerance = tolerance;
+    insert_meta->fill_rule = fill_rule;
+    insert_meta->prim = cogl_object_ref (*primitive);
+    insert_meta->freelist = &dev->path_fill_meta_freelist;
+
+    status = _cairo_path_fixed_init_copy (&insert_meta->path,
+                                          &meta.path);
+    if (unlikely (status))
+        goto BAIL;
+
+    if (unlikely (_cairo_cache_insert (&dev->path_fill_prim_cache,
+                                       &insert_meta->base)))
+    {
+        g_warning ("Fill primitive cache insertion unsuccessful");
+        goto BAIL;
+    }
+
+    _cairo_path_fixed_fini (&meta.path);
+    _cairo_traps_fini (&traps);
+
+    return status;
+
+BAIL:
+    if (*primitive) {
+        cogl_object_unref (*primitive);
+        *primitive = NULL;
+    }
+    if (insert_meta)
+        _cairo_cogl_path_fill_meta_destroy (insert_meta);
+    _cairo_path_fixed_fini (&meta.path);
+    _cairo_traps_fini (&traps);
+
+    return status;
+}
+
+static cairo_bool_t
+_cairo_cogl_stroke_style_equal (const cairo_stroke_style_t *a,
+			        const cairo_stroke_style_t *b)
+{
+    if (a->line_width == b->line_width &&
+	a->line_cap == b->line_cap &&
+	a->line_join == b->line_join &&
+	a->miter_limit == b->miter_limit &&
+	a->num_dashes == b->num_dashes &&
+	a->dash_offset == b->dash_offset)
+    {
+	unsigned int i;
+	for (i = 0; i < a->num_dashes; i++) {
+	    if (a->dash[i] != b->dash[i])
+		return FALSE;
+	}
+    }
+    return TRUE;
+}
+
+static cairo_bool_t
+_cairo_cogl_path_stroke_meta_equal (const void *key_a,
+                                    const void *key_b)
+{
+    const cairo_cogl_path_stroke_meta_t *meta0 = key_a;
+    const cairo_cogl_path_stroke_meta_t *meta1 = key_b;
+
+    if (meta0->tolerance != meta1->tolerance)
+        return FALSE;
+
+    if (!_cairo_cogl_stroke_style_equal (&meta0->style, &meta1->style))
+        return FALSE;
+
+    if (!_cairo_path_fixed_equal (&meta0->path, &meta1->path))
+        return FALSE;
+
+    return TRUE;
+}
+
+static void
+_cairo_cogl_path_stroke_meta_destroy (cairo_cogl_path_stroke_meta_t *meta)
+{
+    _cairo_stroke_style_fini (&meta->style);
+    _cairo_path_fixed_fini (&meta->path);
+    cogl_object_unref (meta->prim);
+
+    _cairo_freelist_free (meta->freelist, meta);
+}
+
+static unsigned long
+_cairo_cogl_stroke_style_hash (unsigned long               hash,
+			       const cairo_stroke_style_t *style)
+{
+    unsigned int i;
+    hash = _cairo_hash_bytes (hash, &style->line_width, sizeof (style->line_width));
+    hash = _cairo_hash_bytes (hash, &style->line_cap, sizeof (style->line_cap));
+    hash = _cairo_hash_bytes (hash, &style->line_join, sizeof (style->line_join));
+    hash = _cairo_hash_bytes (hash, &style->miter_limit, sizeof (style->miter_limit));
+    hash = _cairo_hash_bytes (hash, &style->num_dashes, sizeof (style->num_dashes));
+    hash = _cairo_hash_bytes (hash, &style->dash_offset, sizeof (style->dash_offset));
+    for (i = 0; i < style->num_dashes; i++)
+	hash = _cairo_hash_bytes (hash, &style->dash[i], sizeof (double));
+    return hash;
+}
+
+static cairo_int_status_t
+_cairo_cogl_stroke_to_primitive (cairo_cogl_surface_t	    *surface,
+				 const cairo_path_fixed_t   *path,
+				 const cairo_stroke_style_t *style,
+				 double			     tolerance,
+				 cairo_bool_t		     one_shot,
+				 CoglPrimitive		   **primitive,
+                                 cairo_matrix_t             *transform)
+{
+    cairo_traps_t traps;
+    cairo_int_status_t status;
+    cairo_cogl_path_stroke_meta_t meta;
+    cairo_cogl_path_stroke_meta_t *acquired_meta;
+    cairo_cogl_path_stroke_meta_t *insert_meta = NULL;
+    cairo_matrix_t identity;
+    cairo_cogl_device_t *dev = to_device (surface->base.device);
+    unsigned long hash;
+
+    *primitive = NULL;
+
+    status = _cairo_cogl_get_untransformed_path (&meta.path,
+                                                 path,
+                                                 transform);
+    if (unlikely (status))
+        return status;
+
+    hash = _cairo_path_fixed_hash (&meta.path);
+    hash = _cairo_cogl_stroke_style_hash (hash, style);
+    hash = _cairo_hash_bytes (hash, &tolerance, sizeof (tolerance));
+    meta.base.hash = hash;
+    meta.tolerance = tolerance;
+
+    status = _cairo_stroke_style_init_copy (&meta.style, style);
+    if (unlikely (status)) {
+        _cairo_path_fixed_fini (&meta.path);
+        return status;
+    }
+
+    acquired_meta = _cairo_cache_lookup (&dev->path_stroke_prim_cache,
+                                         &meta.base);
+
+    if (acquired_meta) {
+        // g_print ("stroke cache hit");
+        *primitive = cogl_object_ref (acquired_meta->prim);
+        _cairo_path_fixed_fini (&meta.path);
+        return CAIRO_STATUS_SUCCESS;
+    }
+
+    _cairo_traps_init (&traps);
+
+    cairo_matrix_init_identity (&identity);
+    status = _cairo_path_fixed_stroke_polygon_to_traps (&meta.path,
+                                                        style,
+                                                        &identity,
+                                                        &identity,
+                                                        tolerance,
+                                                        &traps);
+    if (unlikely (status))
+	goto BAIL;
+
+    if (traps.num_traps == 0) {
+	status = CAIRO_INT_STATUS_NOTHING_TO_DO;
+	goto BAIL;
+    }
 
-    *primitive = _cairo_cogl_traps_to_composite_prim (surface, &traps, n_layers, one_shot);
-    if (!*primitive) {
+    *primitive = _cairo_cogl_traps_to_composite_prim (surface,
+                                                      &traps,
+                                                      one_shot);
+    if (unlikely (!*primitive)) {
 	status = CAIRO_INT_STATUS_NO_MEMORY;
 	goto BAIL;
     }
 
+    insert_meta =
+        _cairo_freelist_alloc (&dev->path_stroke_meta_freelist);
+    if (unlikely (!insert_meta)) {
+        status = CAIRO_INT_STATUS_NO_MEMORY;
+        goto BAIL;
+    }
+
+    insert_meta->base.hash = meta.base.hash;
+    insert_meta->base.size =
+        traps.num_traps * sizeof (CoglVertexP2) * 6;
+    insert_meta->tolerance = tolerance;
+    insert_meta->prim = cogl_object_ref (*primitive);
+    insert_meta->freelist = &dev->path_stroke_meta_freelist;
+
+    status = _cairo_stroke_style_init_copy (&insert_meta->style,
+                                            style);
+    if (unlikely (status)) {
+        _cairo_stroke_style_fini (&insert_meta->style);
+        free (insert_meta);
+        insert_meta = NULL;
+        goto BAIL;
+    }
+
+    status = _cairo_path_fixed_init_copy (&insert_meta->path,
+                                          &meta.path);
+    if (unlikely (status))
+        goto BAIL;
+
+    if (unlikely (_cairo_cache_insert (&dev->path_stroke_prim_cache,
+                                       &insert_meta->base)))
+    {
+        g_warning ("Stroke primitive cache insertion unsuccessful");
+        goto BAIL;
+    }
+
+    _cairo_path_fixed_fini (&meta.path);
+    _cairo_stroke_style_fini (&meta.style);
+    _cairo_traps_fini (&traps);
+
+    return status;
+
 BAIL:
+    if (*primitive) {
+        cogl_object_unref (*primitive);
+        *primitive = NULL;
+    }
+    if (insert_meta)
+        _cairo_cogl_path_stroke_meta_destroy (insert_meta);
+    _cairo_path_fixed_fini (&meta.path);
+    _cairo_stroke_style_fini (&meta.style);
     _cairo_traps_fini (&traps);
+
     return status;
 }
 
 static void
-_cairo_cogl_clip_push_box (const cairo_box_t *box)
+_cairo_cogl_set_path_prim_clip (cairo_cogl_surface_t *surface,
+                                cairo_path_fixed_t   *path,
+                                int                  *clip_stack_depth,
+                                cairo_fill_rule_t     fill_rule,
+                                double                tolerance)
+{
+    cairo_rectangle_int_t extents;
+    cairo_int_status_t status;
+    CoglPrimitive *prim;
+    cairo_matrix_t transform;
+    CoglMatrix matrix;
+    double x1, y1, x2, y2;
+
+    status = _cairo_cogl_fill_to_primitive (surface,
+                                            path,
+                                            fill_rule,
+                                            tolerance,
+                                            FALSE,
+                                            &prim,
+                                            &transform);
+    if (status == CAIRO_INT_STATUS_NOTHING_TO_DO) {
+        /* If the clip is of zero fill area, set all clipped */
+        cogl_framebuffer_push_scissor_clip (surface->framebuffer,
+                                            0, 0, 0, 0);
+        (*clip_stack_depth)++;
+        return;
+    } else if (unlikely (status)) {
+        g_warning ("Failed to get primitive for clip path while "
+                   "flushing journal");
+        goto BAIL;
+    }
+
+    float transformfv[16] = {
+        transform.xx, transform.yx, 0, 0,
+        transform.xy, transform.yy, 0, 0,
+        0,            0,            1, 0,
+        transform.x0, transform.y0, 0, 1
+    };
+
+    cogl_matrix_init_from_array (&matrix, transformfv);
+
+    cogl_framebuffer_push_matrix (surface->framebuffer);
+    cogl_framebuffer_transform (surface->framebuffer, &matrix);
+
+    _cairo_path_fixed_approximate_clip_extents (path, &extents);
+
+    /* The extents need to be transformed by the inverse of the
+     * modelview matrix because they are in terms of un-transformed
+     * device coordinates and the bounds coordinates will be
+     * transformed by the modelview matrix */
+    status = cairo_matrix_invert (&transform);
+    if (unlikely (status)) {
+        g_warning ("Could not apply clip due to invalid matrix from "
+                   "path transformation");
+        goto BAIL;
+    }
+
+    x1 = extents.x;
+    y1 = extents.y;
+    x2 = extents.x + extents.width;
+    y2 = extents.y + extents.height;
+    _cairo_matrix_transform_bounding_box (&transform,
+                                          &x1, &y1, &x2, &y2,
+                                          NULL);
+
+    cogl_framebuffer_push_primitive_clip (surface->framebuffer, prim,
+                                          x1, y1, x2, y2);
+    (*clip_stack_depth)++;
+
+    cogl_framebuffer_pop_matrix (surface->framebuffer);
+
+BAIL:
+    if (prim)
+        cogl_object_unref (prim);
+}
+
+/* This is the way in which we handle CAIRO_EXTEND_NONE set on the
+ * source or mask pattern surfaces, as well as unbounded operators.
+ * First, we limit the rendering area to the region which will not be
+ * sampled from beyond the source or mask textures with additional clip
+ * paths, which were created when we obtained the original pipeline.
+ * The region will also be limited by the drawing area due to the fact
+ * we are drawing with the original primitive's vertices.
+ *
+ * In order to handle unbounded operators, we do a second rendering pass
+ * for places outside of such region. We limit the rending to outside
+ * this region by using a depth buffer to preserve all places where
+ * rendering took place during the first pass. For this region, we also
+ * have to remove the CAIRO_EXTEND_NONE clips if the operator is not
+ * bound by their respective contents. Because OpenGL sets all vertex
+ * z-values to 0.0 if none are supplied in the attributes data (we only
+ * supply x and y values), it will update the region in the buffer to a
+ * value over the default clearing value of 1.0. Given that the default
+ * test function is GL_LESS, we don't have to set z attributes on the
+ * vertices of the second rendering pass either, as 0.0 will never be
+ * less than 0.0. If cogl ever adds a method to clip out a primitive
+ * instead of just clipping it in, we may be able to use a more
+ * efficient method using the stencil buffer. */
+static void
+_cairo_cogl_apply_tex_clips (cairo_cogl_surface_t  *surface,
+                             int                   *clip_stack_depth,
+                             cairo_cogl_pipeline_t *pipeline)
+{
+    CoglDepthState depth_state;
+    CoglBool cogl_status;
+
+    /* Enable the depth test if it will be needed */
+    if ((!pipeline->mask_bounded && pipeline->has_mask_tex_clip) ||
+        (!pipeline->src_bounded && pipeline->has_src_tex_clip))
+    {
+        cogl_depth_state_init (&depth_state);
+        cogl_depth_state_set_test_enabled (&depth_state, TRUE);
+        cogl_status = cogl_pipeline_set_depth_state (pipeline->pipeline,
+                                                     &depth_state,
+                                                     NULL);
+        if (unlikely (cogl_status != TRUE))
+            g_warning ("Error setting depth state for unbounded render");
+
+        /* Clear the depth buffer to 1.0. The color values are unused
+         * placeholders. */
+        cogl_framebuffer_clear4f (surface->framebuffer,
+                                  COGL_BUFFER_BIT_DEPTH,
+                                  0.0, 0.0, 0.0, 0.0);
+    }
+
+    if (pipeline->mask_bounded && !pipeline->src_bounded) {
+        /* Push mask clip first so later we can pop the source clip
+         * and still be bound by the mask clip */
+        if (pipeline->has_mask_tex_clip)
+            _cairo_cogl_set_path_prim_clip (surface,
+                                            &pipeline->mask_tex_clip,
+                                            clip_stack_depth,
+                                            CAIRO_FILL_RULE_WINDING,
+                                            0.0);
+        if (pipeline->has_src_tex_clip)
+            _cairo_cogl_set_path_prim_clip (surface,
+                                            &pipeline->src_tex_clip,
+                                            clip_stack_depth,
+                                            CAIRO_FILL_RULE_WINDING,
+                                            0.0);
+    } else {
+        if (pipeline->has_src_tex_clip)
+            _cairo_cogl_set_path_prim_clip (surface,
+                                            &pipeline->src_tex_clip,
+                                            clip_stack_depth,
+                                            CAIRO_FILL_RULE_WINDING,
+                                            0.0);
+        if (pipeline->has_mask_tex_clip)
+            _cairo_cogl_set_path_prim_clip (surface,
+                                            &pipeline->mask_tex_clip,
+                                            clip_stack_depth,
+                                            CAIRO_FILL_RULE_WINDING,
+                                            0.0);
+    }
+}
+
+/* Get the pipeline for the second pass */
+static CoglPipeline *
+_cairo_cogl_setup_unbounded_area_pipeline (cairo_cogl_surface_t *surface,
+                                           cairo_operator_t      op)
+{
+    CoglPipeline *unbounded_pipeline;
+    CoglDepthState depth_state;
+    CoglBool cogl_status;
+    cairo_cogl_device_t *dev = to_device(surface->base.device);
+
+    /* If a template pipeline exists for any given operator, the
+     * corresponding solid template pipeline always exists */
+    unbounded_pipeline =
+        cogl_pipeline_copy (dev->template_pipelines[op][CAIRO_COGL_TEMPLATE_TYPE_SOLID]);
+    cogl_pipeline_set_color4f (unbounded_pipeline, 0.0, 0.0, 0.0, 0.0);
+
+    /* Enable depth test on second-pass pipeline */
+    cogl_depth_state_init (&depth_state);
+    cogl_depth_state_set_test_enabled (&depth_state, TRUE);
+    cogl_status = cogl_pipeline_set_depth_state (unbounded_pipeline,
+                                                 &depth_state,
+                                                 NULL);
+    if (unlikely (cogl_status != TRUE))
+        g_warning ("Error setting depth state for unbounded render");
+
+    return unbounded_pipeline;
+}
+
+static void
+_cairo_cogl_unbounded_render (cairo_cogl_surface_t  *surface,
+                              int                   *clip_stack_depth,
+                              cairo_cogl_pipeline_t *pipeline,
+                              cairo_bool_t          *needs_vertex_render)
+{
+    /* We will need a second rendering of the original vertices if we
+     * still need to be bounded by the mask but had a source tex clip */
+    *needs_vertex_render = FALSE;
+
+    /* Pop all unbounded tex clips. Do not pop clips the operator is
+     * bounded by, so that we can still be bounded by them during the
+     * second pass (vertex render or extents render). */
+    if (pipeline->mask_bounded && pipeline->src_bounded) {
+        /* We don't need a second pass if it will just be in the same
+         * region as the first */
+    } else if (pipeline->src_bounded) {
+        if (pipeline->has_mask_tex_clip) {
+            cogl_framebuffer_pop_clip (surface->framebuffer);
+            (*clip_stack_depth)--;
+        }
+    } else if (pipeline->mask_bounded) {
+        if (pipeline->has_src_tex_clip) {
+            cogl_framebuffer_pop_clip (surface->framebuffer);
+            (*clip_stack_depth)--;
+            *needs_vertex_render = TRUE;
+        }
+    } else {
+        if (pipeline->has_src_tex_clip) {
+            cogl_framebuffer_pop_clip (surface->framebuffer);
+            (*clip_stack_depth)--;
+        }
+        if (pipeline->has_mask_tex_clip) {
+            cogl_framebuffer_pop_clip (surface->framebuffer);
+            (*clip_stack_depth)--;
+        }
+    }
+
+    /* If an operator is unbounded by the mask, we need to render the
+     * second transparent pass within the full unbounded extents */
+    if (!pipeline->mask_bounded) {
+        CoglPipeline *unbounded_pipeline;
+
+        /* Draw a transparent rectangle to cover the entire extents */
+        unbounded_pipeline =
+            _cairo_cogl_setup_unbounded_area_pipeline (surface,
+                                                       pipeline->op);
+        cogl_framebuffer_draw_rectangle (surface->framebuffer,
+                                         unbounded_pipeline,
+                                         pipeline->unbounded_extents.x,
+                                         pipeline->unbounded_extents.y,
+                                         pipeline->unbounded_extents.x + pipeline->unbounded_extents.width,
+                                         pipeline->unbounded_extents.y + pipeline->unbounded_extents.height);
+        cogl_object_unref (unbounded_pipeline);
+    }
+}
+
+static void
+_cairo_cogl_post_unbounded_render (cairo_cogl_surface_t  *surface,
+                                   int                   *clip_stack_depth,
+                                   cairo_cogl_pipeline_t *pipeline)
 {
-    if (_cairo_box_is_pixel_aligned (box)) {
-	cairo_rectangle_int_t rect;
-	_cairo_box_round_to_rectangle (box, &rect);
-	cogl_clip_push_window_rectangle (rect.x, rect.y,
-					 rect.width, rect.height);
+    CoglDepthState depth_state;
+    CoglBool cogl_status;
+
+    /* Disable the depth test */
+    if ((!pipeline->mask_bounded && pipeline->has_mask_tex_clip) ||
+        (!pipeline->src_bounded && pipeline->has_src_tex_clip))
+    {
+        cogl_depth_state_init (&depth_state);
+        cogl_depth_state_set_test_enabled (&depth_state, FALSE);
+        cogl_status = cogl_pipeline_set_depth_state (pipeline->pipeline,
+                                                     &depth_state,
+                                                     NULL);
+        if (unlikely (cogl_status != TRUE))
+            g_warning ("Error setting depth state after unbounded render");
+    }
+
+    /* Pop all bounded tex clips (those that were not popped before) */
+    if (pipeline->src_bounded && pipeline->mask_bounded) {
+        if (pipeline->has_src_tex_clip) {
+            cogl_framebuffer_pop_clip (surface->framebuffer);
+            (*clip_stack_depth)--;
+        }
+        if (pipeline->has_mask_tex_clip) {
+            cogl_framebuffer_pop_clip (surface->framebuffer);
+            (*clip_stack_depth)--;
+        }
+    } else if (pipeline->src_bounded) {
+        if (pipeline->has_src_tex_clip) {
+            cogl_framebuffer_pop_clip (surface->framebuffer);
+            (*clip_stack_depth)--;
+        }
+    } else if (pipeline->mask_bounded) {
+        if (pipeline->has_mask_tex_clip) {
+            cogl_framebuffer_pop_clip (surface->framebuffer);
+            (*clip_stack_depth)--;
+        }
     } else {
-	double x1, y1, x2, y2;
-	_cairo_box_to_doubles (box, &x1, &y1, &x2, &y2);
-	cogl_clip_push_rectangle (x1, y1, x2, y2);
+        /* We have already popped all of the clips in the
+         * unbounded_render function */
     }
 }
 
@@ -762,21 +1279,26 @@ static void
 _cairo_cogl_journal_flush (cairo_cogl_surface_t *surface)
 {
     GList *l;
+    cairo_cogl_device_t *dev;
     int clip_stack_depth = 0;
     int i;
 
     if (!surface->journal)
 	return;
 
-    if (surface->buffer_stack && surface->buffer_stack_offset) {
-	cogl_buffer_unmap (COGL_BUFFER (surface->buffer_stack));
-	cogl_object_unref (surface->buffer_stack);
-	surface->buffer_stack = NULL;
+    dev = to_device(surface->base.device);
+    if (dev->buffer_stack && dev->buffer_stack_offset) {
+	cogl_buffer_unmap (dev->buffer_stack);
+	cogl_object_unref (dev->buffer_stack);
+	dev->buffer_stack = NULL;
     }
 
-    cogl_set_framebuffer (surface->framebuffer);
+    if (unlikely (_cairo_cogl_surface_ensure_framebuffer (surface))) {
+        g_warning ("Could not get framebuffer for flushing journal");
+        assert (0);
+    }
 
-    cogl_push_matrix ();
+    cogl_framebuffer_push_matrix (surface->framebuffer);
 
     for (l = surface->journal->head; l; l = l->next) {
 	cairo_cogl_journal_entry_t *entry = l->data;
@@ -787,58 +1309,46 @@ _cairo_cogl_journal_flush (cairo_cogl_surface_t *surface)
 	    cairo_cogl_journal_clip_entry_t *clip_entry =
 		(cairo_cogl_journal_clip_entry_t *)entry;
 	    cairo_clip_path_t *path;
-#if 0
-	    cairo_bool_t checked_for_primitives = FALSE;
-	    cairo_cogl_clip_primitives_t *clip_primitives;
-#endif
 
 	    for (i = 0; i < clip_stack_depth; i++)
-		cogl_clip_pop ();
+		cogl_framebuffer_pop_clip (surface->framebuffer);
 	    clip_stack_depth = 0;
 
-	    for (path = clip_entry->clip->path, i = 0; path; path = path->prev, i++) {
-		cairo_rectangle_int_t extents;
-		cairo_int_status_t status;
-		CoglPrimitive *prim;
-		size_t prim_size;
-
-		_cairo_path_fixed_approximate_clip_extents (&path->path, &extents);
-
-		/* TODO - maintain a fifo of the last 10 used clips with cached
-		 * primitives to see if we can avoid tessellating the path and
-		 * uploading the vertices...
-		 */
-#if 0
-		if (!checked_for_primitives) {
-		    clip_primitives = find_clip_primitives (clip);
-		    checked_for_primitives = TRUE;
-		}
-		if (clip_primitives)
-		    prim = clip_primitives->primitives[i];
-#endif
-		status = _cairo_cogl_fill_to_primitive (surface,
-							&path->path,
-							path->fill_rule,
-							path->tolerance,
-							0,
-							TRUE,
-							&prim,
-							&prim_size);
-		if (unlikely (status)) {
-		    g_warning ("Failed to get primitive for clip path while flushing journal");
-		    continue;
-		}
-		clip_stack_depth++;
-		cogl_clip_push_primitive (prim,
-					  extents.x, extents.y,
-					  extents.x + extents.width,
-					  extents.y + extents.height);
-		cogl_object_unref (prim);
-	    }
-
-	    for (i = 0; i < clip_entry->clip->num_boxes; i++) {
-		clip_stack_depth++;
-		_cairo_cogl_clip_push_box (&clip_entry->clip->boxes[i]);
+            if (clip_entry->clip == NULL)
+                continue; // there is no clip
+
+	    for (path = clip_entry->clip->path, i = 0;
+                 path;
+                 path = path->prev, i++)
+            {
+                _cairo_cogl_set_path_prim_clip (surface,
+                                                &path->path,
+                                                &clip_stack_depth,
+                                                path->fill_rule,
+                                                path->tolerance);
+            }
+
+	    if (clip_entry->clip->num_boxes > 0) {
+                cairo_path_fixed_t boxes_path;
+
+                _cairo_path_fixed_init (&boxes_path);
+                for (int i = 0; i < clip_entry->clip->num_boxes; i++) {
+                    if (unlikely (_cairo_path_fixed_add_box (&boxes_path,
+                                                             &clip_entry->clip->boxes[i])))
+                    {
+                        g_warning ("Could not add all clip boxes while "
+                                   "flushing journal");
+                        break;
+                    }
+                }
+
+                _cairo_cogl_set_path_prim_clip (surface,
+                                                &boxes_path,
+                                                &clip_stack_depth,
+                                                CAIRO_FILL_RULE_WINDING,
+                                                0.0);
+
+                _cairo_path_fixed_fini (&boxes_path);
 	    }
 
 	    surface->n_clip_updates_per_frame++;
@@ -860,59 +1370,104 @@ _cairo_cogl_journal_flush (cairo_cogl_surface_t *surface)
 		ctm->x0, ctm->y0, 0, 1
 	    };
 	    CoglMatrix transform;
+            cairo_bool_t needs_vertex_render;
+            CoglPipeline *unbounded_pipeline;
 
 	    cogl_matrix_init_from_array (&transform, ctmfv);
 
-	    if (rect_entry->n_layers) {
-		g_assert (rect_entry->n_layers <= 2);
+            _cairo_cogl_apply_tex_clips (surface,
+                                         &clip_stack_depth,
+                                         rect_entry->pipeline);
+
+	    if (rect_entry->pipeline->n_layers) {
+		g_assert (rect_entry->pipeline->n_layers <= 2);
 		tex_coords[0] = x1;
 		tex_coords[1] = y1;
 		tex_coords[2] = x2;
 		tex_coords[3] = y2;
-		if (rect_entry->n_layers > 1)
+		if (rect_entry->pipeline->n_layers > 1)
 		    memcpy (&tex_coords[4], tex_coords, sizeof (float) * 4);
 	    }
 
-	    cogl_set_source (rect_entry->pipeline);
-	    cogl_push_matrix ();
-	    cogl_transform (&transform);
-	    cogl_rectangle_with_multitexture_coords (x1, y1, x2, y2,
-						     tex_coords, 4 * rect_entry->n_layers);
-	    cogl_pop_matrix ();
+	    cogl_framebuffer_push_matrix (surface->framebuffer);
+	    cogl_framebuffer_transform (surface->framebuffer, &transform);
+	    cogl_framebuffer_draw_multitextured_rectangle (surface->framebuffer,
+                                                           rect_entry->pipeline->pipeline,
+                                                           x1, y1,
+                                                           x2, y2,
+						           tex_coords,
+                                                           4 * rect_entry->pipeline->n_layers);
+
+            _cairo_cogl_unbounded_render (surface,
+                                          &clip_stack_depth,
+                                          rect_entry->pipeline,
+                                          &needs_vertex_render);
+            if (needs_vertex_render) {
+                unbounded_pipeline =
+                    _cairo_cogl_setup_unbounded_area_pipeline (surface,
+                                                               rect_entry->pipeline->op);
+                cogl_framebuffer_draw_multitextured_rectangle (surface->framebuffer,
+                                                               unbounded_pipeline,
+                                                               x1, y1,
+                                                               x2, y2,
+						               tex_coords,
+                                                               4 * rect_entry->pipeline->n_layers);
+                cogl_object_unref (unbounded_pipeline);
+            }
+            _cairo_cogl_post_unbounded_render (surface,
+                                               &clip_stack_depth,
+                                               rect_entry->pipeline);
+
+	    cogl_framebuffer_pop_matrix (surface->framebuffer);
 	    break;
 	}
 	case CAIRO_COGL_JOURNAL_ENTRY_TYPE_PRIMITIVE: {
 	    cairo_cogl_journal_prim_entry_t *prim_entry =
 		(cairo_cogl_journal_prim_entry_t *)entry;
 	    CoglMatrix transform;
-
-	    cogl_push_matrix ();
-	    if (prim_entry->has_transform) {
-		cairo_matrix_t *ctm = &prim_entry->transform;
-		float ctmfv[16] = {
-		    ctm->xx, ctm->yx, 0, 0,
-		    ctm->xy, ctm->yy, 0, 0,
-		    0,	     0,	      1, 0,
-		    ctm->x0, ctm->y0, 0, 1
-		};
-		cogl_matrix_init_from_array (&transform, ctmfv);
-		cogl_transform (&transform);
-	    } else {
-		cogl_matrix_init_identity (&transform);
-		cogl_set_modelview_matrix (&transform);
-	    }
-
-	    cogl_set_source (prim_entry->pipeline);
-	    cogl_primitive_draw (prim_entry->primitive);
-	    cogl_pop_matrix ();
-	    break;
-	}
-	case CAIRO_COGL_JOURNAL_ENTRY_TYPE_PATH: {
-	    cairo_cogl_journal_path_entry_t *path_entry =
-		(cairo_cogl_journal_path_entry_t *)entry;
-
-	    cogl_set_source (path_entry->pipeline);
-	    cogl_path_fill (path_entry->path);
+            cairo_bool_t needs_vertex_render;
+            CoglPipeline *unbounded_pipeline;
+
+            _cairo_cogl_apply_tex_clips (surface,
+                                         &clip_stack_depth,
+                                         prim_entry->pipeline);
+
+	    cogl_framebuffer_push_matrix (surface->framebuffer);
+            cairo_matrix_t *ctm = &prim_entry->transform;
+            float ctmfv[16] = {
+                ctm->xx, ctm->yx, 0, 0,
+                ctm->xy, ctm->yy, 0, 0,
+                0,       0,       1, 0,
+                ctm->x0, ctm->y0, 0, 1
+            };
+            cogl_matrix_init_from_array (&transform, ctmfv);
+            cogl_framebuffer_transform (surface->framebuffer, &transform);
+
+            /* If the primitive is NULL, it means we just draw the
+             * unbounded rectangle */
+            if (prim_entry->primitive)
+	        cogl_primitive_draw (prim_entry->primitive,
+                                     surface->framebuffer,
+                                     prim_entry->pipeline->pipeline);
+
+            _cairo_cogl_unbounded_render (surface,
+                                          &clip_stack_depth,
+                                          prim_entry->pipeline,
+                                          &needs_vertex_render);
+            if (needs_vertex_render && prim_entry->primitive) {
+                unbounded_pipeline =
+                    _cairo_cogl_setup_unbounded_area_pipeline (surface,
+                                                               prim_entry->pipeline->op);
+                cogl_primitive_draw (prim_entry->primitive,
+                                     surface->framebuffer,
+                                     unbounded_pipeline);
+                cogl_object_unref (unbounded_pipeline);
+            }
+            _cairo_cogl_post_unbounded_render (surface,
+                                               &clip_stack_depth,
+                                               prim_entry->pipeline);
+
+	    cogl_framebuffer_pop_matrix (surface->framebuffer);
 	    break;
 	}
 	default:
@@ -920,16 +1475,16 @@ _cairo_cogl_journal_flush (cairo_cogl_surface_t *surface)
 	}
     }
 
-    cogl_pop_matrix ();
+    cogl_framebuffer_pop_matrix (surface->framebuffer);
 
     for (i = 0; i < clip_stack_depth; i++)
-	cogl_clip_pop ();
+	cogl_framebuffer_pop_clip (surface->framebuffer);
 
     _cairo_cogl_journal_discard (surface);
 }
 
 static cairo_status_t
-_cairo_cogl_surface_flush (void *abstract_surface,
+_cairo_cogl_surface_flush (void    *abstract_surface,
 			   unsigned flags)
 {
     cairo_cogl_surface_t *surface = (cairo_cogl_surface_t *)abstract_surface;
@@ -962,6 +1517,68 @@ _cairo_cogl_surface_finish (void *abstract_surface)
     return CAIRO_STATUS_SUCCESS;
 }
 
+static CoglTextureComponents
+get_components_from_cairo_content (cairo_content_t content)
+{
+    /* We use RGBA for color-only surfaces due to the fact that cogl
+     * does not provide a padded XRGB format, thereby making us use
+     * RGBA formats to represent e.g. CAIRO_FORMAT_RGB24 and doing very
+     * expensive format conversions on the cpu when images are read
+     * back */
+    return (content & CAIRO_CONTENT_COLOR) ?
+           COGL_TEXTURE_COMPONENTS_RGBA :
+           COGL_TEXTURE_COMPONENTS_A;
+}
+
+static CoglPixelFormat
+get_default_cogl_format_from_components (CoglTextureComponents components)
+{
+    switch (components)
+    {
+    case COGL_TEXTURE_COMPONENTS_A:
+        return COGL_PIXEL_FORMAT_A_8;
+    case COGL_TEXTURE_COMPONENTS_RG:
+        return COGL_PIXEL_FORMAT_RG_88;
+    case COGL_TEXTURE_COMPONENTS_RGB:
+    case COGL_TEXTURE_COMPONENTS_RGBA:
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+	return COGL_PIXEL_FORMAT_BGRA_8888_PRE;
+#else
+	return COGL_PIXEL_FORMAT_ARGB_8888_PRE;
+#endif
+    case COGL_TEXTURE_COMPONENTS_DEPTH:
+        return COGL_PIXEL_FORMAT_DEPTH_32;
+    default:
+        return 0;
+    }
+}
+
+static CoglTextureComponents
+get_components_from_cairo_format (cairo_format_t format)
+{
+    switch (format)
+    {
+    case CAIRO_FORMAT_A1:
+    case CAIRO_FORMAT_A8:
+        return COGL_TEXTURE_COMPONENTS_A;
+
+    case CAIRO_FORMAT_RGB16_565:
+    case CAIRO_FORMAT_RGB24:
+    case CAIRO_FORMAT_RGB30:
+    case CAIRO_FORMAT_RGB96F:
+        return COGL_TEXTURE_COMPONENTS_RGB;
+
+    case CAIRO_FORMAT_ARGB32:
+    case CAIRO_FORMAT_RGBA128F:
+        return COGL_TEXTURE_COMPONENTS_RGBA;
+
+    case CAIRO_FORMAT_INVALID:
+    default:
+        g_warning("Cairo format unrepresentable by cogl");
+        return 0;
+    }
+}
+
 static CoglPixelFormat
 get_cogl_format_from_cairo_format (cairo_format_t cairo_format);
 
@@ -976,7 +1593,13 @@ get_cairo_format_from_cogl_format (CoglPixelFormat format)
 	return CAIRO_FORMAT_A8;
     case COGL_PIXEL_FORMAT_RGB_565:
 	return CAIRO_FORMAT_RGB16_565;
-
+    case COGL_PIXEL_FORMAT_RG_88:
+        g_warning ("cairo cannot handle red-green textures");
+        return CAIRO_FORMAT_INVALID;
+    case COGL_PIXEL_FORMAT_DEPTH_32:
+        g_warning ("cairo cannot handle depth textures");
+        return CAIRO_FORMAT_INVALID;
+    
     case COGL_PIXEL_FORMAT_BGRA_8888_PRE:
     case COGL_PIXEL_FORMAT_ARGB_8888_PRE:
     case COGL_PIXEL_FORMAT_RGBA_8888_PRE:
@@ -985,7 +1608,7 @@ get_cairo_format_from_cogl_format (CoglPixelFormat format)
 	return CAIRO_FORMAT_ARGB32;
 
     default:
-	g_warning("bad format: %x a? %d, bgr? %d, pre %d, format: %d\n",
+	g_warning("bad format: %x a? %d, bgr? %d, pre %d, format: %d",
 		  format,
 		  format & COGL_A_BIT,
 		  format & COGL_BGR_BIT,
@@ -1014,6 +1637,8 @@ get_cogl_format_from_cairo_format (cairo_format_t cairo_format)
     case CAIRO_FORMAT_INVALID:
     case CAIRO_FORMAT_A1:
     case CAIRO_FORMAT_RGB30:
+    case CAIRO_FORMAT_RGB96F:
+    case CAIRO_FORMAT_RGBA128F:
 	return 0;
     }
 
@@ -1021,6 +1646,58 @@ get_cogl_format_from_cairo_format (cairo_format_t cairo_format)
     return 0;
 }
 
+static cairo_surface_t *
+_cairo_cogl_surface_create_similar (void            *abstract_surface,
+				    cairo_content_t  content,
+				    int              width,
+				    int              height)
+{
+    cairo_cogl_surface_t *reference_surface = abstract_surface;
+    cairo_cogl_surface_t *surface;
+    CoglTexture *texture;
+    cairo_status_t status;
+    cairo_cogl_device_t *dev =
+        to_device(reference_surface->base.device);
+    int tex_width = width;
+    int tex_height = height;
+
+    /* In the case of lack of NPOT texture support, we allocate texture
+     * with dimensions of the next power of two */
+    if (!dev->has_npots) {
+        tex_width = pow (2, ceil (log2 (tex_width)));
+        tex_height = pow (2, ceil (log2 (tex_height)));
+    }
+
+    texture = cogl_texture_2d_new_with_size (dev->cogl_context,
+                                             tex_width, tex_height);
+    if (!texture)
+        return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
+
+    cogl_texture_set_components (texture,
+        get_components_from_cairo_content (content));
+
+    surface = (cairo_cogl_surface_t *)
+	_cairo_cogl_surface_create_full (dev, content, NULL, texture);
+    if (unlikely (surface->base.status))
+	return &surface->base;
+
+    /* The surface will take a reference on the texture */
+    cogl_object_unref (texture);
+
+    /* If we passed a texture with larger dimensions, we need to set
+     * the surface dimensions */
+    surface->width = width;
+    surface->height = height;
+
+    status = _cairo_cogl_surface_ensure_framebuffer (surface);
+    if (unlikely (status)) {
+	cairo_surface_destroy (&surface->base);
+	return _cairo_surface_create_in_error (status);
+    }
+
+    return &surface->base;
+}
+
 static cairo_status_t
 _cairo_cogl_surface_read_rect_to_image_surface (cairo_cogl_surface_t   *surface,
 						cairo_rectangle_int_t  *interest,
@@ -1031,32 +1708,32 @@ _cairo_cogl_surface_read_rect_to_image_surface (cairo_cogl_surface_t   *surface,
     cairo_format_t cairo_format;
     CoglPixelFormat cogl_format;
 
-    /* TODO: Add cogl_texture_get_region() API so we don't have to ensure the
-     * surface is bound to an fbo to read back pixels */
     status = _cairo_cogl_surface_ensure_framebuffer (surface);
     if (unlikely (status))
 	return status;
 
-    cairo_format = get_cairo_format_from_cogl_format (surface->cogl_format);
-    if (cairo_format == CAIRO_FORMAT_INVALID) {
-	cairo_format = CAIRO_FORMAT_ARGB32;
-	cogl_format = get_cogl_format_from_cairo_format (cairo_format);
+    if (surface->texture)
+    {
+        cogl_format =
+            get_default_cogl_format_from_components (
+                cogl_texture_get_components (surface->texture) );
+        cairo_format = get_cairo_format_from_cogl_format (cogl_format);
     } else {
-	cogl_format = cogl_framebuffer_get_color_format (surface->framebuffer);
+        cairo_format =
+            _cairo_format_from_content (surface->base.content);
+        cogl_format = get_cogl_format_from_cairo_format (cairo_format);
     }
 
     image = (cairo_image_surface_t *)
-	cairo_image_surface_create (cairo_format, surface->width, surface->height);
+        cairo_image_surface_create (cairo_format,
+                                    surface->width,
+                                    surface->height);
     if (image->base.status)
-	return image->base.status;
+        return image->base.status;
 
-    /* TODO: Add cogl_framebuffer_read_pixels() API */
-    cogl_push_framebuffer (surface->framebuffer);
-    cogl_read_pixels (0, 0, surface->width, surface->height,
-		      COGL_READ_PIXELS_COLOR_BUFFER,
-		      cogl_format,
-		      image->data);
-    cogl_pop_framebuffer ();
+    cogl_framebuffer_read_pixels (surface->framebuffer, 0, 0,
+                                  surface->width, surface->height,
+                                  cogl_format, image->data);
 
     *image_out = image;
 
@@ -1071,17 +1748,44 @@ _cairo_cogl_surface_acquire_source_image (void		         *abstract_surface,
     cairo_cogl_surface_t *surface = abstract_surface;
     cairo_status_t status;
 
+    if (unlikely (_cairo_surface_flush (abstract_surface, 0)))
+        g_warning ("Error flushing journal while acquiring image");
+
     if (surface->texture) {
-	cairo_format_t format = get_cairo_format_from_cogl_format (surface->cogl_format);
-	cairo_image_surface_t *image = (cairo_image_surface_t *)
-	    cairo_image_surface_create (format, surface->width, surface->height);
-	if (image->base.status)
-	    return image->base.status;
+        CoglTextureComponents components =
+            cogl_texture_get_components(surface->texture);
+        CoglPixelFormat cogl_format =
+            get_default_cogl_format_from_components (components);
+        cairo_format_t cairo_format =
+            get_cairo_format_from_cogl_format (cogl_format);
+        if (cairo_format == CAIRO_FORMAT_INVALID) {
+            cairo_format = CAIRO_FORMAT_ARGB32;
+            cogl_format =
+                get_cogl_format_from_cairo_format (cairo_format);
+        }
 
-	cogl_texture_get_data (surface->texture,
-			       cogl_texture_get_format (surface->texture),
-			       0,
-			       image->data);
+        /* We use the actual texture dimensions here instead, because
+         * if we have a larger texture than the surface dimensions for
+         * devices not supporting NPOT textures, the surface dimensions
+         * will not be able to fit the data */
+        cairo_image_surface_t *image = (cairo_image_surface_t *)
+	        cairo_image_surface_create (cairo_format,
+	                                    cogl_texture_get_width (surface->texture),
+	                                    cogl_texture_get_height (surface->texture));
+        if (image->base.status)
+            return image->base.status;
+
+        cogl_texture_get_data (surface->texture,
+                               cogl_format,
+                               0,
+                               image->data);
+
+        /* If the texture dimensions were different than the surface
+         * dimensions, this will set them to the correct values.
+         * Because the stride stays the same, it will still function
+         * correctly */
+        image->width = surface->width;
+        image->height = surface->height;
 
 	image->base.is_clear = FALSE;
 	*image_out = image;
@@ -1110,7 +1814,7 @@ _cairo_cogl_surface_release_source_image (void			*abstract_surface,
 
 static cairo_status_t
 _cairo_cogl_surface_clear (cairo_cogl_surface_t *surface,
-			   const cairo_color_t *color)
+			   const cairo_color_t  *color)
 {
     /* Anything batched in the journal up until now is redundant... */
     _cairo_cogl_journal_discard (surface);
@@ -1170,67 +1874,10 @@ _cairo_cogl_path_fixed_rectangle (cairo_path_fixed_t *path,
     return CAIRO_STATUS_SUCCESS;
 }
 
-static cairo_int_status_t
-_cairo_cogl_surface_paint (void                  *abstract_surface,
-                           cairo_operator_t       op,
-                           const cairo_pattern_t *source,
-                           const cairo_clip_t    *clip)
-{
-    cairo_cogl_surface_t *surface;
-    cairo_path_fixed_t path;
-    cairo_status_t status;
-    cairo_matrix_t identity;
-
-    if (clip == NULL) {
-	if (op == CAIRO_OPERATOR_CLEAR)
-            return _cairo_cogl_surface_clear (abstract_surface, CAIRO_COLOR_TRANSPARENT);
-	else if (source->type == CAIRO_PATTERN_TYPE_SOLID &&
-                (op == CAIRO_OPERATOR_SOURCE ||
-                 (op == CAIRO_OPERATOR_OVER && (((cairo_surface_t *)abstract_surface)->is_clear || _cairo_pattern_is_opaque_solid (source))))) {
-            return _cairo_cogl_surface_clear (abstract_surface,
-					      &((cairo_solid_pattern_t *) source)->color);
-        }
-    }
-
-    /* fallback to handling the paint in terms of a fill... */
-
-    surface = abstract_surface;
-
-    _cairo_path_fixed_init (&path);
-
-    status = _cairo_cogl_path_fixed_rectangle (&path, 0, 0, surface->width, surface->height);
-    if (unlikely (status))
-	goto BAIL;
-
-#ifdef NEED_COGL_CONTEXT
-    /* XXX: in cairo-cogl-context.c we set some sideband data on the
-     * surface before issuing a fill so we need to do that here too... */
-    surface->user_path = &path;
-    cairo_matrix_init_identity (&identity);
-    surface->ctm = &identity;
-    surface->ctm_inverse = &identity;
-    surface->path_is_rectangle = TRUE;
-    surface->path_rectangle_x = 0;
-    surface->path_rectangle_y = 0;
-    surface->path_rectangle_width = surface->width;
-    surface->path_rectangle_height = surface->height;
-#endif
-
-    status = _cairo_cogl_surface_fill (abstract_surface,
-				       op,
-				       source,
-				       &path,
-				       CAIRO_FILL_RULE_WINDING,
-				       1,
-				       CAIRO_ANTIALIAS_DEFAULT,
-				       clip);
-BAIL:
-    _cairo_path_fixed_fini (&path);
-    return status;
-}
 
 static CoglPipelineWrapMode
-get_cogl_wrap_mode_for_extend (cairo_extend_t extend_mode)
+get_cogl_wrap_mode_for_extend (cairo_extend_t       extend_mode,
+                               cairo_cogl_device_t *dev)
 {
     switch (extend_mode)
     {
@@ -1241,236 +1888,734 @@ get_cogl_wrap_mode_for_extend (cairo_extend_t extend_mode)
     case CAIRO_EXTEND_REPEAT:
 	return COGL_PIPELINE_WRAP_MODE_REPEAT;
     case CAIRO_EXTEND_REFLECT:
-	/* TODO: return COGL_PIPELINE_WRAP_MODE_MIRROR; */
-	return CAIRO_EXTEND_REPEAT;
+        if (!dev->has_mirrored_repeat)
+            /* If the hardware cannot support mirrored repeating, we
+             * emulate it elsewhere */
+            return COGL_PIPELINE_WRAP_MODE_REPEAT;
+        else
+	    return COGL_PIPELINE_WRAP_MODE_MIRRORED_REPEAT;
     }
     assert (0); /* not reached */
     return COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE;
 }
 
-#if 0
-/* Given an arbitrary texture, check if it's already a pot texture and simply
- * return it back if so. If not create a new pot texture, scale the old to
- * fill it, unref the old and return a pointer to the new pot texture. */
-static cairo_int_status_t
-_cairo_cogl_get_pot_texture (CoglContext *context,
-			     CoglTexture *texture,
-			     CoglTexture **pot_texture)
-{
-    int width = cogl_texture_get_width (texture);
-    int height = cogl_texture_get_height (texture);
-    int pot_width;
-    int pot_height;
-    CoglHandle offscreen = NULL;
-    CoglTexture2D *pot = NULL;
-    GError *error;
-
-    pot_width = _cairo_cogl_util_next_p2 (width);
-    pot_height = _cairo_cogl_util_next_p2 (height);
-
-    if (pot_width == width && pot_height == height)
-	return CAIRO_INT_STATUS_SUCCESS;
-
-    for (;;) {
-	error = NULL;
-	pot = cogl_texture_2d_new_with_size (context,
-					     pot_width,
-					     pot_height,
-					     cogl_texture_get_format (texture),
-					     &error);
-	if (pot)
-	    break;
-	else
-	    g_error_free (error);
+static CoglPipelineFilter
+get_cogl_filter_for_filter (cairo_filter_t filter)
+{
+    switch (filter)
+    {
+    case CAIRO_FILTER_FAST:
+    case CAIRO_FILTER_NEAREST:
+        return COGL_PIPELINE_FILTER_NEAREST;
 
-	if (pot_width > pot_height)
-	    pot_width >>= 1;
-	else
-	    pot_height >>= 1;
+    case CAIRO_FILTER_GOOD:
+    case CAIRO_FILTER_BEST:
+    case CAIRO_FILTER_BILINEAR:
+        return COGL_PIPELINE_FILTER_LINEAR;
 
-	if (!pot_width || !pot_height)
-	    break;
+    case CAIRO_FILTER_GAUSSIAN:
+    default:
+        g_warning("Invalid pattern filter");
+        return COGL_PIPELINE_FILTER_NEAREST;
+    }
+}
+
+static void
+_cairo_cogl_matrix_all_scale (cairo_matrix_t *matrix,
+                              double          xscale,
+                              double          yscale)
+{
+    /* Since cairo_matrix_scale does not scale the x0 and y0 components,
+     * which is required for scaling translations to normalized
+     * coordinates, use a custom solution here. */
+    matrix->xx *= xscale;
+    matrix->yx *= yscale;
+    matrix->xy *= xscale;
+    matrix->yy *= yscale;
+    matrix->x0 *= xscale;
+    matrix->y0 *= yscale;
+}
+
+static CoglTexture *
+_cairo_cogl_scale_texture (CoglContext           *context,
+                           CoglTexture           *texture_in,
+                           unsigned int           new_width,
+                           unsigned int           new_height,
+                           cairo_bool_t           do_mirror_texture,
+                           cairo_bool_t           always_new_texture)
+{
+    CoglTexture *texture_out = NULL;
+    CoglPipeline *copying_pipeline = NULL;
+    CoglFramebuffer *fb = NULL;
+    CoglError *error = NULL;
+    unsigned int tex_width = new_width;
+    unsigned int tex_height = new_height;
+
+    /* If the texture is already in the desired dimensions and we are
+     * not mirroring it, copying it, or reading from different extents,
+     * return it unmodified */
+    if (!do_mirror_texture && !always_new_texture &&
+        new_width == cogl_texture_get_width (texture_in) &&
+        new_height == cogl_texture_get_height (texture_in))
+        return texture_in;
+
+    if (do_mirror_texture) {
+        tex_width *= 2;
+        tex_height *= 2;
+    }
+
+    texture_out =
+        cogl_texture_2d_new_with_size (context, tex_width, tex_height);
+    if (unlikely (!texture_out)) {
+        g_warning ("Failed to get texture for scaling");
+        goto BAIL;
+    }
+
+    cogl_texture_set_components (texture_out,
+        cogl_texture_get_components (texture_in));
+
+    fb = cogl_offscreen_new_with_texture (texture_out);
+    if (unlikely (!cogl_framebuffer_allocate (fb, &error))) {
+        g_warning ("Could not get framebuffer for texture scaling: %s",
+                   error->message);
+        cogl_error_free (error);
+        goto BAIL;
+    }
+
+    cogl_framebuffer_orthographic (fb, 0, 0,
+                                       tex_width, tex_height,
+                                       -1, 100);
+
+    copying_pipeline = cogl_pipeline_new (context);
+    cogl_pipeline_set_layer_texture (copying_pipeline, 0, texture_in);
+    cogl_pipeline_set_layer_filters (copying_pipeline, 0,
+                                     COGL_PIPELINE_FILTER_NEAREST,
+                                     COGL_PIPELINE_FILTER_NEAREST);
+
+    if (do_mirror_texture) {
+        /* Draw four rectangles to the new texture with the appropriate
+         * reflection on each one */
+
+        const float rect_coordinates[32] = {
+            /* Rectangle 1 */
+            0, 0, 0.5 * tex_width, 0.5 * tex_height,
+            0, 0, 1, 1,
+
+            /* Rectangle 2 */
+            tex_width, 0, 0.5 * tex_width, 0.5 * tex_height,
+            0, 0, 1, 1,
+
+            /* Rectangle 3 */
+            0, tex_height, 0.5 * tex_width, 0.5 * tex_height,
+            0, 0, 1, 1,
+
+            /* Rectangle 4 */
+            tex_width, tex_height, 0.5 * tex_width, 0.5 * tex_height,
+            0, 0, 1, 1
+        };
+
+        cogl_framebuffer_draw_textured_rectangles (fb,
+                                                   copying_pipeline,
+                                                   rect_coordinates,
+                                                   4);
+    } else {
+        cogl_framebuffer_draw_textured_rectangle (fb,
+                                                  copying_pipeline,
+                                                  0, 0,
+                                                  tex_width,
+                                                  tex_height,
+                                                  0, 0, 1, 1);
     }
 
-    *pot_texture = COGL_TEXTURE (pot);
+    cogl_object_unref (fb);
+    cogl_object_unref (copying_pipeline);
+    cogl_object_unref (texture_in);
 
-    if (!pot)
-	return CAIRO_INT_STATUS_NO_MEMORY;
+    return texture_out;
 
-    /* Use the GPU to do a bilinear filtered scale from npot to pot... */
-    offscreen = cogl_offscreen_new_to_texture (COGL_TEXTURE (pot));
-    error = NULL;
-    if (!cogl_framebuffer_allocate (COGL_FRAMEBUFFER (offscreen), &error)) {
-	/* NB: if we don't pass an error then Cogl is allowed to simply abort
-	 * automatically. */
-	g_error_free (error);
-	cogl_object_unref (pot);
-	*pot_texture = NULL;
-	return CAIRO_INT_STATUS_NO_MEMORY;
+BAIL:
+    if (texture_out)
+        cogl_object_unref (texture_out);
+    if (fb)
+        cogl_object_unref (fb);
+    if (copying_pipeline)
+        cogl_object_unref (copying_pipeline);
+
+    return NULL;
+}
+
+/* NB: a reference for the texture is transferred to the caller which
+ * should be unrefed */
+static CoglTexture *
+_cairo_cogl_acquire_cogl_surface_texture (cairo_cogl_surface_t        *reference_surface,
+                                          cairo_surface_t             *surface,
+                                          const cairo_rectangle_int_t *surface_extents,
+                                          const cairo_matrix_t        *pattern_matrix,
+                                          cairo_matrix_t              *out_matrix,
+                                          const cairo_bool_t           need_mirrored_texture,
+                                          cairo_bool_t                *is_mirrored_texture)
+{
+    CoglTexture *texture;
+    cairo_surface_t *clone = NULL;
+    cairo_cogl_surface_t *cogl_surface =
+        (cairo_cogl_surface_t *)surface;
+    cairo_bool_t do_mirror_texture;
+    cairo_cogl_device_t *dev =
+        to_device (reference_surface->base.device);
+    double xscale, yscale;
+    int new_width = surface_extents->width;
+    int new_height = surface_extents->height;
+
+    if (surface_extents->x < 0 || surface_extents->y < 0 ||
+        (surface_extents->x + surface_extents->width) >
+            cogl_surface->width ||
+        (surface_extents->y + surface_extents->height) >
+            cogl_surface->height)
+        return NULL;
+
+    *out_matrix = *pattern_matrix;
+    *is_mirrored_texture = FALSE;
+
+    if (unlikely (_cairo_surface_flush (surface, 0))) {
+        g_warning ("Error flushing source surface while getting "
+                   "pattern texture");
+        goto BAIL;
+    }
+
+    *is_mirrored_texture =
+        need_mirrored_texture || cogl_surface->is_mirrored_snapshot;
+    do_mirror_texture =
+        need_mirrored_texture && !cogl_surface->is_mirrored_snapshot;
+
+    /* There seems to be a bug in which cogl isn't flushing its own
+     * internal journal when reading from dependent sub-textures.
+     * If this is ever fixed, the following block of code can be
+     * removed. */
+    {
+        _cairo_cogl_surface_ensure_framebuffer (cogl_surface);
+        cogl_framebuffer_finish (cogl_surface->framebuffer);
+    }
+    /* We copy the surface to a new texture, thereby making a
+     * snapshot of it, as its contents may change between the time
+     * we log the pipeline and when we flush the journal. The sub
+     * texture itself cannot be used while drawing primitives, so we do
+     * a copy to a 2d texture. */
+    texture = cogl_sub_texture_new (dev->cogl_context,
+                                    cogl_surface->texture,
+                                    surface_extents->x,
+                                    surface_extents->y,
+                                    surface_extents->width,
+                                    surface_extents->height);
+    if (unlikely (!texture))
+        goto BAIL;
+
+    /* If we do not support NPOT dimensions, scale the new texture to
+     * the next power of two while copying */
+    if (!dev->has_npots) {
+        new_width = (int)pow (2, ceil (log2 (new_width)));
+        new_height = (int)pow (2, ceil (log2 (new_height)));
     }
+    texture = _cairo_cogl_scale_texture (dev->cogl_context,
+                                         texture,
+                                         new_width,
+                                         new_height,
+                                         do_mirror_texture,
+                                         TRUE);
+    if (unlikely (!texture))
+        goto BAIL;
+
+    clone =
+        _cairo_cogl_surface_create_full (dev,
+                                         reference_surface->base.content,
+                                         NULL,
+                                         texture);
+    if (unlikely (clone->status)) {
+        g_warning ("Could not get clone surface for texture");
+        goto BAIL;
+    }
+    _cairo_surface_attach_snapshot (surface, clone, NULL);
+
+    /* Attaching the snapshot will take a reference on the clone surface... */
+    cairo_surface_destroy (clone);
+    clone = NULL;
+
+    /* Convert from un-normalized source coordinates in backend
+     * coordinates to normalized texture coordinates. */
+    if (*is_mirrored_texture) {
+        xscale = 0.5 / surface_extents->width;
+        yscale = 0.5 / surface_extents->height;
+    } else {
+        xscale = 1.0 / surface_extents->width;
+        yscale = 1.0 / surface_extents->height;
+    }
+    _cairo_cogl_matrix_all_scale (out_matrix, xscale, yscale);
+
+    return texture;
 
-    cogl_push_framebuffer (COGL_FRAMEBUFFER (offscreen));
-    cogl_set_source_texture (texture);
-    cogl_rectangle (-1, 1, 1, -1);
-    cogl_pop_framebuffer ();
+BAIL:
+    if (texture)
+        cogl_object_unref (texture);
+    if (clone)
+        cairo_surface_destroy (clone);
 
-    cogl_object_unref (offscreen);
+    return NULL;
 }
-#endif
 
-/* NB: a reference for the texture is transferred to the caller which should
- * be unrefed */
+/* NB: a reference for the texture is transferred to the caller which
+ * should be unrefed */
 static CoglTexture *
-_cairo_cogl_acquire_surface_texture (cairo_cogl_surface_t  *reference_surface,
-				     cairo_surface_t	   *abstract_surface)
+_cairo_cogl_acquire_recording_surface_texture (cairo_cogl_surface_t        *reference_surface,
+                                               cairo_surface_t             *surface,
+                                               const cairo_rectangle_int_t *extents,
+                                               const cairo_matrix_t        *pattern_matrix,
+                                               cairo_matrix_t              *out_matrix,
+                                               const cairo_bool_t           need_mirrored_texture,
+                                               cairo_bool_t                *is_mirrored_texture)
 {
+    CoglTexture *texture = NULL;
+    cairo_surface_t *clone = NULL;
+    cairo_cogl_device_t *dev =
+        to_device (reference_surface->base.device);
+    cairo_matrix_t transform;
+    int tex_height, tex_width;
+    double xscale, yscale;
+
+    *is_mirrored_texture = FALSE;
+
+    /* We will pre-transform all of the drawing by the pattern matrix
+     * and confine it to the required extents, so no later transform
+     * will be required */
+    cairo_matrix_init_translate (out_matrix, -extents->x, -extents->y);
+
+    cairo_matrix_init_translate (&transform, extents->x, extents->y);
+    cairo_matrix_multiply (&transform, &transform, pattern_matrix);
+
+    if (!dev->has_npots) {
+        /* Record to a texture sized to the next power of two */
+        tex_width = (int)pow (2, ceil (log2 (extents->width)));
+        tex_height = (int)pow (2, ceil (log2 (extents->height)));
+
+        /* And scale accordingly */
+        cairo_matrix_scale (&transform,
+                            (double)extents->width / (double)tex_width,
+                            (double)extents->height / (double)tex_height);
+    } else {
+        tex_width = extents->width;
+        tex_height = extents->height;
+    }
+
+    texture = cogl_texture_2d_new_with_size (dev->cogl_context,
+                                             tex_width,
+                                             tex_height);
+    if (unlikely (!texture)) {
+        g_warning ("Failed to create texture for replaying recording "
+                   "surface");
+        goto BAIL;
+    }
+
+    cogl_texture_set_components (texture,
+        get_components_from_cairo_content (surface->content));
+
+    /* Do not attach this as a snapshot, as it only represents part of
+     * the surface */
+    clone =
+        _cairo_cogl_surface_create_full (dev,
+                                         reference_surface->base.content,
+                                         NULL,
+                                         texture);
+    if (unlikely (_cairo_cogl_surface_ensure_framebuffer ((cairo_cogl_surface_t *)clone)))
+    {
+        g_warning ("Could not get framebuffer for replaying recording "
+                   "surface");
+        goto BAIL;
+    }
+
+    if (unlikely (_cairo_recording_surface_replay_with_clip (surface,
+                                                             &transform,
+                                                             clone,
+                                                             NULL)))
+    {
+        g_warning ("Could not replay recording surface");
+        goto BAIL;
+    }
+    _cairo_cogl_journal_flush ((cairo_cogl_surface_t *)clone);
+    cairo_surface_destroy (clone);
+
+    if (need_mirrored_texture) {
+        /* Scale to the same image extents, but mirror the texture,
+         * thereby making it larger */
+        texture = _cairo_cogl_scale_texture (dev->cogl_context,
+                                             texture,
+                                             tex_width,
+                                             tex_height,
+                                             TRUE,
+                                             FALSE);
+        if (unlikely (!texture))
+            goto BAIL;
+
+        *is_mirrored_texture = TRUE;
+    }
+
+    /* Convert from un-normalized source coordinates in backend
+     * coordinates to normalized texture coordinates. */
+    if (*is_mirrored_texture) {
+        xscale = 0.5 / extents->width;
+        yscale = 0.5 / extents->height;
+    } else {
+        xscale = 1.0 / extents->width;
+        yscale = 1.0 / extents->height;
+    }
+    _cairo_cogl_matrix_all_scale (out_matrix, xscale, yscale);
+
+    return texture;
+
+BAIL:
+    if (clone)
+        cairo_surface_destroy (clone);
+    if (texture)
+        cogl_object_unref (texture);
+
+    return NULL;
+}
+
+/* NB: a reference for the texture is transferred to the caller which
+ * should be unrefed */
+static CoglTexture *
+_cairo_cogl_acquire_generic_surface_texture (cairo_cogl_surface_t *reference_surface,
+                                             cairo_surface_t      *surface,
+                                             const cairo_matrix_t *pattern_matrix,
+                                             cairo_matrix_t       *out_matrix,
+                                             const cairo_bool_t    need_mirrored_texture,
+                                             cairo_bool_t         *is_mirrored_texture)
+{
+    CoglTexture *texture = NULL;
     cairo_image_surface_t *image;
     cairo_image_surface_t *acquired_image = NULL;
     void *image_extra;
-    CoglPixelFormat format;
     cairo_image_surface_t *image_clone = NULL;
-    CoglTexture2D *texture;
-    GError *error = NULL;
-    cairo_surface_t *clone;
+    CoglBitmap *bitmap;
+    CoglError *error = NULL;
+    cairo_surface_t *clone = NULL;
+    CoglPixelFormat format;
+    cairo_cogl_device_t *dev =
+        to_device (reference_surface->base.device);
+    ptrdiff_t stride;
+    unsigned char *data;
+    double xscale, yscale;
 
-    if (abstract_surface->device == reference_surface->base.device) {
-	cairo_cogl_surface_t *surface = (cairo_cogl_surface_t *)abstract_surface;
-	_cairo_cogl_surface_flush (surface, 0);
-	return surface->texture ? cogl_object_ref (surface->texture) : NULL;
+    *out_matrix = *pattern_matrix;
+    *is_mirrored_texture = FALSE;
+
+    if (_cairo_surface_is_image (surface)) {
+        image = (cairo_image_surface_t *)surface;
+    } else {
+        cairo_status_t status =
+            _cairo_surface_acquire_source_image (surface,
+                                                 &acquired_image,
+                                                 &image_extra);
+        if (unlikely (status)) {
+            g_warning ("acquire_source_image failed: %s [%d]",
+                        cairo_status_to_string (status), status);
+            return NULL;
+        }
+        image = acquired_image;
     }
 
-    if (abstract_surface->type == CAIRO_SURFACE_TYPE_COGL) {
-	if (_cairo_surface_is_subsurface (abstract_surface)) {
-	    cairo_cogl_surface_t *surface;
+    format = get_cogl_format_from_cairo_format (image->format);
+    if (!format) {
+        image_clone = _cairo_image_surface_coerce (image);
+        if (unlikely (image_clone->base.status)) {
+            g_warning ("image_surface_coerce failed");
+            texture = NULL;
+            goto BAIL;
+        }
 
-	    surface = (cairo_cogl_surface_t *)
-		_cairo_surface_subsurface_get_target (abstract_surface);
-	    if (surface->base.device == reference_surface->base.device)
-		return surface->texture ? cogl_object_ref (surface->texture) : NULL;
-	}
-    }
+        format =
+            get_cogl_format_from_cairo_format (image_clone->format);
+        assert (format);
 
-    clone = _cairo_surface_has_snapshot (abstract_surface, &_cairo_cogl_surface_backend);
-    if (clone) {
-	cairo_cogl_surface_t *surface = (cairo_cogl_surface_t *)clone;
-	return surface->texture ? cogl_object_ref (surface->texture) : NULL;
+        image = image_clone;
     }
 
-    g_warning ("Uploading image surface to texture");
-
-    if (_cairo_surface_is_image (abstract_surface)) {
-	image = (cairo_image_surface_t *)abstract_surface;
+    if (image->stride < 0) {
+        /* If the stride is negative, this modifies the data pointer so
+         * that all of the pixels are read into the texture, but
+         * upside-down. We then invert the matrix so the texture is
+         * read from the bottom up instead of from the top down. */
+        stride = -image->stride;
+        data = image->data - stride * (image->height - 1);
+
+        out_matrix->yx *= -1.0;
+        out_matrix->yy *= -1.0;
+        out_matrix->y0 += image->height;
     } else {
-	cairo_status_t status = _cairo_surface_acquire_source_image (abstract_surface,
-								     &acquired_image, &image_extra);
-	if (unlikely (status)) {
-	    g_warning ("acquire_source_image failed: %s [%d]\n",
-		       cairo_status_to_string (status), status);
-	    return NULL;
-	}
-	image = acquired_image;
+        stride = image->stride;
+        data = image->data;
     }
 
-    format = get_cogl_format_from_cairo_format (image->format);
-    if (!format)
-    {
-	image_clone = _cairo_image_surface_coerce (image);
-	if (unlikely (image_clone->base.status)) {
-	    g_warning ("image_surface_coerce failed");
-	    texture = NULL;
-	    goto BAIL;
-	}
+    bitmap = cogl_bitmap_new_for_data (dev->cogl_context,
+                                       image->width,
+                                       image->height,
+                                       format, /* incoming */
+                                       stride,
+                                       data);
+
+    if (!dev->has_npots)
+        texture =
+            cogl_texture_2d_sliced_new_from_bitmap (bitmap,
+                                                    COGL_TEXTURE_MAX_WASTE);
+    else
+        texture = cogl_texture_2d_new_from_bitmap (bitmap);
+
+    /* The texture will have taken a reference on the bitmap */
+    cogl_object_unref (bitmap);
+
+    cogl_texture_set_components (texture,
+        get_components_from_cairo_format (image->format));
+
+    if (unlikely (!cogl_texture_allocate (texture, &error))) {
+        g_warning ("Failed to allocate texture: %s", error->message);
+        cogl_error_free (error);
+        goto BAIL;
+    }
 
-	format = get_cogl_format_from_cairo_format (image_clone->format);
-	assert (format);
-    }
-
-    texture = cogl_texture_2d_new_from_data (to_device(reference_surface->base.device)->cogl_context,
-					     image->width,
-					     image->height,
-					     format, /* incoming */
-					     format, /* desired */
-					     image->stride,
-					     image->data,
-					     &error);
-    if (!texture) {
-	g_warning ("Failed to allocate texture: %s", error->message);
-	g_error_free (error);
-	goto BAIL;
+    if (need_mirrored_texture) {
+        int new_width = image->width;
+        int new_height = image->height;
+
+        /* If the device does not support npot textures, scale to the
+         * next power of two as well */
+        if (!dev->has_npots) {
+            new_width = (int)pow (2, ceil (log2 (new_width)));
+            new_height = (int)pow (2, ceil (log2 (new_height)));
+        }
+
+        texture = _cairo_cogl_scale_texture (dev->cogl_context,
+                                             texture,
+                                             new_width,
+                                             new_height,
+                                             TRUE,
+                                             FALSE);
+        if (unlikely (!texture))
+            goto BAIL;
+
+        *is_mirrored_texture = TRUE;
+    } else if (!dev->has_npots) {
+        /* We need to scale the texture up if the hardware does not
+         * support npots */
+
+        /* Get dimensions for the next power of two */
+        int new_width = (int)pow (2, ceil (log2 (image->width)));
+        int new_height = (int)pow (2, ceil (log2 (image->height)));
+
+        texture = _cairo_cogl_scale_texture (dev->cogl_context,
+                                             texture,
+                                             new_width,
+                                             new_height,
+                                             FALSE,
+                                             FALSE);
+        if (unlikely (!texture))
+            goto BAIL;
+    }
+
+    clone =
+        _cairo_cogl_surface_create_full (dev,
+                                         reference_surface->base.content,
+                                         NULL,
+                                         texture);
+    if (unlikely (clone->status)) {
+        g_warning ("Unable to create clone surface for texture");
+        goto BAIL;
     }
 
-    clone = _cairo_cogl_surface_create_full (to_device(reference_surface->base.device),
-					     reference_surface->ignore_alpha,
-					     NULL, COGL_TEXTURE (texture));
+    if (*is_mirrored_texture)
+        ((cairo_cogl_surface_t *)clone)->is_mirrored_snapshot = TRUE;
 
-    _cairo_surface_attach_snapshot (abstract_surface, clone, NULL);
+    if (_cairo_surface_is_subsurface (surface))
+        _cairo_surface_subsurface_set_snapshot (surface, clone);
+    else
+        _cairo_surface_attach_snapshot (surface, clone, NULL);
 
     /* Attaching the snapshot will take a reference on the clone surface... */
     cairo_surface_destroy (clone);
+    clone = NULL;
+
+    /* Convert from un-normalized source coordinates in backend
+     * coordinates to normalized texture coordinates. */
+    if (*is_mirrored_texture) {
+        xscale = 0.5 / image->width;
+        yscale = 0.5 / image->height;
+    } else {
+        xscale = 1.0 / image->width;
+        yscale = 1.0 / image->height;
+    }
+    _cairo_cogl_matrix_all_scale (out_matrix, xscale, yscale);
+
+    /* Release intermediate surface representations */
+    if (image_clone) {
+	cairo_surface_destroy (&image_clone->base);
+        image_clone = NULL;
+    }
+    if (acquired_image) {
+	_cairo_surface_release_source_image (surface,
+                                             acquired_image,
+                                             image_extra);
+        acquired_image = NULL;
+    }
+
+    return texture;
 
 BAIL:
+    if (clone)
+        cairo_surface_destroy (clone);
     if (image_clone)
 	cairo_surface_destroy (&image_clone->base);
     if (acquired_image)
-	_cairo_surface_release_source_image (abstract_surface, acquired_image, image_extra);
+	_cairo_surface_release_source_image (surface,
+                                             acquired_image,
+                                             image_extra);
+    if (texture)
+        cogl_object_unref (texture);
 
-    return COGL_TEXTURE (texture);
+    return NULL;
+}
+
+static cairo_status_t
+_cairo_cogl_create_tex_clip (cairo_path_fixed_t *tex_clip,
+                             cairo_matrix_t      inverse,
+                             cairo_bool_t        is_mirrored_texture)
+{
+    cairo_status_t status;
+
+    status = cairo_matrix_invert (&inverse);
+    if (unlikely (status))
+        return status;
+
+    if (is_mirrored_texture)
+        status =
+            _cairo_cogl_path_fixed_rectangle (tex_clip, 0, 0,
+                                              _cairo_fixed_from_double (0.5),
+                                              _cairo_fixed_from_double (0.5));
+    else
+        status = _cairo_cogl_path_fixed_rectangle (tex_clip, 0, 0,
+                                                   CAIRO_FIXED_ONE,
+                                                   CAIRO_FIXED_ONE);
+    if (unlikely (status))
+	return status;
+
+    _cairo_path_fixed_transform (tex_clip, &inverse);
+
+    return CAIRO_STATUS_SUCCESS;
 }
 
 /* NB: a reference for the texture is transferred to the caller which should
  * be unrefed */
 static CoglTexture *
-_cairo_cogl_acquire_pattern_texture (const cairo_pattern_t *pattern,
-				     cairo_cogl_surface_t *destination,
-				     const cairo_rectangle_int_t *extents,
-				     const cairo_rectangle_int_t *sample,
-				     cairo_cogl_texture_attributes_t *attributes)
+_cairo_cogl_acquire_pattern_texture (const cairo_pattern_t           *pattern,
+				     cairo_cogl_surface_t            *destination,
+				     const cairo_rectangle_int_t     *extents,
+				     cairo_cogl_texture_attributes_t *attributes,
+                                     cairo_path_fixed_t              *tex_clip)
 {
     CoglTexture *texture = NULL;
+    cairo_cogl_device_t *dev = to_device (destination->base.device);
+    cairo_bool_t is_mirrored_texture;
+    cairo_bool_t need_mirrored_texture =
+        (pattern->extend == CAIRO_EXTEND_REFLECT &&
+         !dev->has_mirrored_repeat);
 
     switch ((int)pattern->type)
     {
     case CAIRO_PATTERN_TYPE_SURFACE: {
-	cairo_surface_t *surface = ((cairo_surface_pattern_t *)pattern)->surface;
-	texture = _cairo_cogl_acquire_surface_texture (destination, surface);
-	if (!texture)
-	    return NULL;
-
-	/* XXX: determine if it would have no effect to change the
-	 * extend mode to EXTEND_PAD instead since we can simply map
-	 * EXTEND_PAD to CLAMP_TO_EDGE without needing fragment shader
-	 * tricks or extra border texels. */
-#if 0
-	/* TODO: We still need to consider HW such as SGX which doesn't have
-	 * full support for NPOT textures. */
-	if (pattern->extend == CAIRO_EXTEND_REPEAT || pattern->extend == CAIRO_EXTEND_REFLECT) {
-	    _cairo_cogl_get_pot_texture ();
-	}
-#endif
-
-	cairo_matrix_init_identity (&attributes->matrix);
+        cairo_cogl_surface_t *clone;
+        cairo_surface_t *surface = ((cairo_surface_pattern_t *)pattern)->surface;
+
+        clone = (cairo_cogl_surface_t *)
+            _cairo_surface_has_snapshot (surface,
+                                         &_cairo_cogl_surface_backend);
+        if (clone && clone->texture)
+            if ((!need_mirrored_texture) || clone->is_mirrored_snapshot)
+            {
+                texture = cogl_object_ref (clone->texture);
+                attributes->matrix = pattern->matrix;
+                is_mirrored_texture = clone->is_mirrored_snapshot;
+
+                /* Convert from un-normalized source coordinates in
+                 * backend coordinates to normalized texture
+                 * coordinates. */
+                _cairo_cogl_matrix_all_scale (&attributes->matrix,
+                                              1.0 / clone->width,
+                                              1.0 / clone->height);
+            };
+
+        if (!texture) {
+            cairo_rectangle_int_t surface_extents;
+            cairo_surface_t *unwrapped =
+                _cairo_surface_get_source (surface, &surface_extents);
+
+            if (_cairo_surface_is_recording (surface)) {
+                texture =
+                    _cairo_cogl_acquire_recording_surface_texture (destination,
+                                                                   surface,
+                                                                   extents,
+                                                                   &pattern->matrix,
+                                                                   &attributes->matrix,
+                                                                   need_mirrored_texture,
+                                                                   &is_mirrored_texture);
+            } else if (surface->type == CAIRO_SURFACE_TYPE_COGL &&
+                       ((cairo_cogl_surface_t *)unwrapped)->texture) {
+                texture =
+                    _cairo_cogl_acquire_cogl_surface_texture (destination,
+                                                              unwrapped,
+                                                              &surface_extents,
+                                                              &pattern->matrix,
+                                                              &attributes->matrix,
+                                                              need_mirrored_texture,
+                                                              &is_mirrored_texture);
+            }
+        }
 
-	/* Convert from un-normalized source coordinates in backend
-	 * coordinates to normalized texture coordinates */
-	cairo_matrix_scale (&attributes->matrix,
-			    1.0f / cogl_texture_get_width (texture),
-			    1.0f / cogl_texture_get_height (texture));
+        if (!texture)
+            texture =
+                _cairo_cogl_acquire_generic_surface_texture (destination,
+                                                             surface,
+                                                             &pattern->matrix,
+                                                             &attributes->matrix,
+                                                             need_mirrored_texture,
+                                                             &is_mirrored_texture);
 
-	/* XXX: need to multiply in the pattern->matrix */
+        if (unlikely (!texture))
+            return NULL;
 
 	attributes->extend = pattern->extend;
-	attributes->filter = CAIRO_FILTER_BILINEAR;
+	attributes->filter =
+            get_cogl_filter_for_filter (pattern->filter);
 	attributes->has_component_alpha = pattern->has_component_alpha;
 
-	attributes->s_wrap = get_cogl_wrap_mode_for_extend (pattern->extend);
+	attributes->s_wrap =
+            get_cogl_wrap_mode_for_extend (pattern->extend, dev);
 	attributes->t_wrap = attributes->s_wrap;
 
+        /* In order to support CAIRO_EXTEND_NONE, we use the same wrap
+         * mode as CAIRO_EXTEND_PAD, but pass a clip to the drawing
+         * function to make sure that we never sample anything beyond
+         * the texture boundaries. */
+        if (pattern->extend == CAIRO_EXTEND_NONE && tex_clip)
+            if (_cairo_cogl_create_tex_clip (tex_clip,
+                                             attributes->matrix,
+                                             is_mirrored_texture))
+            {
+                cogl_object_unref (texture);
+                return NULL;
+            }
+
 	return texture;
     }
     case CAIRO_PATTERN_TYPE_RADIAL:
-    case CAIRO_PATTERN_TYPE_MESH: {
+    case CAIRO_PATTERN_TYPE_MESH:
+    case CAIRO_PATTERN_TYPE_RASTER_SOURCE: {
 	cairo_surface_t *surface;
-	cairo_matrix_t texture_matrix;
+        cairo_matrix_t new_pattern_matrix;
 
 	surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32,
 					      extents->width, extents->height);
@@ -1482,29 +2627,41 @@ _cairo_cogl_acquire_pattern_texture (const cairo_pattern_t *pattern,
 	    return NULL;
 	}
 
-	texture = _cairo_cogl_acquire_surface_texture (destination, surface);
-	if (!texture)
+        cairo_matrix_init_translate (&new_pattern_matrix,
+                                     -extents->x, -extents->y);
+
+	texture =
+            _cairo_cogl_acquire_generic_surface_texture (destination,
+                                                         surface,
+                                                         &new_pattern_matrix,
+                                                         &attributes->matrix,
+                                                         need_mirrored_texture,
+                                                         &is_mirrored_texture);
+	if (unlikely (!texture))
 	    goto BAIL;
 
-	cairo_matrix_init_identity (&texture_matrix);
-
-	/* Convert from un-normalized source coordinates in backend
-	 * coordinates to normalized texture coordinates */
-	cairo_matrix_scale (&texture_matrix,
-			    1.0f / cogl_texture_get_width (texture),
-			    1.0f / cogl_texture_get_height (texture));
-
-	cairo_matrix_translate (&texture_matrix, -extents->x, -extents->y);
-
-	attributes->matrix = texture_matrix;
 	attributes->extend = pattern->extend;
-	attributes->filter = CAIRO_FILTER_NEAREST;
+	attributes->filter = COGL_PIPELINE_FILTER_NEAREST;
 	attributes->has_component_alpha = pattern->has_component_alpha;
 
 	/* any pattern extend modes have already been dealt with... */
 	attributes->s_wrap = COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE;
 	attributes->t_wrap = attributes->s_wrap;
 
+        /* In order to support CAIRO_EXTEND_NONE, we use the same wrap
+         * mode as CAIRO_EXTEND_PAD, but pass a clip to the drawing
+         * function to make sure that we never sample anything beyond
+         * the texture boundaries. */
+        if (pattern->extend == CAIRO_EXTEND_NONE && tex_clip)
+            if (_cairo_cogl_create_tex_clip (tex_clip,
+                                             attributes->matrix,
+                                             is_mirrored_texture))
+            {
+                cogl_object_unref (texture);
+                cairo_surface_destroy (surface);
+                return NULL;
+            }
+
 BAIL:
 	cairo_surface_destroy (surface);
 
@@ -1515,74 +2672,295 @@ BAIL:
 	cairo_cogl_linear_gradient_t *gradient;
 	cairo_cogl_linear_texture_entry_t *linear_texture;
 	cairo_int_status_t status;
-	float a, b;
-	float dist;
-	float scale;
-	float angle;
+        double dist, scale;
+
+	status = _cairo_cogl_get_linear_gradient (to_device(destination->base.device),
+						  pattern->extend,
+						  linear_pattern->base.n_stops,
+						  linear_pattern->base.stops,
+                                                  need_mirrored_texture,
+						  &gradient);
+	if (unlikely (status))
+	    return NULL;
+
+	linear_texture = _cairo_cogl_linear_gradient_texture_for_extend (gradient, pattern->extend);
+
+	attributes->extend = pattern->extend;
+	attributes->filter =
+            get_cogl_filter_for_filter (pattern->filter);
+	attributes->has_component_alpha = pattern->has_component_alpha;
+	attributes->s_wrap =
+            get_cogl_wrap_mode_for_extend (pattern->extend, dev);
+	attributes->t_wrap = attributes->s_wrap;
+
+        attributes->matrix = pattern->matrix;
+
+	double a = linear_pattern->pd2.x - linear_pattern->pd1.x;
+	double b = linear_pattern->pd2.y - linear_pattern->pd1.y;
+	double angle = - atan2f (b, a);
+
+	cairo_matrix_rotate (&attributes->matrix, angle);
+
+	cairo_matrix_translate (&attributes->matrix,
+				-linear_pattern->pd1.x,
+				-linear_pattern->pd1.y);
+
+	/* Convert from un-normalized source coordinates in backend
+	 * coordinates to normalized texture coordinates. */
+	dist = sqrtf (a*a + b*b);
+        if (need_mirrored_texture)
+            scale = 0.5 / dist;
+        else
+	    scale = 1.0 / dist;
+        _cairo_cogl_matrix_all_scale (&attributes->matrix,
+                                      scale, scale);
+
+	return cogl_object_ref (linear_texture->texture);
+    }
+    default:
+	g_warning ("Unsupported source type");
+	return NULL;
+    }
+}
+
+static cairo_bool_t
+set_blend (CoglPipeline *pipeline, const char *blend_string)
+{
+    CoglError *error = NULL;
+    if (unlikely (!cogl_pipeline_set_blend (pipeline,
+                                            blend_string,
+                                            &error)))
+    {
+	g_warning ("Unsupported blend string with current gpu/driver: %s", blend_string);
+	cogl_error_free (error);
+	return FALSE;
+    }
+    return TRUE;
+}
 
-	status = _cairo_cogl_get_linear_gradient (to_device(destination->base.device),
-						  pattern->extend,
-						  linear_pattern->base.n_stops,
-						  linear_pattern->base.stops,
-						  &gradient);
-	if (unlikely (status))
-	    return NULL;
+static cairo_bool_t
+_cairo_cogl_setup_op_state (CoglPipeline    *pipeline,
+                            cairo_operator_t op)
+{
+    cairo_bool_t status = FALSE;
 
-	linear_texture = _cairo_cogl_linear_gradient_texture_for_extend (gradient, pattern->extend);
+    switch ((int)op)
+    {
+    case CAIRO_OPERATOR_OVER:
+	status = set_blend (pipeline, "RGBA = ADD (SRC_COLOR, DST_COLOR * (1 - SRC_COLOR[A]))");
+	break;
+    case CAIRO_OPERATOR_IN:
+	status = set_blend (pipeline, "RGBA = ADD (SRC_COLOR * DST_COLOR[A], 0)");
+	break;
+    case CAIRO_OPERATOR_OUT:
+        status = set_blend (pipeline, "RGBA = ADD (SRC_COLOR * (1 - DST_COLOR[A]), 0)");
+        break;
+    case CAIRO_OPERATOR_ATOP:
+        status = set_blend (pipeline, "RGBA = ADD (SRC_COLOR * DST_COLOR[A], DST_COLOR * (1 - SRC_COLOR[A]))");
+        break;
+    case CAIRO_OPERATOR_DEST:
+        status = set_blend (pipeline, "RGBA = ADD (0, DST_COLOR)");
+        break;
+    case CAIRO_OPERATOR_DEST_OVER:
+	status = set_blend (pipeline, "RGBA = ADD (SRC_COLOR * (1 - DST_COLOR[A]), DST_COLOR)");
+	break;
+    case CAIRO_OPERATOR_DEST_IN:
+	status = set_blend (pipeline, "RGBA = ADD (0, DST_COLOR * SRC_COLOR[A])");
+	break;
+    case CAIRO_OPERATOR_DEST_OUT:
+        status = set_blend (pipeline, "RGBA = ADD (0, DST_COLOR * (1 - SRC_COLOR[A]))");
+        break;
+    case CAIRO_OPERATOR_DEST_ATOP:
+        status = set_blend (pipeline, "RGBA = ADD (SRC_COLOR * (1 - DST_COLOR[A]), DST_COLOR * SRC_COLOR[A])");
+        break;
+    case CAIRO_OPERATOR_XOR:
+        status = set_blend (pipeline, "RGBA = ADD (SRC_COLOR * (1 - DST_COLOR[A]), DST_COLOR * (1 - SRC_COLOR[A]))");
+        break;
+    /* In order to handle SOURCE with a mask, we use two passes. The
+     * first consists of a CAIRO_OPERATOR_DEST_OUT with the source alpha
+     * replaced by the mask alpha in order to multiply all the
+     * destination values by one minus the mask alpha. The second pass
+     * (this one) then adds the source values, which have already been
+     * premultiplied by the mask alpha. */
+    case CAIRO_OPERATOR_SOURCE:
+    case CAIRO_OPERATOR_ADD:
+	status = set_blend (pipeline, "RGBA = ADD (SRC_COLOR, DST_COLOR)");
+	break;
+    case CAIRO_OPERATOR_CLEAR:
+        /* Runtime check */
+        /* CAIRO_OPERATOR_CLEAR is not supposed to use its own pipeline
+         * type. Use CAIRO_OPERATOR_DEST_OUT with the mask alpha as
+         * source alpha instead. */
+        assert (0);
+    default:
+        g_warning ("Unsupported blend operator");
+        assert (0);
+    }
 
-	attributes->extend = pattern->extend;
-	attributes->filter = CAIRO_FILTER_BILINEAR;
-	attributes->has_component_alpha = pattern->has_component_alpha;
-	attributes->s_wrap = get_cogl_wrap_mode_for_extend (pattern->extend);
-	attributes->t_wrap = COGL_PIPELINE_WRAP_MODE_REPEAT;
+    return status;
+}
 
-	cairo_matrix_init_identity (&attributes->matrix);
+static void
+create_template_for_op_type (cairo_cogl_device_t      *dev,
+                              cairo_operator_t         op,
+                              cairo_cogl_template_type type)
+{
+    CoglPipeline *pipeline;
+    CoglColor color;
 
-	a = linear_pattern->pd2.x - linear_pattern->pd1.x;
-	b = linear_pattern->pd2.y - linear_pattern->pd1.y;
-	dist = sqrtf (a*a + b*b);
-	scale = 1.0f / dist;
-	angle = - atan2f (b, a);
+    if (dev->template_pipelines[op][type])
+        return;
 
-	cairo_matrix_rotate (&attributes->matrix, angle);
-	cairo_matrix_scale (&attributes->matrix, scale, scale);
+    cogl_color_init_from_4f (&color, 1.0f, 1.0f, 1.0f, 1.0f);
 
-	cairo_matrix_translate (&attributes->matrix,
-				-linear_pattern->pd1.x,
-				-linear_pattern->pd1.y);
+    if (!dev->template_pipelines[op][CAIRO_COGL_TEMPLATE_TYPE_SOLID]) {
+        CoglPipeline *base = cogl_pipeline_new (dev->cogl_context);
 
-	/* XXX: this caught me out: cairo doesn't follow the standard
-	 * maths convention for multiplying two matrices A x B - cairo
-	 * does B x A so the final matrix is as if A's transforms were
-	 * applied first.
-	 */
-	cairo_matrix_multiply (&attributes->matrix,
-			       &pattern->matrix,
-			       &attributes->matrix);
+        if (!_cairo_cogl_setup_op_state (base, op)) {
+            cogl_object_unref (base);
+            return;
+        }
 
-	return cogl_object_ref (linear_texture->texture);
+        dev->template_pipelines[op][CAIRO_COGL_TEMPLATE_TYPE_SOLID] = base;
     }
+
+    switch ((int)type)
+    {
+    case CAIRO_COGL_TEMPLATE_TYPE_SOLID:
+        return;
+    case CAIRO_COGL_TEMPLATE_TYPE_SOLID_MASK_SOLID:
+        pipeline =
+            cogl_pipeline_copy (dev->template_pipelines[op][CAIRO_COGL_TEMPLATE_TYPE_SOLID]);
+        cogl_pipeline_set_layer_combine_constant (pipeline, 0, &color);
+        cogl_pipeline_set_layer_combine (pipeline, 0,
+                                         "RGBA = MODULATE (PRIMARY, CONSTANT[A])",
+                                         NULL);
+        break;
+    case CAIRO_COGL_TEMPLATE_TYPE_TEXTURE_MASK_SOLID:
+        pipeline =
+            cogl_pipeline_copy (dev->template_pipelines[op][CAIRO_COGL_TEMPLATE_TYPE_SOLID]);
+        cogl_pipeline_set_layer_null_texture (pipeline, 0,
+                                              COGL_TEXTURE_TYPE_2D);
+        cogl_pipeline_set_layer_combine (pipeline, 0,
+                                         "RGBA = MODULATE (PRIMARY, TEXTURE[A])",
+                                         NULL);
+        break;
+    case CAIRO_COGL_TEMPLATE_TYPE_TEXTURE:
+        pipeline =
+            cogl_pipeline_copy (dev->template_pipelines[op][CAIRO_COGL_TEMPLATE_TYPE_SOLID]);
+        cogl_pipeline_set_layer_null_texture (pipeline, 0,
+                                              COGL_TEXTURE_TYPE_2D);
+        break;
+    case CAIRO_COGL_TEMPLATE_TYPE_SOLID_MASK_TEXTURE:
+        pipeline =
+            cogl_pipeline_copy (dev->template_pipelines[op][CAIRO_COGL_TEMPLATE_TYPE_SOLID]);
+        cogl_pipeline_set_layer_null_texture (pipeline, 0,
+                                              COGL_TEXTURE_TYPE_2D);
+        cogl_pipeline_set_layer_combine_constant (pipeline, 1, &color);
+        cogl_pipeline_set_layer_combine (pipeline, 1,
+                                         "RGBA = MODULATE (PREVIOUS, CONSTANT[A])",
+                                         NULL);
+        break;
+    case CAIRO_COGL_TEMPLATE_TYPE_TEXTURE_MASK_TEXTURE:
+        pipeline =
+            cogl_pipeline_copy (dev->template_pipelines[op][CAIRO_COGL_TEMPLATE_TYPE_SOLID]);
+        cogl_pipeline_set_layer_null_texture (pipeline, 0,
+                                              COGL_TEXTURE_TYPE_2D);
+        cogl_pipeline_set_layer_null_texture (pipeline, 1,
+                                              COGL_TEXTURE_TYPE_2D);
+        cogl_pipeline_set_layer_combine (pipeline, 1,
+                                         "RGBA = MODULATE (PREVIOUS, TEXTURE[A])",
+                                         NULL);
+        break;
+    case CAIRO_COGL_TEMPLATE_TYPE_TEXTURE_IGNORE_ALPHA:
+        pipeline =
+            cogl_pipeline_copy (dev->template_pipelines[op][CAIRO_COGL_TEMPLATE_TYPE_SOLID]);
+        cogl_pipeline_set_layer_null_texture (pipeline, 0,
+                                              COGL_TEXTURE_TYPE_2D);
+        /* We do not set the combine color when we use this template
+         * pipeline, so the source texture alpha will be replaces by
+         * ones */
+        cogl_pipeline_set_layer_combine_constant (pipeline, 0, &color);
+        cogl_pipeline_set_layer_combine (pipeline, 0,
+                                         "RGB = REPLACE (TEXTURE)"
+                                         "A = REPLACE (CONSTANT)",
+                                         NULL);
+        break;
+    case CAIRO_COGL_TEMPLATE_TYPE_SOLID_MASK_TEXTURE_IGNORE_ALPHA:
+        pipeline =
+            cogl_pipeline_copy (dev->template_pipelines[op][CAIRO_COGL_TEMPLATE_TYPE_SOLID]);
+        cogl_pipeline_set_layer_null_texture (pipeline, 0,
+                                              COGL_TEXTURE_TYPE_2D);
+        /* We do not set the combine color when we use this template
+         * pipeline, so the source texture alpha will be replaces by
+         * ones */
+        cogl_pipeline_set_layer_combine_constant (pipeline, 0, &color);
+        cogl_pipeline_set_layer_combine (pipeline, 0,
+                                         "RGB = REPLACE (TEXTURE)"
+                                         "A = REPLACE (CONSTANT)",
+                                         NULL);
+        cogl_pipeline_set_layer_combine_constant (pipeline, 1, &color);
+        cogl_pipeline_set_layer_combine (pipeline, 1,
+                                         "RGBA = MODULATE (PREVIOUS, CONSTANT[A])",
+                                         NULL);
+        break;
+    case CAIRO_COGL_TEMPLATE_TYPE_TEXTURE_MASK_TEXTURE_IGNORE_ALPHA:
+        pipeline =
+            cogl_pipeline_copy (dev->template_pipelines[op][CAIRO_COGL_TEMPLATE_TYPE_SOLID]);
+        cogl_pipeline_set_layer_null_texture (pipeline, 0,
+                                              COGL_TEXTURE_TYPE_2D);
+        /* We do not set the combine color when we use this template
+         * pipeline, so the source texture alpha will be replaces by
+         * ones */
+        cogl_pipeline_set_layer_combine_constant (pipeline, 0, &color);
+        cogl_pipeline_set_layer_combine (pipeline, 0,
+                                         "RGB = REPLACE (TEXTURE)"
+                                         "A = REPLACE (CONSTANT)",
+                                         NULL);
+        cogl_pipeline_set_layer_null_texture (pipeline, 1,
+                                              COGL_TEXTURE_TYPE_2D);
+        cogl_pipeline_set_layer_combine (pipeline, 1,
+                                         "RGBA = MODULATE (PREVIOUS, TEXTURE[A])",
+                                         NULL);
+        break;
     default:
-	g_warning ("Un-supported source type");
-	return NULL;
+        g_warning ("Invalid cogl pipeline template type");
+        return;
     }
+
+    dev->template_pipelines[op][type] = pipeline;
 }
 
 static void
-set_layer_texture_with_attributes (CoglPipeline *pipeline,
-				   int layer_index,
-				   CoglTexture *texture,
-				   cairo_cogl_texture_attributes_t *attributes)
+set_layer_texture_with_attributes (CoglPipeline                    *pipeline,
+				   int                              layer_index,
+				   CoglTexture                     *texture,
+				   cairo_cogl_texture_attributes_t *attributes,
+                                   cairo_matrix_t                  *path_transform)
 {
+    cairo_matrix_t m;
+
     cogl_pipeline_set_layer_texture (pipeline, layer_index, texture);
 
-    if (!_cairo_matrix_is_identity (&attributes->matrix)) {
-	cairo_matrix_t *m = &attributes->matrix;
+    cogl_pipeline_set_layer_filters (pipeline,
+                                     layer_index,
+                                     attributes->filter,
+                                     attributes->filter);
+
+    /* We multiply in the path transform here so that we read texture
+     * values from coordinates that are consistent with the coordinates
+     * of the path after it is transformed by the modelview matrix */
+    if (path_transform)
+        cairo_matrix_multiply (&m, path_transform, &attributes->matrix);
+    else
+        m = attributes->matrix;
+
+    if (!_cairo_matrix_is_identity (&m)) {
 	float texture_matrixfv[16] = {
-	    m->xx, m->yx, 0, 0,
-	    m->xy, m->yy, 0, 0,
-	    0, 0, 1, 0,
-	    m->x0, m->y0, 0, 1
+	    m.xx, m.yx, 0, 0,
+	    m.xy, m.yy, 0, 0,
+	    0,    0,    1, 0,
+	    m.x0, m.y0, 0, 1
 	};
 	CoglMatrix texture_matrix;
 	cogl_matrix_init_from_array (&texture_matrix, texture_matrixfv);
@@ -1592,58 +2970,188 @@ set_layer_texture_with_attributes (CoglPipeline *pipeline,
     if (attributes->s_wrap != attributes->t_wrap) {
 	cogl_pipeline_set_layer_wrap_mode_s (pipeline, layer_index, attributes->s_wrap);
 	cogl_pipeline_set_layer_wrap_mode_t (pipeline, layer_index, attributes->t_wrap);
-    } else
+    } else {
 	cogl_pipeline_set_layer_wrap_mode (pipeline, layer_index, attributes->s_wrap);
+    }
 }
 
-static CoglPipeline *
-get_source_mask_operator_destination_pipeline (const cairo_pattern_t *mask,
-					       const cairo_pattern_t *source,
-					       cairo_operator_t op,
-					       cairo_cogl_surface_t *destination,
-					       cairo_composite_rectangles_t *extents)
+/* This takes an argument of a pointer to an array of two pointers to
+ * #cairo_cogl_pipeline_t. On failure, both pointers will be set to
+ * NULL */
+static void
+get_source_mask_operator_destination_pipelines (cairo_cogl_pipeline_t       **pipelines,
+                                                const cairo_pattern_t        *mask,
+					        const cairo_pattern_t        *source,
+					        cairo_operator_t              op,
+					        cairo_cogl_surface_t         *destination,
+					        cairo_composite_rectangles_t *extents,
+                                                cairo_matrix_t               *path_transform)
 {
     cairo_cogl_template_type template_type;
-    CoglPipeline *pipeline;
+    cairo_cogl_device_t *dev = to_device(destination->base.device);
+
+    pipelines[0] = NULL;
+    pipelines[1] = NULL;
 
     switch ((int)source->type)
     {
     case CAIRO_PATTERN_TYPE_SOLID:
-	template_type = mask ?
-	    CAIRO_COGL_TEMPLATE_TYPE_MASK_SOLID : CAIRO_COGL_TEMPLATE_TYPE_SOLID;
-	break;
+        if (mask) {
+            /* If the mask surface has no alpha content, we use a mask
+             * of solid ones */
+            if ((mask->type == CAIRO_PATTERN_TYPE_SOLID) ||
+                (mask->type == CAIRO_PATTERN_TYPE_SURFACE &&
+                 ((cairo_surface_pattern_t *)mask)->surface->content == CAIRO_CONTENT_COLOR))
+                template_type =
+                    CAIRO_COGL_TEMPLATE_TYPE_SOLID_MASK_SOLID;
+            else
+                template_type =
+                    CAIRO_COGL_TEMPLATE_TYPE_TEXTURE_MASK_SOLID;
+        } else {
+            template_type = CAIRO_COGL_TEMPLATE_TYPE_SOLID;
+        }
+        break;
     case CAIRO_PATTERN_TYPE_SURFACE:
+        /* If the source does not have alpha content, we have to use
+         * a specialized set of texture combining functions in order to
+         * ensure that if we have a CAIRO_FORMAT_RGB24 source, we are
+         * ignoring the alpha and replacing it with ones. Otherwise, we
+         * use the template types for any other type of non-solid
+         * source. */
+        if (((cairo_surface_pattern_t *)source)->surface->content ==
+             CAIRO_CONTENT_COLOR)
+        {
+            if (mask) {
+                /* If the mask surface has no alpha content, we use a
+                 * mask of solid ones */
+                if ((mask->type == CAIRO_PATTERN_TYPE_SOLID) ||
+                    (mask->type == CAIRO_PATTERN_TYPE_SURFACE &&
+                     ((cairo_surface_pattern_t *)mask)->surface->content == CAIRO_CONTENT_COLOR))
+                    template_type =
+                        CAIRO_COGL_TEMPLATE_TYPE_SOLID_MASK_TEXTURE_IGNORE_ALPHA;
+                else
+                    template_type =
+                        CAIRO_COGL_TEMPLATE_TYPE_TEXTURE_MASK_TEXTURE_IGNORE_ALPHA;
+            } else {
+                template_type =
+                    CAIRO_COGL_TEMPLATE_TYPE_TEXTURE_IGNORE_ALPHA;
+            }
+            break;
+        }
+        // else fall through
     case CAIRO_PATTERN_TYPE_LINEAR:
     case CAIRO_PATTERN_TYPE_RADIAL:
     case CAIRO_PATTERN_TYPE_MESH:
-	template_type = mask ?
-	    CAIRO_COGL_TEMPLATE_TYPE_MASK_TEXTURE : CAIRO_COGL_TEMPLATE_TYPE_TEXTURE;
-	break;
+    case CAIRO_PATTERN_TYPE_RASTER_SOURCE:
+        if (mask) {
+            /* If the mask surface has no alpha content, we use a mask
+             * of solid ones */
+            if ((mask->type == CAIRO_PATTERN_TYPE_SOLID) ||
+                (mask->type == CAIRO_PATTERN_TYPE_SURFACE &&
+                 ((cairo_surface_pattern_t *)mask)->surface->content == CAIRO_CONTENT_COLOR))
+                template_type =
+                    CAIRO_COGL_TEMPLATE_TYPE_SOLID_MASK_TEXTURE;
+            else
+                template_type =
+                    CAIRO_COGL_TEMPLATE_TYPE_TEXTURE_MASK_TEXTURE;
+        } else {
+            template_type = CAIRO_COGL_TEMPLATE_TYPE_TEXTURE;
+        }
+        break;
     default:
-	g_warning ("Un-supported source type");
-	return NULL;
+	g_warning ("Unsupported source type");
+	return;
     }
 
-    pipeline = cogl_pipeline_copy (to_device(destination->base.device)->template_pipelines[op][template_type]);
+    /* pipelines[0] is for pre-rendering the mask alpha in the case
+     * that it cannot be represented through the source color alpha
+     * value. For more details, go to the description in
+     * _cairo_cogl_setup_op_state */
+    if (op == CAIRO_OPERATOR_CLEAR || op == CAIRO_OPERATOR_SOURCE) {
+        cairo_cogl_template_type prerender_type;
+
+        pipelines[0] = g_new (cairo_cogl_pipeline_t, 1);
+
+        if (mask && mask->type != CAIRO_PATTERN_TYPE_SOLID)
+            prerender_type = CAIRO_COGL_TEMPLATE_TYPE_SOLID;
+        else
+            prerender_type = CAIRO_COGL_TEMPLATE_TYPE_TEXTURE;
+
+        /* Lazily create pipeline templates */
+        if (unlikely (dev->template_pipelines[CAIRO_OPERATOR_DEST_OUT][prerender_type] == NULL))
+            create_template_for_op_type (dev,
+                                         CAIRO_OPERATOR_DEST_OUT,
+                                         prerender_type);
+
+        pipelines[0]->pipeline =
+            cogl_pipeline_copy (dev->template_pipelines[CAIRO_OPERATOR_DEST_OUT][prerender_type]);
+
+        pipelines[0]->mask_bounded =
+            _cairo_operator_bounded_by_mask (op);
+        pipelines[0]->src_bounded =
+            _cairo_operator_bounded_by_source (op);
+        pipelines[0]->op = CAIRO_OPERATOR_DEST_OUT;
+        pipelines[0]->n_layers = 0;
+        pipelines[0]->has_src_tex_clip = FALSE;
+        pipelines[0]->has_mask_tex_clip = FALSE;
+        pipelines[0]->unbounded_extents = extents->unbounded;
+    }
 
-    if (source->type == CAIRO_PATTERN_TYPE_SOLID) {
-	cairo_solid_pattern_t *solid_pattern = (cairo_solid_pattern_t *)source;
-	cogl_pipeline_set_color4f (pipeline,
-				   solid_pattern->color.red * solid_pattern->color.alpha,
-				   solid_pattern->color.green * solid_pattern->color.alpha,
-				   solid_pattern->color.blue * solid_pattern->color.alpha,
-				   solid_pattern->color.alpha);
-    } else {
-	cairo_cogl_texture_attributes_t attributes;
-	CoglTexture *texture =
-	    _cairo_cogl_acquire_pattern_texture (source, destination,
-						 &extents->bounded,
-						 &extents->source_sample_area,
-						 &attributes);
-	if (!texture)
-	    goto BAIL;
-	set_layer_texture_with_attributes (pipeline, 0, texture, &attributes);
-	cogl_object_unref (texture);
+    /* pipelines[1] is for normal rendering, modulating the mask with
+     * the source. Most operators will only need this pipeline. */
+    if (op != CAIRO_OPERATOR_CLEAR) {
+        pipelines[1] = g_new (cairo_cogl_pipeline_t, 1);
+
+        /* Lazily create pipeline templates */
+        if (unlikely (dev->template_pipelines[op][template_type] == NULL))
+            create_template_for_op_type (dev, op, template_type);
+
+        pipelines[1]->pipeline =
+            cogl_pipeline_copy (dev->template_pipelines[op][template_type]);
+
+        pipelines[1]->mask_bounded =
+            _cairo_operator_bounded_by_mask (op);
+        pipelines[1]->src_bounded =
+            _cairo_operator_bounded_by_source (op);
+        pipelines[1]->op = op;
+        pipelines[1]->n_layers = 0;
+        pipelines[1]->has_src_tex_clip = FALSE;
+        pipelines[1]->has_mask_tex_clip = FALSE;
+        pipelines[1]->unbounded_extents = extents->unbounded;
+    }
+
+    if (pipelines[1]) {
+        if (source->type == CAIRO_PATTERN_TYPE_SOLID) {
+            cairo_solid_pattern_t *solid_pattern = (cairo_solid_pattern_t *)source;
+            cogl_pipeline_set_color4f (pipelines[1]->pipeline,
+                                       solid_pattern->color.red * solid_pattern->color.alpha,
+                                       solid_pattern->color.green * solid_pattern->color.alpha,
+                                       solid_pattern->color.blue * solid_pattern->color.alpha,
+                                       solid_pattern->color.alpha);
+        } else {
+	    cairo_cogl_texture_attributes_t attributes;
+
+            _cairo_path_fixed_init (&pipelines[1]->src_tex_clip);
+
+	    CoglTexture *texture =
+	        _cairo_cogl_acquire_pattern_texture (source, destination,
+                                                     &extents->bounded,
+                                                     &attributes,
+                                                     &pipelines[1]->src_tex_clip);
+            if (unlikely (!texture))
+                goto BAIL;
+            set_layer_texture_with_attributes (pipelines[1]->pipeline,
+                                               pipelines[1]->n_layers++,
+                                               texture,
+                                               &attributes,
+                                               path_transform);
+            cogl_object_unref (texture);
+
+            if (pipelines[1]->src_tex_clip.buf.base.num_ops > 0)
+                pipelines[1]->has_src_tex_clip = TRUE;
+            else
+                _cairo_path_fixed_fini (&pipelines[1]->src_tex_clip);
+        }
     }
 
     if (mask) {
@@ -1655,40 +3163,100 @@ get_source_mask_operator_destination_pipeline (const cairo_pattern_t *mask,
 				     solid_pattern->color.green * solid_pattern->color.alpha,
 				     solid_pattern->color.blue * solid_pattern->color.alpha,
 				     solid_pattern->color.alpha);
-	    cogl_pipeline_set_layer_combine_constant (pipeline, 1, &color);
-	} else {
+            if (pipelines[1])
+	        cogl_pipeline_set_layer_combine_constant (pipelines[1]->pipeline,
+                                                          pipelines[1]->n_layers++,
+                                                          &color);
+            if (pipelines[0])
+                cogl_pipeline_set_color (pipelines[0]->pipeline,
+                                         &color);
+        /* If the only component present in our mask is a color
+         * component, skip setting the layer texture, as we already
+         * set a solid of uniform ones on it during the template
+         * creation process */
+	} else if (!(mask->type == CAIRO_PATTERN_TYPE_SURFACE &&
+                    ((cairo_surface_pattern_t *)mask)->surface->content == CAIRO_CONTENT_COLOR)) {
 	    cairo_cogl_texture_attributes_t attributes;
+            cairo_path_fixed_t mask_tex_clip;
+
+            _cairo_path_fixed_init (&mask_tex_clip);
+
 	    CoglTexture *texture =
 		_cairo_cogl_acquire_pattern_texture (mask, destination,
 						     &extents->bounded,
-						     &extents->mask_sample_area,
-						     &attributes);
-	    if (!texture)
+						     &attributes,
+                                                     &mask_tex_clip);
+	    if (unlikely (!texture))
 		goto BAIL;
-	    set_layer_texture_with_attributes (pipeline, 1, texture, &attributes);
+            if (pipelines[1]) {
+                if (mask_tex_clip.buf.base.num_ops > 0) {
+                    pipelines[1]->has_mask_tex_clip = TRUE;
+                    if (unlikely (_cairo_path_fixed_init_copy (&pipelines[1]->mask_tex_clip,
+                                                               &mask_tex_clip)))
+                        goto BAIL;
+                }
+	        set_layer_texture_with_attributes (pipelines[1]->pipeline,
+                                                   pipelines[1]->n_layers++,
+                                                   texture,
+                                                   &attributes,
+                                                   path_transform);
+            }
+            if (pipelines[0]) {
+                if (mask_tex_clip.buf.base.num_ops > 0) {
+                    pipelines[0]->has_mask_tex_clip = TRUE;
+                    if (unlikely (_cairo_path_fixed_init_copy (&pipelines[0]->mask_tex_clip,
+                                                               &mask_tex_clip)))
+                        goto BAIL;
+                }
+                set_layer_texture_with_attributes (pipelines[0]->pipeline,
+                                                   pipelines[0]->n_layers++,
+                                                   texture,
+                                                   &attributes,
+                                                   path_transform);
+            }
+
+            _cairo_path_fixed_fini (&mask_tex_clip);
 	    cogl_object_unref (texture);
 	}
     }
 
-    return pipeline;
+    return;
 
 BAIL:
-    cogl_object_unref (pipeline);
-    return NULL;
+    if (pipelines[0]) {
+        cogl_object_unref (pipelines[0]->pipeline);
+        if (pipelines[0]->has_src_tex_clip)
+            _cairo_path_fixed_fini (&pipelines[0]->src_tex_clip);
+        if (pipelines[0]->has_mask_tex_clip)
+            _cairo_path_fixed_fini (&pipelines[0]->mask_tex_clip);
+        g_free (pipelines[0]);
+        pipelines[0] = NULL;
+    }
+    if (pipelines[1]) {
+        cogl_object_unref (pipelines[1]->pipeline);
+        if (pipelines[1]->has_src_tex_clip)
+            _cairo_path_fixed_fini (&pipelines[1]->src_tex_clip);
+        if (pipelines[1]->has_mask_tex_clip)
+            _cairo_path_fixed_fini (&pipelines[1]->mask_tex_clip);
+        g_free (pipelines[1]);
+        pipelines[1] = NULL;
+    }
 }
 
 #if 0
 CoglPrimitive *
-_cairo_cogl_rectangle_new_p2t2t2 (float x,
-				  float y,
-				  float width,
-				  float height)
+_cairo_cogl_rectangle_new_p2t2t2 (CoglContext *cogl_context,
+                                  float        x,
+                                  float        y,
+                                  float        width,
+                                  float        height)
 {
     CoglVertexP2 vertices[] = {
 	{x, y}, {x, y + height}, {x + width, y + height},
 	{x, y}, {x + width, y + height}, {x + width, y}
     };
-    CoglAttributeBuffer *buffer = cogl_attribute_buffer_new (sizeof (vertices));
+    CoglAttributeBuffer *buffer = cogl_attribute_buffer_new (cogl_context,
+                                                             sizeof (vertices));
     CoglAttribute *pos = cogl_attribute_new (buffer,
 					     "cogl_position_in",
 					     sizeof (CoglVertexP2),
@@ -1709,7 +3277,7 @@ _cairo_cogl_rectangle_new_p2t2t2 (float x,
 						     COGL_ATTRIBUTE_TYPE_FLOAT);
     CoglPrimitive *prim;
 
-    cogl_buffer_set_data (COGL_BUFFER (buffer), 0, vertices, sizeof (vertices));
+    cogl_buffer_set_data (buffer, 0, vertices, sizeof (vertices));
 
     /* The attributes will now keep the buffer alive... */
     cogl_object_unref (buffer);
@@ -1726,7 +3294,7 @@ _cairo_cogl_rectangle_new_p2t2t2 (float x,
 
 static void
 _cairo_cogl_log_clip (cairo_cogl_surface_t *surface,
-		      const cairo_clip_t *clip)
+		      const cairo_clip_t   *clip)
 {
     if (!_cairo_clip_equal (clip, surface->last_clip)) {
 	_cairo_cogl_journal_log_clip (surface, clip);
@@ -1736,7 +3304,7 @@ _cairo_cogl_log_clip (cairo_cogl_surface_t *surface,
 }
 
 static void
-_cairo_cogl_maybe_log_clip (cairo_cogl_surface_t *surface,
+_cairo_cogl_maybe_log_clip (cairo_cogl_surface_t         *surface,
 			    cairo_composite_rectangles_t *composite)
 {
     cairo_clip_t *clip = composite->clip;
@@ -1757,309 +3325,169 @@ static cairo_bool_t
 is_operator_supported (cairo_operator_t op)
 {
     switch ((int)op) {
+    case CAIRO_OPERATOR_CLEAR:
     case CAIRO_OPERATOR_SOURCE:
     case CAIRO_OPERATOR_OVER:
     case CAIRO_OPERATOR_IN:
+    case CAIRO_OPERATOR_OUT:
+    case CAIRO_OPERATOR_ATOP:
+    case CAIRO_OPERATOR_DEST:
     case CAIRO_OPERATOR_DEST_OVER:
     case CAIRO_OPERATOR_DEST_IN:
+    case CAIRO_OPERATOR_DEST_OUT:
+    case CAIRO_OPERATOR_DEST_ATOP:
+    case CAIRO_OPERATOR_XOR:
     case CAIRO_OPERATOR_ADD:
 	return TRUE;
 
     default:
+        g_warning("cairo-cogl: Blend operator not supported");
 	return FALSE;
     }
 }
 
 static cairo_int_status_t
-_cairo_cogl_surface_mask (void                    *abstract_surface,
-                          cairo_operator_t         op,
-                          const cairo_pattern_t   *source,
-                          const cairo_pattern_t   *mask,
-                          const cairo_clip_t      *clip)
+_cairo_cogl_surface_paint (void                  *abstract_surface,
+                           cairo_operator_t       op,
+                           const cairo_pattern_t *source,
+                           const cairo_clip_t    *clip)
 {
-    cairo_cogl_surface_t *surface = abstract_surface;
-    cairo_composite_rectangles_t extents;
-    cairo_status_t status;
-    CoglPipeline *pipeline;
+    cairo_cogl_surface_t *surface;
+    cairo_int_status_t status;
     cairo_matrix_t identity;
+    cairo_cogl_pipeline_t *pipelines[2];
+    cairo_composite_rectangles_t extents;
 
-    /* XXX: Use this to smoke test the acquire_source/dest_image fallback
-     * paths... */
-    //return CAIRO_INT_STATUS_UNSUPPORTED;
+    if (clip == NULL) {
+        status = _cairo_cogl_surface_ensure_framebuffer (abstract_surface);
+        if (unlikely (status))
+            return status;
+
+	if (op == CAIRO_OPERATOR_CLEAR)
+            return _cairo_cogl_surface_clear (abstract_surface, CAIRO_COLOR_TRANSPARENT);
+	else if (source->type == CAIRO_PATTERN_TYPE_SOLID &&
+                (op == CAIRO_OPERATOR_SOURCE ||
+                 (op == CAIRO_OPERATOR_OVER && (((cairo_surface_t *)abstract_surface)->is_clear || _cairo_pattern_is_opaque_solid (source))))) {
+            return _cairo_cogl_surface_clear (abstract_surface,
+					      &((cairo_solid_pattern_t *) source)->color);
+        }
+    }
+
+    /* fall back to handling the paint in terms of a rectangle... */
+
+    surface = (cairo_cogl_surface_t *)abstract_surface;
 
     if (!is_operator_supported (op))
 	return CAIRO_INT_STATUS_UNSUPPORTED;
 
-    status = _cairo_composite_rectangles_init_for_mask (&extents,
-							&surface->base,
-							op, source, mask, clip);
+    status =
+        _cairo_composite_rectangles_init_for_paint (&extents,
+                                                    &surface->base,
+                                                    op,
+                                                    source,
+                                                    clip);
     if (unlikely (status))
 	return status;
 
-    pipeline = get_source_mask_operator_destination_pipeline (mask, source,
-							      op, surface, &extents);
-    if (!pipeline){
-	status = CAIRO_INT_STATUS_UNSUPPORTED;
-	goto BAIL;
+    get_source_mask_operator_destination_pipelines (pipelines,
+                                                    NULL,
+                                                    source,
+                                                    op,
+                                                    surface,
+                                                    &extents,
+                                                    NULL);
+    if (unlikely (pipelines[0] == NULL && pipelines[1] == NULL)) {
+        status = CAIRO_INT_STATUS_UNSUPPORTED;
+        goto BAIL;
     }
 
     _cairo_cogl_maybe_log_clip (surface, &extents);
 
     cairo_matrix_init_identity (&identity);
-    _cairo_cogl_journal_log_rectangle (surface, pipeline,
-				       extents.bounded.x,
-				       extents.bounded.y,
-				       extents.bounded.width,
-				       extents.bounded.height,
-				       2,
-				       &identity);
-
-    /* The journal will take a reference on the pipeline and clip_path... */
-    cogl_object_unref (pipeline);
+    if (pipelines[0])
+        _cairo_cogl_journal_log_rectangle (surface,
+                                           pipelines[0],
+                                           extents.bounded.x,
+                                           extents.bounded.y,
+                                           extents.bounded.width,
+                                           extents.bounded.height,
+                                           &identity);
+    if (pipelines[1])
+        _cairo_cogl_journal_log_rectangle (surface,
+                                           pipelines[1],
+                                           extents.bounded.x,
+                                           extents.bounded.y,
+                                           extents.bounded.width,
+                                           extents.bounded.height,
+                                           &identity);
 
 BAIL:
-    return status;
-}
-
-static int
-_cairo_cogl_source_n_layers (const cairo_pattern_t *source)
-{
-    switch ((int)source->type)
-    {
-    case CAIRO_PATTERN_TYPE_SOLID:
-	return 0;
-    case CAIRO_PATTERN_TYPE_LINEAR:
-    case CAIRO_PATTERN_TYPE_RADIAL:
-    case CAIRO_PATTERN_TYPE_MESH:
-    case CAIRO_PATTERN_TYPE_SURFACE:
-	return 1;
-    default:
-	g_warning ("Unsupported source type");
-	return 0;
-    }
-}
-
-static cairo_bool_t
-_cairo_cogl_path_fill_meta_equal (const void *key_a, const void *key_b)
-{
-    const cairo_cogl_path_fill_meta_t *meta0 = key_a;
-    const cairo_cogl_path_fill_meta_t *meta1 = key_b;
-
-    return _cairo_path_fixed_equal (meta0->user_path, meta1->user_path);
-}
-
-static cairo_bool_t
-_cairo_cogl_stroke_style_equal (const cairo_stroke_style_t *a,
-			        const cairo_stroke_style_t *b)
-{
-    if (a->line_width == b->line_width &&
-	a->line_cap == b->line_cap &&
-	a->line_join == b->line_join &&
-	a->miter_limit == b->miter_limit &&
-	a->num_dashes == b->num_dashes &&
-	a->dash_offset == b->dash_offset)
-    {
-	unsigned int i;
-	for (i = 0; i < a->num_dashes; i++) {
-	    if (a->dash[i] != b->dash[i])
-		return FALSE;
-	}
-    }
-    return TRUE;
-}
-
-static cairo_bool_t
-_cairo_cogl_path_stroke_meta_equal (const void *key_a, const void *key_b)
-{
-    const cairo_cogl_path_stroke_meta_t *meta0 = key_a;
-    const cairo_cogl_path_stroke_meta_t *meta1 = key_b;
-
-    return _cairo_cogl_stroke_style_equal (&meta0->style, &meta1->style) &&
-	_cairo_path_fixed_equal (meta0->user_path, meta1->user_path);
-}
-
-static cairo_cogl_path_stroke_meta_t *
-_cairo_cogl_path_stroke_meta_reference (cairo_cogl_path_stroke_meta_t *meta)
-{
-    assert (CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&meta->ref_count));
-
-    _cairo_reference_count_inc (&meta->ref_count);
-
-    return meta;
-}
-
-static void
-_cairo_cogl_path_stroke_meta_destroy (cairo_cogl_path_stroke_meta_t *meta)
-{
-    assert (CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&meta->ref_count));
-
-    if (! _cairo_reference_count_dec_and_test (&meta->ref_count))
-	return;
-
-    _cairo_path_fixed_fini (meta->user_path);
-    free (meta->user_path);
-
-    _cairo_stroke_style_fini (&meta->style);
-
-    if (meta->prim)
-	cogl_object_unref (meta->prim);
-
-    free (meta);
-}
-
-static cairo_cogl_path_stroke_meta_t *
-_cairo_cogl_path_stroke_meta_lookup (cairo_cogl_device_t	*ctx,
-				     unsigned long		 hash,
-				     cairo_path_fixed_t		*user_path,
-				     const cairo_stroke_style_t *style,
-				     double			 tolerance)
-{
-    cairo_cogl_path_stroke_meta_t *ret;
-    cairo_cogl_path_stroke_meta_t lookup;
-
-    lookup.cache_entry.hash = hash;
-    lookup.user_path = user_path;
-    lookup.style = *style;
-    lookup.tolerance = tolerance;
+    _cairo_composite_rectangles_fini (&extents);
 
-    ret = _cairo_cache_lookup (&ctx->path_stroke_staging_cache, &lookup.cache_entry);
-    if (!ret)
-	ret = _cairo_cache_lookup (&ctx->path_stroke_prim_cache, &lookup.cache_entry);
-    return ret;
-}
-
-static void
-_cairo_cogl_path_stroke_meta_set_prim_size (cairo_cogl_surface_t *surface,
-					    cairo_cogl_path_stroke_meta_t *meta,
-					    size_t size)
-{
-    /* now that we know the meta structure is associated with a primitive
-     * we promote it from the staging cache into the primitive cache.
-     */
-
-    /* XXX: _cairo_cache borks if you try and remove an entry that's already
-     * been evicted so we explicitly look it up first... */
-    if (_cairo_cache_lookup (&to_device(surface->base.device)->path_stroke_staging_cache, &meta->cache_entry)) {
-	_cairo_cogl_path_stroke_meta_reference (meta);
-	_cairo_cache_remove (&to_device(surface->base.device)->path_stroke_staging_cache, &meta->cache_entry);
-    }
-
-    meta->cache_entry.size = size;
-    if (_cairo_cache_insert (&to_device(surface->base.device)->path_stroke_prim_cache, &meta->cache_entry) !=
-	CAIRO_STATUS_SUCCESS)
-	_cairo_cogl_path_stroke_meta_destroy (meta);
-}
-
-static unsigned int
-_cairo_cogl_stroke_style_hash (unsigned int hash,
-			       const cairo_stroke_style_t *style)
-{
-    unsigned int i;
-    hash = _cairo_hash_bytes (hash, &style->line_width, sizeof (style->line_width));
-    hash = _cairo_hash_bytes (hash, &style->line_cap, sizeof (style->line_cap));
-    hash = _cairo_hash_bytes (hash, &style->line_join, sizeof (style->line_join));
-    hash = _cairo_hash_bytes (hash, &style->miter_limit, sizeof (style->miter_limit));
-    hash = _cairo_hash_bytes (hash, &style->num_dashes, sizeof (style->num_dashes));
-    hash = _cairo_hash_bytes (hash, &style->dash_offset, sizeof (style->dash_offset));
-    for (i = 0; i < style->num_dashes; i++)
-	hash = _cairo_hash_bytes (hash, &style->dash[i], sizeof (double));
-    return hash;
-}
-
-static cairo_cogl_path_stroke_meta_t *
-_cairo_cogl_get_path_stroke_meta (cairo_cogl_surface_t *surface,
-				  const cairo_stroke_style_t *style,
-				  double tolerance)
-{
-    unsigned long hash;
-    cairo_cogl_path_stroke_meta_t *meta = NULL;
-    cairo_path_fixed_t *meta_path = NULL;
-    cairo_status_t status;
-
-    if (!surface->user_path)
-	return NULL;
-
-    hash = _cairo_path_fixed_hash (surface->user_path);
-    hash = _cairo_cogl_stroke_style_hash (hash, style);
-    hash = _cairo_hash_bytes (hash, &tolerance, sizeof (tolerance));
-
-    meta = _cairo_cogl_path_stroke_meta_lookup (to_device(surface->base.device), hash,
-						surface->user_path, style, tolerance);
-    if (meta)
-	return meta;
-
-    meta = calloc (1, sizeof (cairo_cogl_path_stroke_meta_t));
-    if (!meta)
-	goto BAIL;
-    CAIRO_REFERENCE_COUNT_INIT (&meta->ref_count, 1);
-    meta->cache_entry.hash = hash;
-    meta->counter = 0;
-    meta_path = _cairo_malloc (sizeof (cairo_path_fixed_t));
-    if (!meta_path)
-	goto BAIL;
-    /* FIXME: we should add a ref-counted wrapper for our user_paths
-     * so we don't have to keep copying them here! */
-    status = _cairo_path_fixed_init_copy (meta_path, surface->user_path);
-    if (unlikely (status))
-	goto BAIL;
-    meta->user_path = meta_path;
-    meta->ctm_inverse = *surface->ctm_inverse;
-
-    status = _cairo_stroke_style_init_copy (&meta->style, style);
-    if (unlikely (status)) {
-	_cairo_path_fixed_fini (meta_path);
-	goto BAIL;
-    }
-    meta->tolerance = tolerance;
-
-    return meta;
-
-BAIL:
-    free (meta_path);
-    free (meta);
-    return NULL;
+    return status;
 }
 
 static cairo_int_status_t
-_cairo_cogl_stroke_to_primitive (cairo_cogl_surface_t	    *surface,
-				 const cairo_path_fixed_t   *path,
-				 const cairo_stroke_style_t *style,
-				 const cairo_matrix_t	    *ctm,
-				 const cairo_matrix_t	    *ctm_inverse,
-				 double			     tolerance,
-				 int			     n_layers,
-				 cairo_bool_t		     one_shot,
-				 CoglPrimitive		   **primitive,
-				 size_t			    *size)
+_cairo_cogl_surface_mask (void                  *abstract_surface,
+                          cairo_operator_t       op,
+                          const cairo_pattern_t *source,
+                          const cairo_pattern_t *mask,
+                          const cairo_clip_t    *clip)
 {
-    cairo_traps_t traps;
+    cairo_cogl_surface_t *surface = abstract_surface;
+    cairo_composite_rectangles_t extents;
     cairo_int_status_t status;
+    cairo_cogl_pipeline_t *pipelines[2];
+    cairo_matrix_t identity;
 
-    _cairo_traps_init (&traps);
+    /* XXX: Use this to smoke test the acquire_source/dest_image fallback
+     * paths... */
+    //return CAIRO_INT_STATUS_UNSUPPORTED;
+
+    if (!is_operator_supported (op))
+	return CAIRO_INT_STATUS_UNSUPPORTED;
 
-    status = _cairo_path_fixed_stroke_polygon_to_traps (path, style,
-							ctm, ctm_inverse,
-							tolerance,
-							&traps);
+    status = _cairo_composite_rectangles_init_for_mask (&extents,
+							&surface->base,
+							op, source, mask, clip);
     if (unlikely (status))
-	goto BAIL;
+	return status;
 
-    if (traps.num_traps == 0) {
-	status = CAIRO_INT_STATUS_NOTHING_TO_DO;
-	goto BAIL;
+    get_source_mask_operator_destination_pipelines (pipelines,
+                                                    mask,
+                                                    source,
+                                                    op,
+                                                    surface,
+                                                    &extents,
+                                                    NULL);
+    if (unlikely (pipelines[0] == NULL && pipelines[1] == NULL)) {
+	status = CAIRO_INT_STATUS_UNSUPPORTED;
+        goto BAIL;
     }
 
-    *size = traps.num_traps * sizeof (CoglVertexP2) * 6;
+    _cairo_cogl_maybe_log_clip (surface, &extents);
 
-    //g_print ("new stroke prim\n");
-    *primitive = _cairo_cogl_traps_to_composite_prim (surface, &traps, n_layers, one_shot);
-    if (!*primitive) {
-	status = CAIRO_INT_STATUS_NO_MEMORY;
-	goto BAIL;
-    }
+    cairo_matrix_init_identity (&identity);
+    if (pipelines[0])
+        _cairo_cogl_journal_log_rectangle (surface,
+                                           pipelines[0],
+                                           extents.bounded.x,
+                                           extents.bounded.y,
+                                           extents.bounded.width,
+                                           extents.bounded.height,
+                                           &identity);
+    if (pipelines[1])
+        _cairo_cogl_journal_log_rectangle (surface,
+                                           pipelines[1],
+                                           extents.bounded.x,
+                                           extents.bounded.y,
+                                           extents.bounded.width,
+                                           extents.bounded.height,
+                                           &identity);
 
 BAIL:
-    _cairo_traps_fini (&traps);
+    _cairo_composite_rectangles_fini (&extents);
+
     return status;
 }
 
@@ -2077,29 +3505,14 @@ _cairo_cogl_surface_stroke (void                       *abstract_surface,
 {
     cairo_cogl_surface_t *surface = (cairo_cogl_surface_t *)abstract_surface;
     cairo_composite_rectangles_t extents;
-    CoglPipeline *pipeline;
-    cairo_status_t status;
-#ifdef ENABLE_PATH_CACHE
-    cairo_cogl_path_stroke_meta_t *meta = NULL;
-    cairo_matrix_t transform_matrix;
-#endif
-    cairo_matrix_t *transform = NULL;
-    gboolean one_shot = TRUE;
+    cairo_cogl_pipeline_t *pipelines[2];
+    cairo_int_status_t status;
+    cairo_matrix_t transform;
     CoglPrimitive *prim = NULL;
-    cairo_bool_t new_prim = FALSE;
 
     if (! is_operator_supported (op))
 	return CAIRO_INT_STATUS_UNSUPPORTED;
 
-    /* FIXME - support unbounded operators */
-    if (!_cairo_operator_bounded_by_mask (op)) {
-	/* Currently IN this is the only unbounded operator we aim to support
-	 * in cairo-cogl. */
-	assert (op == CAIRO_OPERATOR_IN);
-	g_warning ("FIXME: handle stroking with unbounded operators!");
-	return CAIRO_INT_STATUS_UNSUPPORTED;
-    }
-
     status = _cairo_composite_rectangles_init_for_stroke (&extents,
 							  &surface->base,
 							  op, source, path,
@@ -2109,170 +3522,50 @@ _cairo_cogl_surface_stroke (void                       *abstract_surface,
     if (unlikely (status))
 	return status;
 
-#ifdef ENABLE_PATH_CACHE
-    /* FIXME: we are currently leaking the meta state if we don't reach
-     * the cache_insert at the end. */
-    meta = _cairo_cogl_get_path_stroke_meta (surface, style, tolerance);
-    if (meta) {
-	prim = meta->prim;
-	if (prim) {
-	    cairo_matrix_multiply (&transform_matrix, &meta->ctm_inverse, surface->ctm);
-	    transform = &transform_matrix;
-	} else if (meta->counter++ > 10)
-	    one_shot = FALSE;
+    status = _cairo_cogl_stroke_to_primitive (surface, path, style,
+                                              tolerance, TRUE, &prim,
+                                              &transform);
+    if (status == CAIRO_INT_STATUS_NOTHING_TO_DO
+        && _cairo_operator_bounded_by_mask (op) == FALSE) {
+        /* Just render the unbounded rectangle */
+        prim = NULL;
+    } else if (unlikely (status)) {
+        goto BAIL;
     }
-#endif
 
-    if (!prim) {
-	int n_layers = _cairo_cogl_source_n_layers (source);
-	size_t prim_size = 0;
-	status = _cairo_cogl_stroke_to_primitive (surface, path, style,
-						  ctm, ctm_inverse, tolerance,
-						  n_layers, one_shot,
-						  &prim, &prim_size);
-	if (unlikely (status))
-	    return status;
-	new_prim = TRUE;
-#if defined (ENABLE_PATH_CACHE)
-	if (meta) {
-	    meta->prim = cogl_object_ref (prim);
-	    _cairo_cogl_path_stroke_meta_set_prim_size (surface, meta, prim_size);
-	}
-#endif
+    get_source_mask_operator_destination_pipelines (pipelines,
+                                                    NULL,
+                                                    source,
+                                                    op,
+                                                    surface,
+                                                    &extents,
+                                                    &transform);
+    if (unlikely (pipelines[0] == NULL && pipelines[1] == NULL)) {
+        status = CAIRO_INT_STATUS_UNSUPPORTED;
+        goto BAIL;
     }
 
-    pipeline = get_source_mask_operator_destination_pipeline (NULL, source,
-							      op, surface, &extents);
-    if (!pipeline)
-	return CAIRO_INT_STATUS_UNSUPPORTED;
-
     _cairo_cogl_maybe_log_clip (surface, &extents);
 
-    _cairo_cogl_journal_log_primitive (surface, pipeline, prim, transform);
+    if (pipelines[0])
+        _cairo_cogl_journal_log_primitive (surface,
+                                           pipelines[0],
+                                           prim,
+                                           &transform);
+    if (pipelines[1])
+        _cairo_cogl_journal_log_primitive (surface,
+                                           pipelines[1],
+                                           prim,
+                                           &transform);
 
-    /* The journal will take a reference on the pipeline and primitive... */
-    cogl_object_unref (pipeline);
-    if (new_prim)
+BAIL:
+    /* The journal will take a reference on the primitive... */
+    if (prim)
 	cogl_object_unref (prim);
 
-    return CAIRO_INT_STATUS_SUCCESS;
-}
-
-static cairo_cogl_path_fill_meta_t *
-_cairo_cogl_path_fill_meta_reference (cairo_cogl_path_fill_meta_t *meta)
-{
-    assert (CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&meta->ref_count));
-
-    _cairo_reference_count_inc (&meta->ref_count);
-
-    return meta;
-}
-
-static void
-_cairo_cogl_path_fill_meta_destroy (cairo_cogl_path_fill_meta_t *meta)
-{
-    assert (CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&meta->ref_count));
-
-    if (! _cairo_reference_count_dec_and_test (&meta->ref_count))
-	return;
-
-    _cairo_path_fixed_fini (meta->user_path);
-    free (meta->user_path);
-
-    if (meta->prim)
-	cogl_object_unref (meta->prim);
-
-    free (meta);
-}
-
-static cairo_cogl_path_fill_meta_t *
-_cairo_cogl_path_fill_meta_lookup (cairo_cogl_device_t	*ctx,
-				   unsigned long	 hash,
-				   cairo_path_fixed_t	*user_path)
-{
-    cairo_cogl_path_fill_meta_t *ret;
-    cairo_cogl_path_fill_meta_t lookup;
-
-    lookup.cache_entry.hash = hash;
-    lookup.user_path = user_path;
-
-    ret = _cairo_cache_lookup (&ctx->path_fill_staging_cache, &lookup.cache_entry);
-    if (!ret)
-	ret = _cairo_cache_lookup (&ctx->path_fill_prim_cache, &lookup.cache_entry);
-    return ret;
-}
-
-static void
-_cairo_cogl_path_fill_meta_set_prim_size (cairo_cogl_surface_t *surface,
-					  cairo_cogl_path_fill_meta_t *meta,
-					  size_t size)
-{
-    /* now that we know the meta structure is associated with a primitive
-     * we promote it from the staging cache into the primitive cache.
-     */
-
-    /* XXX: _cairo_cache borks if you try and remove an entry that's already
-     * been evicted so we explicitly look it up first... */
-    if (_cairo_cache_lookup (&to_device(surface->base.device)->path_fill_staging_cache, &meta->cache_entry)) {
-	_cairo_cogl_path_fill_meta_reference (meta);
-	_cairo_cache_remove (&to_device(surface->base.device)->path_fill_staging_cache, &meta->cache_entry);
-    }
-
-    meta->cache_entry.size = size;
-    if (_cairo_cache_insert (&to_device(surface->base.device)->path_fill_prim_cache, &meta->cache_entry) !=
-	CAIRO_STATUS_SUCCESS)
-	_cairo_cogl_path_fill_meta_destroy (meta);
-}
-
-static cairo_cogl_path_fill_meta_t *
-_cairo_cogl_get_path_fill_meta (cairo_cogl_surface_t *surface)
-{
-    unsigned long hash;
-    cairo_cogl_path_fill_meta_t *meta = NULL;
-    cairo_path_fixed_t *meta_path = NULL;
-    cairo_status_t status;
-
-    if (!surface->user_path)
-	return NULL;
-
-    hash = _cairo_path_fixed_hash (surface->user_path);
-
-    meta = _cairo_cogl_path_fill_meta_lookup (to_device(surface->base.device),
-					      hash, surface->user_path);
-    if (meta)
-	return meta;
-
-    meta = calloc (1, sizeof (cairo_cogl_path_fill_meta_t));
-    if (!meta)
-	goto BAIL;
-    meta->cache_entry.hash = hash;
-    meta->counter = 0;
-    CAIRO_REFERENCE_COUNT_INIT (&meta->ref_count, 1);
-    meta_path = _cairo_malloc (sizeof (cairo_path_fixed_t));
-    if (!meta_path)
-	goto BAIL;
-    /* FIXME: we should add a ref-counted wrapper for our user_paths
-     * so we don't have to keep copying them here! */
-    status = _cairo_path_fixed_init_copy (meta_path, surface->user_path);
-    if (unlikely (status))
-	goto BAIL;
-    meta->user_path = meta_path;
-    meta->ctm_inverse = *surface->ctm_inverse;
-
-    /* To start with - until we associate a CoglPrimitive with the meta
-     * structure - we keep the meta in a staging structure until we
-     * see whether it actually gets re-used. */
-    meta->cache_entry.size = 1;
-    if (_cairo_cache_insert (&to_device(surface->base.device)->path_fill_staging_cache, &meta->cache_entry) !=
-	CAIRO_STATUS_SUCCESS)
-	_cairo_cogl_path_fill_meta_destroy (meta);
+    _cairo_composite_rectangles_fini (&extents);
 
-    return meta;
-
-BAIL:
-    free (meta_path);
-    free (meta);
-    return NULL;
+    return status;
 }
 
 static cairo_int_status_t
@@ -2287,29 +3580,14 @@ _cairo_cogl_surface_fill (void			    *abstract_surface,
 {
     cairo_cogl_surface_t *surface = abstract_surface;
     cairo_composite_rectangles_t extents;
-    cairo_status_t status;
-#ifdef ENABLE_PATH_CACHE
-    cairo_cogl_path_fill_meta_t *meta = NULL;
-    cairo_matrix_t transform_matrix;
-#endif
-    cairo_matrix_t *transform = NULL;
-    cairo_bool_t one_shot = TRUE;
+    cairo_int_status_t status;
+    cairo_matrix_t transform;
     CoglPrimitive *prim = NULL;
-    cairo_bool_t new_prim = FALSE;
-    CoglPipeline *pipeline;
+    cairo_cogl_pipeline_t *pipelines[2];
 
     if (! is_operator_supported (op))
 	return CAIRO_INT_STATUS_UNSUPPORTED;
 
-    /* FIXME - support unbounded operators */
-    if (!_cairo_operator_bounded_by_mask (op)) {
-	/* Currently IN this is the only unbounded operator we aim to support
-	 * in cairo-cogl. */
-	assert (op == CAIRO_OPERATOR_IN);
-	g_warning ("FIXME: handle filling with unbounded operators!");
-	return CAIRO_INT_STATUS_UNSUPPORTED;
-    }
-
     status = _cairo_composite_rectangles_init_for_fill (&extents,
 							&surface->base,
 							op, source, path,
@@ -2317,152 +3595,111 @@ _cairo_cogl_surface_fill (void			    *abstract_surface,
     if (unlikely (status))
 	return status;
 
-#ifndef FILL_WITH_COGL_PATH
-#ifdef ENABLE_PATH_CACHE
-    meta = _cairo_cogl_get_path_fill_meta (surface);
-    if (meta) {
-	prim = meta->prim;
-	if (prim) {
-	    cairo_matrix_multiply (&transform_matrix, &meta->ctm_inverse, surface->ctm);
-	    transform = &transform_matrix;
-	} else if (meta->counter++ > 10)
-	    one_shot = FALSE;
-    }
-#endif /* ENABLE_PATH_CACHE */
-
-    if (!prim) {
-	int n_layers = _cairo_cogl_source_n_layers (source);
-	size_t prim_size;
-	status = _cairo_cogl_fill_to_primitive (surface, path, fill_rule, tolerance,
-						one_shot, n_layers, &prim, &prim_size);
-	if (unlikely (status))
-	    return status;
-	new_prim = TRUE;
-#ifdef ENABLE_PATH_CACHE
-	if (meta) {
-	    meta->prim = cogl_object_ref (prim);
-	    _cairo_cogl_path_fill_meta_set_prim_size (surface, meta, prim_size);
-	}
-#endif /* ENABLE_PATH_CACHE */
+    status = _cairo_cogl_fill_to_primitive (surface, path, fill_rule,
+                                            tolerance, TRUE, &prim,
+                                            &transform);
+    if (status == CAIRO_INT_STATUS_NOTHING_TO_DO
+        && _cairo_operator_bounded_by_mask (op) == FALSE) {
+        /* Just render the unbounded rectangle */
+        prim = NULL;
+    } else if (unlikely (status)) {
+        goto BAIL;
     }
 
-#endif /* !FILL_WITH_COGL_PATH */
-
-    pipeline = get_source_mask_operator_destination_pipeline (NULL, source,
-							      op, surface, &extents);
-    if (!pipeline)
-	return CAIRO_INT_STATUS_UNSUPPORTED;
+    get_source_mask_operator_destination_pipelines (pipelines,
+                                                    NULL,
+                                                    source,
+                                                    op,
+                                                    surface,
+                                                    &extents,
+                                                    &transform);
+    if (unlikely (pipelines[0] == NULL && pipelines[1] == NULL)) {
+        status = CAIRO_INT_STATUS_UNSUPPORTED;
+        goto BAIL;
+    }
 
     _cairo_cogl_maybe_log_clip (surface, &extents);
 
-#ifndef FILL_WITH_COGL_PATH
-    _cairo_cogl_journal_log_primitive (surface, pipeline, prim, transform);
+    if (pipelines[0])
+        _cairo_cogl_journal_log_primitive (surface,
+                                           pipelines[0],
+                                           prim,
+                                           &transform);
+    if (pipelines[1])
+        _cairo_cogl_journal_log_primitive (surface,
+                                           pipelines[1],
+                                           prim,
+                                           &transform);
+
+BAIL:
     /* The journal will take a reference on the prim */
-    if (new_prim)
+    if (prim)
 	cogl_object_unref (prim);
-#else
-    CoglPath * cogl_path = _cairo_cogl_util_path_from_cairo (path, fill_rule, tolerance);
-    _cairo_cogl_journal_log_path (surface, pipeline, cogl_path);
-    cogl_object_unref (cogl_path);
-#endif
+    _cairo_composite_rectangles_fini (&extents);
 
-    /* The journal will take a reference on the pipeline... */
-    cogl_object_unref (pipeline);
-
-    return CAIRO_INT_STATUS_SUCCESS;
+    return status;
 }
 
-cairo_int_status_t
-_cairo_cogl_surface_fill_rectangle (void		     *abstract_surface,
-				    cairo_operator_t	      op,
-				    const cairo_pattern_t    *source,
-				    double		      x,
-				    double		      y,
-				    double		      width,
-				    double		      height,
-				    cairo_matrix_t	     *ctm,
-				    const cairo_clip_t	     *clip)
+/* Mostly taken from #cairo_vg_surface.c */
+/* TODO: implement actual font support, with either cogl-pango's glyph
+ * cache or our own */
+static cairo_int_status_t
+_cairo_cogl_surface_show_glyphs (void                  *abstract_surface,
+                                 cairo_operator_t       op,
+                                 const cairo_pattern_t *source,
+                                 cairo_glyph_t         *glyphs,
+                                 int                    num_glyphs,
+                                 cairo_scaled_font_t   *scaled_font,
+                                 const cairo_clip_t    *clip)
 {
-    cairo_cogl_surface_t *surface = abstract_surface;
-    CoglPipeline *pipeline;
-
-    if (! is_operator_supported (op))
-	return CAIRO_INT_STATUS_UNSUPPORTED;
+    cairo_status_t status = CAIRO_STATUS_SUCCESS;
+    cairo_path_fixed_t path;
+    int num_chunk_glyphs;
+    int i;
 
-    /* FIXME - support unbounded operators */
-    if (!_cairo_operator_bounded_by_mask (op)) {
-	/* Currently IN this is the only unbounded operator we aim to support
-	 * in cairo-cogl. */
-	assert (op == CAIRO_OPERATOR_IN);
-	g_warning ("FIXME: handle filling with unbounded operators!");
-	return CAIRO_INT_STATUS_UNSUPPORTED;
+    if (num_glyphs <= 0)
+        return CAIRO_STATUS_SUCCESS;
+
+#define GLYPH_CHUNK_SIZE 100
+
+    /* Chunk glyphs in order to avoid large computation overheads
+     * during tessellation of long strings */
+    for (i = 0; i < num_glyphs; i += GLYPH_CHUNK_SIZE) {
+        num_chunk_glyphs = (num_glyphs - i) < GLYPH_CHUNK_SIZE ?
+                           (num_glyphs - i) : GLYPH_CHUNK_SIZE;
+
+        _cairo_path_fixed_init (&path);
+        status = _cairo_scaled_font_glyph_path (scaled_font,
+                                                &glyphs[i],
+                                                num_chunk_glyphs,
+                                                &path);
+        if (unlikely (status))
+            goto BAIL;
+
+        status = _cairo_cogl_surface_fill (abstract_surface,
+                                           op, source, &path,
+                                           CAIRO_FILL_RULE_WINDING,
+                                           CAIRO_GSTATE_TOLERANCE_DEFAULT,
+                                           CAIRO_ANTIALIAS_DEFAULT,
+                                           clip);
+
+        _cairo_path_fixed_fini (&path);
     }
 
-    /* FIXME */
-#if 0
-    status = _cairo_composite_rectangles_init_for_fill_rectangle (&extents,
-								  &surface->base,
-								  op, source, path,
-								  clip);
-    if (unlikely (status))
-	return status;
-#endif
+#undef GLYPH_CHUNK_SIZE
 
-    if (source->type == CAIRO_PATTERN_TYPE_SOLID) {
-	double x1 = x;
-	double y1 = y;
-	double x2 = x1 + width;
-	double y2 = y1 + height;
-
-	pipeline = get_source_mask_operator_destination_pipeline (NULL, source,
-								  op, surface, NULL);
-	if (!pipeline)
-	    return CAIRO_INT_STATUS_UNSUPPORTED;
-
-	_cairo_cogl_log_clip (surface, clip);
-
-	_cairo_cogl_journal_log_rectangle (surface,
-					   pipeline,
-					   x1, y1, x2, y2,
-					   0,
-					   ctm);
-	return CAIRO_INT_STATUS_SUCCESS;
-    } else
-	return CAIRO_INT_STATUS_UNSUPPORTED;
+    return CAIRO_STATUS_SUCCESS;
 
-    /* TODO:
-     * We need to acquire the textures here, look at the corresponding
-     * attributes and see if this can be trivially handled by logging
-     * a textured rectangle only needing simple scaling or translation
-     * of texture coordinates.
-     *
-     * At this point we should also aim to remap the default
-     * EXTEND_NONE mode to EXTEND_PAD which is more efficient if we
-     * know it makes no difference either way since we can map that to
-     * CLAMP_TO_EDGE.
-     */
-}
+BAIL:
+    _cairo_path_fixed_fini (&path);
 
-static cairo_int_status_t
-_cairo_cogl_surface_show_glyphs (void			*surface,
-                                 cairo_operator_t        op,
-                                 const cairo_pattern_t	*source,
-                                 cairo_glyph_t          *glyphs,
-                                 int                     num_glyphs,
-                                 cairo_scaled_font_t	*scaled_font,
-                                 const cairo_clip_t     *clip)
-{
-    return CAIRO_INT_STATUS_UNSUPPORTED;
+    return status;
 }
 
 const cairo_surface_backend_t _cairo_cogl_surface_backend = {
     CAIRO_SURFACE_TYPE_COGL,
     _cairo_cogl_surface_finish,
-#ifdef NEED_COGL_CONTEXT
-    _cairo_cogl_context_create,
-#else
     _cairo_default_context_create,
-#endif
 
     _cairo_cogl_surface_create_similar,
     NULL, /* create similar image */
@@ -2487,15 +3724,15 @@ const cairo_surface_backend_t _cairo_cogl_surface_backend = {
     _cairo_cogl_surface_mask,
     _cairo_cogl_surface_stroke,
     _cairo_cogl_surface_fill,
-    NULL, /* fill_stroke*/
-    _cairo_surface_fallback_glyphs,
+    NULL, /* fill_stroke */
+    _cairo_cogl_surface_show_glyphs,
 };
 
 static cairo_surface_t *
 _cairo_cogl_surface_create_full (cairo_cogl_device_t *dev,
-				 cairo_bool_t ignore_alpha,
-				 CoglFramebuffer *framebuffer,
-				 CoglTexture *texture)
+				 cairo_content_t      content,
+				 CoglFramebuffer     *framebuffer,
+				 CoglTexture         *texture)
 {
     cairo_cogl_surface_t *surface;
     cairo_status_t status;
@@ -2508,13 +3745,12 @@ _cairo_cogl_surface_create_full (cairo_cogl_device_t *dev,
     if (unlikely (surface == NULL))
         return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_NO_MEMORY));
 
-    surface->ignore_alpha = ignore_alpha;
+    surface->is_mirrored_snapshot = FALSE;
 
     surface->framebuffer = framebuffer;
     if (framebuffer) {
-	surface->width = cogl_framebuffer_get_width (framebuffer);
-	surface->height = cogl_framebuffer_get_height (framebuffer);
-	surface->cogl_format = cogl_framebuffer_get_color_format (framebuffer);
+        surface->width = cogl_framebuffer_get_width (framebuffer);
+        surface->height = cogl_framebuffer_get_height (framebuffer);
 	cogl_object_ref (framebuffer);
     }
 
@@ -2523,36 +3759,34 @@ _cairo_cogl_surface_create_full (cairo_cogl_device_t *dev,
     surface->texture = texture;
     if (texture) {
 	if (!framebuffer) {
-	    surface->width = cogl_texture_get_width (texture);
-	    surface->height = cogl_texture_get_height (texture);
-	    surface->cogl_format = cogl_texture_get_format (texture);
-	}
+            surface->width = cogl_texture_get_width (texture);
+            surface->height = cogl_texture_get_height (texture);
+        }
 	cogl_object_ref (texture);
     }
 
-    assert(surface->width && surface->height);
-
     surface->journal = NULL;
 
-    surface->buffer_stack = NULL;
-    surface->buffer_stack_size = 4096;
-
     surface->last_clip = NULL;
 
     surface->n_clip_updates_per_frame = 0;
 
+    surface->path_is_rectangle = FALSE;
+    surface->user_path = NULL;
+
     _cairo_surface_init (&surface->base,
                          &_cairo_cogl_surface_backend,
                          &dev->base,
-                         CAIRO_CONTENT_COLOR_ALPHA,
+                         content,
 			 FALSE); /* is_vector */
 
     return &surface->base;
 }
 
 cairo_surface_t *
-cairo_cogl_surface_create (cairo_device_t  *abstract_device,
-			   CoglFramebuffer *framebuffer)
+cairo_cogl_surface_create_for_fb (cairo_device_t  *abstract_device,
+                                  CoglFramebuffer *framebuffer,
+                                  cairo_content_t  content)
 {
     cairo_cogl_device_t *dev = (cairo_cogl_device_t *)abstract_device;
 
@@ -2565,9 +3799,106 @@ cairo_cogl_surface_create (cairo_device_t  *abstract_device,
     if (abstract_device->backend->type != CAIRO_DEVICE_TYPE_COGL)
 	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_SURFACE_TYPE_MISMATCH));
 
-    return _cairo_cogl_surface_create_full (dev, FALSE, framebuffer, NULL);
+    return _cairo_cogl_surface_create_full (dev,
+                                            content,
+                                            framebuffer,
+                                            NULL);
+}
+slim_hidden_def (cairo_cogl_surface_create_for_fb);
+
+cairo_surface_t *
+cairo_cogl_onscreen_surface_create (cairo_device_t *abstract_device,
+                                    cairo_content_t content,
+                                    int width, int height)
+{
+    CoglFramebuffer *fb;
+    CoglTextureComponents components;
+    CoglError *error = NULL;
+    cairo_surface_t *surface;
+    cairo_cogl_device_t *dev = (cairo_cogl_device_t *)abstract_device;
+
+    if (abstract_device->backend->type != CAIRO_DEVICE_TYPE_COGL)
+	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_SURFACE_TYPE_MISMATCH));
+
+    /* We don't yet have a way to set the components of a framebuffer */
+    components = get_components_from_cairo_content (content);
+
+    fb = cogl_onscreen_new (dev->cogl_context, width, height);
+
+    if (unlikely (!cogl_framebuffer_allocate (fb, &error))) {
+        g_warning ("Could not allocate framebuffer for onscreen "
+                   "surface: %s", error->message);
+        cogl_error_free (error);
+        return _cairo_surface_create_in_error (CAIRO_STATUS_DEVICE_ERROR);
+    }
+    cogl_framebuffer_orthographic (fb, 0, 0, width, height, -1, 100);
+
+    surface = cairo_cogl_surface_create_for_fb (abstract_device,
+                                                fb,
+                                                content);
+
+    /* The surface will take a reference on the framebuffer */
+    cogl_object_unref (fb);
+
+    return surface;
+}
+slim_hidden_def (cairo_cogl_onscreen_surface_create);
+
+cairo_surface_t *
+cairo_cogl_offscreen_surface_create (cairo_device_t *abstract_device,
+                                     cairo_content_t content,
+                                     int width, int height)
+{
+    CoglFramebuffer *fb;
+    CoglTexture *tex;
+    CoglError *error = NULL;
+    cairo_surface_t *surface;
+    cairo_cogl_device_t *dev = (cairo_cogl_device_t *)abstract_device;
+    int tex_width = width;
+    int tex_height = height;
+
+    if (abstract_device->backend->type != CAIRO_DEVICE_TYPE_COGL)
+	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_SURFACE_TYPE_MISMATCH));
+
+    /* If we cannot use an NPOT texture, allocate the texture in power
+     * of two dimensions instead */
+    if (!dev->has_npots) {
+        tex_width = (int)pow (2, ceil (log2 (tex_width)));
+        tex_height = (int)pow (2, ceil (log2 (tex_height)));
+    }
+
+    tex = cogl_texture_2d_new_with_size (dev->cogl_context,
+                                         tex_width, tex_height);
+    cogl_texture_set_components (tex,
+        get_components_from_cairo_content (content));
+    fb = cogl_offscreen_new_with_texture (tex);
+
+    if (unlikely (!cogl_framebuffer_allocate (fb, &error))) {
+        g_warning ("Could not allocate framebuffer for offscreen "
+                   "surface: %s", error->message);
+        cogl_error_free (error);
+        return _cairo_surface_create_in_error (CAIRO_STATUS_DEVICE_ERROR);
+    }
+    cogl_framebuffer_orthographic (fb, 0, 0,
+                                   tex_width, tex_height,
+                                   -1, 100);
+
+    /* The framebuffer will take a reference on the texture */
+    cogl_object_unref (tex);
+
+    surface = cairo_cogl_surface_create_for_fb (abstract_device,
+                                                fb,
+                                                content);
+
+    /* The surface will take a reference on the framebuffer */
+    cogl_object_unref (fb);
+
+    ((cairo_cogl_surface_t *)surface)->width = width;
+    ((cairo_cogl_surface_t *)surface)->height = height;
+
+    return surface;
 }
-slim_hidden_def (cairo_cogl_surface_create);
+slim_hidden_def (cairo_cogl_offscreen_surface_create);
 
 CoglFramebuffer *
 cairo_cogl_surface_get_framebuffer (cairo_surface_t *abstract_surface)
@@ -2605,6 +3936,7 @@ static cairo_status_t
 _cairo_cogl_device_flush (void *device)
 {
     cairo_status_t status;
+    cairo_cogl_device_t *dev = device;
 
     status = cairo_device_acquire (device);
     if (unlikely (status))
@@ -2613,6 +3945,12 @@ _cairo_cogl_device_flush (void *device)
     /* XXX: we don't need to flush Cogl here, we just need to flush
      * any batching we do of compositing primitives. */
 
+    if (dev->buffer_stack && dev->buffer_stack_offset) {
+        cogl_buffer_unmap (dev->buffer_stack);
+        cogl_object_unref (dev->buffer_stack);
+        dev->buffer_stack = NULL;
+    }
+
     cairo_device_release (device);
 
     return CAIRO_STATUS_SUCCESS;
@@ -2622,6 +3960,8 @@ static void
 _cairo_cogl_device_finish (void *device)
 {
     cairo_status_t status;
+    cairo_cogl_device_t *dev = device;
+    int i, j;
 
     status = cairo_device_acquire (device);
     if (unlikely (status))
@@ -2629,6 +3969,28 @@ _cairo_cogl_device_finish (void *device)
 
     /* XXX: Drop references to external resources */
 
+    _cairo_cache_fini (&dev->linear_cache);
+    _cairo_cache_fini (&dev->path_fill_prim_cache);
+    _cairo_cache_fini (&dev->path_stroke_prim_cache);
+
+    _cairo_freelist_fini (&dev->path_fill_meta_freelist);
+    _cairo_freelist_fini (&dev->path_stroke_meta_freelist);
+
+    if (dev->buffer_stack && dev->buffer_stack_offset) {
+        cogl_buffer_unmap (dev->buffer_stack);
+        cogl_object_unref (dev->buffer_stack);
+        dev->buffer_stack = NULL;
+    }
+
+    for (i = 0; i < CAIRO_OPERATOR_SATURATE; i++)
+        for (j = 0; j < CAIRO_COGL_TEMPLATE_TYPE_COUNT; j++)
+            if (dev->template_pipelines[i][j] != NULL) {
+                cogl_object_unref (dev->template_pipelines[i][j]);
+                dev->template_pipelines[i][j] = NULL;
+            }
+
+    cogl_object_unref (dev->cogl_context);
+
     cairo_device_release (device);
 }
 
@@ -2637,8 +3999,6 @@ _cairo_cogl_device_destroy (void *device)
 {
     cairo_cogl_device_t *dev = device;
 
-    /* FIXME: Free stuff! */
-
     g_free (dev);
 }
 
@@ -2653,125 +4013,39 @@ static const cairo_device_backend_t _cairo_cogl_device_backend = {
     _cairo_cogl_device_destroy,
 };
 
-static cairo_bool_t
-set_blend (CoglPipeline *pipeline, const char *blend_string)
-{
-    GError *error = NULL;
-    if (!cogl_pipeline_set_blend (pipeline, blend_string, &error)) {
-	g_warning ("Unsupported blend string with current gpu/driver: %s", blend_string);
-	g_error_free (error);
-	return FALSE;
-    }
-    return TRUE;
-}
-
-static cairo_bool_t
-_cairo_cogl_setup_op_state (CoglPipeline *pipeline, cairo_operator_t op)
-{
-    cairo_bool_t status = FALSE;
-
-    switch ((int)op)
-    {
-    case CAIRO_OPERATOR_SOURCE:
-	status = set_blend (pipeline, "RGBA = ADD (SRC_COLOR, 0)");
-	break;
-    case CAIRO_OPERATOR_OVER:
-	status = set_blend (pipeline, "RGBA = ADD (SRC_COLOR, DST_COLOR * (1 - SRC_COLOR[A]))");
-	break;
-    case CAIRO_OPERATOR_IN:
-	status = set_blend (pipeline, "RGBA = ADD (SRC_COLOR * DST_COLOR[A], 0)");
-	break;
-    case CAIRO_OPERATOR_DEST_OVER:
-	status = set_blend (pipeline, "RGBA = ADD (SRC_COLOR * (1 - DST_COLOR[A]), DST_COLOR)");
-	break;
-    case CAIRO_OPERATOR_DEST_IN:
-	status = set_blend (pipeline, "RGBA = ADD (0, DST_COLOR * SRC_COLOR[A])");
-	break;
-    case CAIRO_OPERATOR_ADD:
-	status = set_blend (pipeline, "RGBA = ADD (SRC_COLOR, DST_COLOR)");
-	break;
-    }
-
-    return status;
-}
-
-static void
-create_templates_for_op (cairo_cogl_device_t *dev, cairo_operator_t op)
-{
-    CoglPipeline *base = cogl_pipeline_new ();
-    CoglPipeline *pipeline;
-    CoglColor color;
-
-    if (!_cairo_cogl_setup_op_state (base, op)) {
-	cogl_object_unref (base);
-	return;
-    }
-
-    dev->template_pipelines[op][CAIRO_COGL_TEMPLATE_TYPE_SOLID] = base;
-
-    pipeline = cogl_pipeline_copy (base);
-    cogl_pipeline_set_layer_texture (pipeline, 0, dev->dummy_texture);
-    dev->template_pipelines[op][CAIRO_COGL_TEMPLATE_TYPE_TEXTURE] = pipeline;
-
-    pipeline = cogl_pipeline_copy (base);
-    cogl_pipeline_set_layer_combine (pipeline, 1,
-                                     "RGBA = MODULATE (PREVIOUS, CONSTANT[A])",
-                                     NULL);
-    cogl_pipeline_set_layer_combine_constant (pipeline, 1, &color);
-    cogl_pipeline_set_layer_texture (pipeline, 1, dev->dummy_texture);
-    dev->template_pipelines[op][CAIRO_COGL_TEMPLATE_TYPE_MASK_SOLID] = pipeline;
-
-    pipeline = cogl_pipeline_copy (base);
-    cogl_pipeline_set_layer_combine (pipeline, 1,
-                                     "RGBA = MODULATE (PREVIOUS, TEXTURE[A])",
-                                     NULL);
-    cogl_pipeline_set_layer_texture (pipeline, 1, dev->dummy_texture);
-    dev->template_pipelines[op][CAIRO_COGL_TEMPLATE_TYPE_MASK_TEXTURE] = pipeline;
-}
-
 cairo_device_t *
 cairo_cogl_device_create (CoglContext *cogl_context)
 {
-    cairo_cogl_device_t *dev = g_new0 (cairo_cogl_device_t, 1);
+    cairo_cogl_device_t *dev = g_new (cairo_cogl_device_t, 1);
     cairo_status_t status;
 
-    dev->backend_vtable_initialized = FALSE;
+    dev->cogl_context = cogl_object_ref (cogl_context);
 
-    dev->cogl_context = cogl_context;
+    dev->has_npots =
+        cogl_has_features (cogl_context,
+                           COGL_FEATURE_ID_TEXTURE_NPOT_BASIC,
+                           COGL_FEATURE_ID_TEXTURE_NPOT_REPEAT,
+                           0);
 
-    dev->dummy_texture = cogl_texture_new_with_size (1, 1,
-						     COGL_TEXTURE_NO_SLICING,
-						     COGL_PIXEL_FORMAT_ANY);
-    if (!dev->dummy_texture)
-	goto ERROR;
+    dev->has_mirrored_repeat =
+        cogl_has_feature (cogl_context,
+                          COGL_FEATURE_ID_MIRRORED_REPEAT);
 
+    dev->buffer_stack = NULL;
+    dev->buffer_stack_size = 4096;
+
+    /* Set all template pipelines to NULL */
     memset (dev->template_pipelines, 0, sizeof (dev->template_pipelines));
-    create_templates_for_op (dev, CAIRO_OPERATOR_SOURCE);
-    create_templates_for_op (dev, CAIRO_OPERATOR_OVER);
-    create_templates_for_op (dev, CAIRO_OPERATOR_IN);
-    create_templates_for_op (dev, CAIRO_OPERATOR_DEST_OVER);
-    create_templates_for_op (dev, CAIRO_OPERATOR_DEST_IN);
-    create_templates_for_op (dev, CAIRO_OPERATOR_ADD);
 
     status = _cairo_cache_init (&dev->linear_cache,
                                 _cairo_cogl_linear_gradient_equal,
                                 NULL,
                                 (cairo_destroy_func_t) _cairo_cogl_linear_gradient_destroy,
                                 CAIRO_COGL_LINEAR_GRADIENT_CACHE_SIZE);
-    if (unlikely (status))
-	return _cairo_device_create_in_error(status);
-
-    status = _cairo_cache_init (&dev->path_fill_staging_cache,
-                                _cairo_cogl_path_fill_meta_equal,
-                                NULL,
-                                (cairo_destroy_func_t) _cairo_cogl_path_fill_meta_destroy,
-                                1000);
-
-    status = _cairo_cache_init (&dev->path_stroke_staging_cache,
-                                _cairo_cogl_path_stroke_meta_equal,
-                                NULL,
-                                (cairo_destroy_func_t) _cairo_cogl_path_stroke_meta_destroy,
-                                1000);
+    if (unlikely (status)) {
+        g_free (dev);
+        return _cairo_device_create_in_error (status);
+    }
 
     status = _cairo_cache_init (&dev->path_fill_prim_cache,
                                 _cairo_cogl_path_fill_meta_equal,
@@ -2785,22 +4059,48 @@ cairo_cogl_device_create (CoglContext *cogl_context)
                                 (cairo_destroy_func_t) _cairo_cogl_path_stroke_meta_destroy,
                                 CAIRO_COGL_PATH_META_CACHE_SIZE);
 
+    _cairo_freelist_init (&dev->path_fill_meta_freelist,
+                          sizeof(cairo_cogl_path_fill_meta_t));
+    _cairo_freelist_init (&dev->path_stroke_meta_freelist,
+                          sizeof(cairo_cogl_path_stroke_meta_t));
+
     _cairo_device_init (&dev->base, &_cairo_cogl_device_backend);
     return &dev->base;
-
-ERROR:
-    g_free (dev);
-    return _cairo_device_create_in_error (CAIRO_STATUS_DEVICE_ERROR);
 }
 slim_hidden_def (cairo_cogl_device_create);
 
-void
+cairo_status_t
 cairo_cogl_surface_end_frame (cairo_surface_t *abstract_surface)
 {
     cairo_cogl_surface_t *surface = (cairo_cogl_surface_t *)abstract_surface;
+
+    if (abstract_surface->backend != &_cairo_cogl_surface_backend)
+        return CAIRO_STATUS_SURFACE_TYPE_MISMATCH;
+
     cairo_surface_flush (abstract_surface);
 
-    //g_print ("n_clip_update_per_frame = %d\n", surface->n_clip_updates_per_frame);
+    if (surface->framebuffer)
+        if (cogl_is_onscreen (surface->framebuffer))
+            cogl_onscreen_swap_buffers (surface->framebuffer);
+
+    //g_print ("n_clip_updates_per_frame = %d\n", surface->n_clip_updates_per_frame);
     surface->n_clip_updates_per_frame = 0;
+
+    return CAIRO_STATUS_SUCCESS;
 }
 slim_hidden_def (cairo_cogl_surface_end_frame);
+
+cairo_status_t
+cairo_cogl_surface_synchronize (cairo_surface_t *abstract_surface)
+{
+    cairo_cogl_surface_t *surface = (cairo_cogl_surface_t *)abstract_surface;
+
+    if (abstract_surface->backend != &_cairo_cogl_surface_backend)
+        return CAIRO_STATUS_SURFACE_TYPE_MISMATCH;
+
+    if (surface->framebuffer)
+        cogl_framebuffer_finish (surface->framebuffer);
+
+    return CAIRO_STATUS_SUCCESS;
+}
+slim_hidden_def (cairo_cogl_surface_synchronize);
diff --git a/src/cairo-cogl-utils-private.h b/src/cairo-cogl-utils-private.h
deleted file mode 100644
index ee77f3034..000000000
--- a/src/cairo-cogl-utils-private.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright  2011 Intel Corporation.
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335, USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.og/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * Contributor(s):
- *      Robert Bragg <robert@linux.intel.com>
- */
-
-#ifndef CAIRO_COGL_UTILS_PRIVATE_H
-#define CAIRO_COGL_UTILS_PRIVATE_H
-
-#include "cairo-path-fixed-private.h"
-#include <cogl/cogl2-experimental.h>
-
-CoglPath *
-_cairo_cogl_util_path_from_cairo (const cairo_path_fixed_t *path,
-				  cairo_fill_rule_t fill_rule,
-				  float tolerance);
-
-int
-_cairo_cogl_util_next_p2 (int a);
-
-#define CAIRO_FIXED_ONE_FLOAT ((float)(1 << CAIRO_FIXED_FRAC_BITS))
-
-static inline float
-_cairo_cogl_util_fixed_to_float (cairo_fixed_t f)
-{
-    return ((float) f) / CAIRO_FIXED_ONE_FLOAT;
-}
-
-#endif /* CAIRO_COGL_UTILS_PRIVATE_H */
diff --git a/src/cairo-cogl-utils.c b/src/cairo-cogl-utils.c
deleted file mode 100644
index 4f02aaa52..000000000
--- a/src/cairo-cogl-utils.c
+++ /dev/null
@@ -1,126 +0,0 @@
-/* cairo - a vector graphics library with display and print output
- *
- * Copyright  2011 Intel Corporation.
- *
- * This library is free software; you can redistribute it and/or
- * modify it either under the terms of the GNU Lesser General Public
- * License version 2.1 as published by the Free Software Foundation
- * (the "LGPL") or, at your option, under the terms of the Mozilla
- * Public License Version 1.1 (the "MPL"). If you do not alter this
- * notice, a recipient may use your version of this file under either
- * the MPL or the LGPL.
- *
- * You should have received a copy of the LGPL along with this library
- * in the file COPYING-LGPL-2.1; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335, USA
- * You should have received a copy of the MPL along with this library
- * in the file COPYING-MPL-1.1
- *
- * The contents of this file are subject to the Mozilla Public License
- * Version 1.1 (the "License"); you may not use this file except in
- * compliance with the License. You may obtain a copy of the License at
- * http://www.mozilla.og/MPL/
- *
- * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
- * OF ANY KIND, either express or implied. See the LGPL or the MPL for
- * the specific language governing rights and limitations.
- *
- * Contributor(s):
- *      Robert Bragg <robert@linux.intel.com>
- */
-
-#include "cairoint.h"
-#include "cairo-cogl-utils-private.h"
-
-#include <cogl/cogl.h>
-#include <glib.h>
-
-static cairo_status_t
-_cogl_move_to (void		   *closure,
-	       const cairo_point_t *point)
-{
-    cogl_path_move_to (closure,
-		       _cairo_cogl_util_fixed_to_float (point->x),
-		       _cairo_cogl_util_fixed_to_float (point->y));
-    return CAIRO_STATUS_SUCCESS;
-}
-
-static cairo_status_t
-_cogl_line_to (void		   *closure,
-	       const cairo_point_t *point)
-{
-    cogl_path_line_to (closure,
-		       _cairo_cogl_util_fixed_to_float (point->x),
-		       _cairo_cogl_util_fixed_to_float (point->y));
-    return CAIRO_STATUS_SUCCESS;
-}
-
-static cairo_status_t
-_cogl_curve_to (void                *closure,
-		const cairo_point_t *p0,
-		const cairo_point_t *p1,
-		const cairo_point_t *p2)
-{
-    cogl_path_curve_to (closure,
-			_cairo_cogl_util_fixed_to_float (p0->x),
-			_cairo_cogl_util_fixed_to_float (p0->y),
-			_cairo_cogl_util_fixed_to_float (p1->x),
-			_cairo_cogl_util_fixed_to_float (p1->y),
-			_cairo_cogl_util_fixed_to_float (p2->x),
-			_cairo_cogl_util_fixed_to_float (p2->y));
-    return CAIRO_STATUS_SUCCESS;
-}
-
-static cairo_status_t
-_cogl_close_path (void *closure)
-{
-    cogl_path_close (closure);
-    return CAIRO_STATUS_SUCCESS;
-}
-
-CoglPath *
-_cairo_cogl_util_path_from_cairo (const cairo_path_fixed_t *path,
-				  cairo_fill_rule_t fill_rule,
-				  float tolerance)
-{
-    CoglPath *cogl_path = cogl_path_new ();
-    cairo_status_t status;
-
-    if (fill_rule == CAIRO_FILL_RULE_EVEN_ODD)
-	cogl_path_set_fill_rule (cogl_path, COGL_PATH_FILL_RULE_EVEN_ODD);
-    else
-	cogl_path_set_fill_rule (cogl_path, COGL_PATH_FILL_RULE_NON_ZERO);
-
-#ifdef USE_CAIRO_PATH_FLATTENER
-    /* XXX: rely on cairo to do path flattening, since it seems Cogl's
-     * curve_to flattening is much slower */
-    status = _cairo_path_fixed_interpret_flat (path,
-					       _cogl_move_to,
-					       _cogl_line_to,
-					       _cogl_close_path,
-					       cogl_path,
-					       tolerance);
-#else
-    status = _cairo_path_fixed_interpret (path,
-					  _cogl_move_to,
-					  _cogl_line_to,
-					  _cogl_curve_to,
-					  _cogl_close_path,
-					  cogl_path);
-#endif
-
-    assert (status == CAIRO_STATUS_SUCCESS);
-    return cogl_path;
-}
-
-int
-_cairo_cogl_util_next_p2 (int a)
-{
-  int rval = 1;
-
-  while (rval < a)
-    rval <<= 1;
-
-  return rval;
-}
-
diff --git a/src/cairo-cogl.h b/src/cairo-cogl.h
index f270d74d3..b7a5b8e5c 100644
--- a/src/cairo-cogl.h
+++ b/src/cairo-cogl.h
@@ -33,8 +33,8 @@
  *      Robert Bragg <robert@linux.intel.com>
  */
 
-#ifndef CAIRO_VG_H
-#define CAIRO_VG_H
+#ifndef CAIRO_COGL_H
+#define CAIRO_COGL_H
 
 #include "cairo.h"
 
@@ -48,18 +48,35 @@ cairo_public cairo_device_t *
 cairo_cogl_device_create (CoglContext *context);
 
 cairo_public cairo_surface_t *
-cairo_cogl_surface_create (cairo_device_t *device,
-			   CoglFramebuffer *framebuffer);
+cairo_cogl_onscreen_surface_create (cairo_device_t *device,
+                                    cairo_content_t content,
+                                    int width, int height);
+
+cairo_public cairo_surface_t *
+cairo_cogl_offscreen_surface_create (cairo_device_t *device,
+                                     cairo_content_t content,
+                                     int width, int height);
+
+cairo_public cairo_surface_t *
+cairo_cogl_surface_create_for_fb (cairo_device_t  *device,
+                                  CoglFramebuffer *framebuffer,
+                                  cairo_content_t  content);
 
 cairo_public CoglFramebuffer *
 cairo_cogl_surface_get_framebuffer (cairo_surface_t *surface);
 
+/* If NPOT textures are not supported, the contents of interests may
+ * only be in the lowest-coordinate corner of the texture obtained from
+ * this function */
 cairo_public CoglTexture *
 cairo_cogl_surface_get_texture (cairo_surface_t *surface);
 
-cairo_public void
+cairo_public cairo_status_t
 cairo_cogl_surface_end_frame (cairo_surface_t *surface);
 
+cairo_public cairo_status_t
+cairo_cogl_surface_synchronize (cairo_surface_t *surface);
+
 CAIRO_END_DECLS
 
 #else  /* CAIRO_HAS_COGL_SURFACE*/
diff --git a/src/cairo-compiler-private.h b/src/cairo-compiler-private.h
index d982c101d..4562bea66 100644
--- a/src/cairo-compiler-private.h
+++ b/src/cairo-compiler-private.h
@@ -201,10 +201,12 @@
 #define hypot _hypot
 #define pclose _pclose
 #define popen _popen
-#define snprintf _snprintf
 #define strdup _strdup
 #define unlink _unlink
-#define vsnprintf _vsnprintf
+#if _MSC_VER < 1900
+  #define vsnprintf _vsnprintf
+  #define snprintf _snprintf
+#endif
 #endif
 
 #ifdef _MSC_VER
diff --git a/src/cairo-debug.c b/src/cairo-debug.c
index 760f092e3..6acdea9dd 100644
--- a/src/cairo-debug.c
+++ b/src/cairo-debug.c
@@ -94,10 +94,6 @@ cairo_debug_reset_static_data (void)
 
     _cairo_default_context_reset_static_data ();
 
-#if CAIRO_HAS_COGL_SURFACE
-    _cairo_cogl_context_reset_static_data ();
-#endif
-
     CAIRO_MUTEX_FINALIZE ();
 }
 
diff --git a/src/cairo-ft-font.c b/src/cairo-ft-font.c
index fea489d01..c22da6f95 100644
--- a/src/cairo-ft-font.c
+++ b/src/cairo-ft-font.c
@@ -370,6 +370,8 @@ _cairo_ft_unscaled_font_map_destroy (void)
 static cairo_ft_unscaled_font_map_t *
 _cairo_ft_unscaled_font_map_lock (void)
 {
+    CAIRO_MUTEX_INITIALIZE ();
+
     CAIRO_MUTEX_LOCK (_cairo_ft_unscaled_font_map_mutex);
 
     if (unlikely (cairo_ft_unscaled_font_map == NULL)) {
@@ -459,6 +461,11 @@ _cairo_ft_unscaled_font_init (cairo_ft_unscaled_font_t *unscaled,
 		unscaled->variations = calloc (ft_mm_var->num_axis, sizeof (FT_Fixed));
 		if (unscaled->variations)
 		    FT_Get_Var_Design_Coordinates (face, ft_mm_var->num_axis, unscaled->variations);
+#if HAVE_FT_DONE_MM_VAR
+		FT_Done_MM_Var (face->glyph->library, ft_mm_var);
+#else
+		free (ft_mm_var);
+#endif
 	    }
 	}
 #endif
@@ -976,7 +983,7 @@ _compute_xrender_bitmap_size(FT_Bitmap      *target,
 	pitch = width * 4;
 	break;
 
-#ifdef FT_PIXEL_MODE_BGRA
+#ifdef FT_LOAD_COLOR
     case FT_PIXEL_MODE_BGRA:
 	/* each pixel is replicated into a 32-bit ARGB value */
 	pitch = width * 4;
@@ -1179,7 +1186,7 @@ _fill_xrender_bitmap(FT_Bitmap      *target,
 	}
 	break;
 
-#ifdef FT_PIXEL_MODE_BGRA
+#ifdef FT_LOAD_COLOR
     case FT_PIXEL_MODE_BGRA:
 	for (h = height; h > 0; h--, srcLine += src_pitch, dstLine += pitch)
 	    memcpy (dstLine, srcLine, width * 4);
@@ -1293,7 +1300,7 @@ _get_bitmap_surface (FT_Bitmap		     *bitmap,
 	    component_alpha = TRUE;
 	}
 	break;
-#ifdef FT_PIXEL_MODE_BGRA
+#ifdef FT_LOAD_COLOR
     case FT_PIXEL_MODE_BGRA:
 	stride = width * 4;
 	if (own_buffer) {
@@ -2455,6 +2462,15 @@ _cairo_ft_scaled_glyph_load_glyph (cairo_ft_scaled_font_t *scaled_font,
     if (vertical_layout)
 	_cairo_ft_scaled_glyph_vertical_layout_bearing_fix (scaled_font, face->glyph);
 
+    if (face->glyph->format == FT_GLYPH_FORMAT_OUTLINE) {
+        FT_Pos xshift, yshift;
+
+        xshift = _cairo_scaled_glyph_xphase (scaled_glyph) << 4;
+        yshift = _cairo_scaled_glyph_yphase (scaled_glyph) << 4;
+
+        FT_Outline_Translate (&face->glyph->outline, xshift, -yshift);
+    }
+
     return CAIRO_STATUS_SUCCESS;
 }
 
diff --git a/src/cairo-gl-shaders.c b/src/cairo-gl-shaders.c
index c43cf3b18..f789ae1d9 100644
--- a/src/cairo-gl-shaders.c
+++ b/src/cairo-gl-shaders.c
@@ -203,6 +203,7 @@ _cairo_gl_context_fini_shaders (cairo_gl_context_t *ctx)
 	    ctx->dispatch.DeleteShader (ctx->vertex_shaders[i]);
     }
 
+    _cairo_gl_shader_fini(ctx, &ctx->fill_rectangles_shader);
     _cairo_cache_fini (&ctx->shaders);
 }
 
diff --git a/src/cairo-image-compositor.c b/src/cairo-image-compositor.c
index 434f67e59..79ad69f68 100644
--- a/src/cairo-image-compositor.c
+++ b/src/cairo-image-compositor.c
@@ -841,12 +841,15 @@ _cairo_image_scaled_glyph_fini (cairo_scaled_font_t *scaled_font,
     if (global_glyph_cache) {
 	pixman_glyph_cache_remove (
 	    global_glyph_cache, scaled_font,
-	    (void *)_cairo_scaled_glyph_index (scaled_glyph));
+	    (void *)scaled_glyph->hash_entry.hash);
     }
 
     CAIRO_MUTEX_UNLOCK (_cairo_glyph_cache_mutex);
 }
 
+#define PHASE(x) ((int)(floor (4 * (x + 0.125)) - 4 * floor (x + 0.125)))
+#define POSITION(x) ((int) floor (x + 0.125))
+
 static cairo_int_status_t
 composite_glyphs (void				*_dst,
 		  cairo_operator_t		 op,
@@ -888,6 +891,12 @@ composite_glyphs (void				*_dst,
     for (i = 0; i < info->num_glyphs; i++) {
 	unsigned long index = info->glyphs[i].index;
 	const void *glyph;
+        int xphase, yphase;
+
+        xphase = PHASE(info->glyphs[i].x);
+        yphase = PHASE(info->glyphs[i].y);
+
+	index = index | (xphase << 24) | (yphase << 26);
 
 	glyph = pixman_glyph_cache_lookup (glyph_cache, info->font, (void *)index);
 	if (!glyph) {
@@ -917,8 +926,8 @@ composite_glyphs (void				*_dst,
 	    }
 	}
 
-	pg->x = _cairo_lround (info->glyphs[i].x);
-	pg->y = _cairo_lround (info->glyphs[i].y);
+	pg->x = POSITION (info->glyphs[i].x);
+	pg->y = POSITION (info->glyphs[i].y);
 	pg->glyph = glyph;
 	pg++;
     }
diff --git a/src/cairo-misc.c b/src/cairo-misc.c
index 2f551ee27..81f9325ca 100644
--- a/src/cairo-misc.c
+++ b/src/cairo-misc.c
@@ -38,10 +38,13 @@
  *      Adrian Johnson <ajohnson@redneon.com>
  */
 
+#define _GNU_SOURCE 1	/* strtod_l() */
+
 #include "cairoint.h"
 #include "cairo-error-private.h"
 
 #include <stdio.h>
+#include <stdlib.h>
 #include <errno.h>
 #include <locale.h>
 #ifdef HAVE_XLOCALE_H
diff --git a/src/cairo-paginated-surface.c b/src/cairo-paginated-surface.c
index 612cb5dfb..6b35c1f92 100644
--- a/src/cairo-paginated-surface.c
+++ b/src/cairo-paginated-surface.c
@@ -780,7 +780,7 @@ static const cairo_surface_backend_t cairo_paginated_surface_backend = {
     _cairo_paginated_context_create,
 
     _cairo_paginated_surface_create_similar,
-    NULL, /* create siimlar image */
+    NULL, /* create similar image */
     NULL, /* map to image */
     NULL, /* unmap image */
 
diff --git a/src/cairo-qt-surface.cpp b/src/cairo-qt-surface.cpp
index 5f669d8be..d276f059e 100644
--- a/src/cairo-qt-surface.cpp
+++ b/src/cairo-qt-surface.cpp
@@ -1539,7 +1539,8 @@ cairo_qt_surface_create (QPainter *painter)
     _cairo_surface_init (&qs->base,
 			 &cairo_qt_surface_backend,
 			 NULL, /* device */
-			 CAIRO_CONTENT_COLOR_ALPHA);
+			 CAIRO_CONTENT_COLOR_ALPHA,
+			 FALSE); /* is_vector */
 
     _cairo_surface_clipper_init (&qs->clipper,
 				 _cairo_qt_surface_clipper_intersect_clip_path);
@@ -1578,7 +1579,8 @@ cairo_qt_surface_create_with_qimage (cairo_format_t format,
     _cairo_surface_init (&qs->base,
 			 &cairo_qt_surface_backend,
 			 NULL, /* device */
-			 _cairo_content_from_format (format));
+			 _cairo_content_from_format (format),
+			 FALSE); /* is_vector */
 
     _cairo_surface_clipper_init (&qs->clipper,
 				 _cairo_qt_surface_clipper_intersect_clip_path);
@@ -1639,7 +1641,8 @@ cairo_qt_surface_create_with_qpixmap (cairo_content_t content,
     _cairo_surface_init (&qs->base,
 			 &cairo_qt_surface_backend,
 			 NULL, /* device */
-			 content);
+			 content,
+			 FALSE); /* is_vector */
 
     _cairo_surface_clipper_init (&qs->clipper,
 				 _cairo_qt_surface_clipper_intersect_clip_path);
diff --git a/src/cairo-script-surface.c b/src/cairo-script-surface.c
index c31900aa2..4d7778b99 100644
--- a/src/cairo-script-surface.c
+++ b/src/cairo-script-surface.c
@@ -1839,7 +1839,7 @@ _emit_path_boxes (cairo_script_surface_t *surface,
 {
     cairo_script_context_t *ctx = to_context (surface);
     cairo_path_fixed_iter_t iter;
-    cairo_status_t status;
+    cairo_status_t status = CAIRO_STATUS_SUCCESS;
     struct _cairo_boxes_chunk *chunk;
     cairo_boxes_t boxes;
     cairo_box_t box;
diff --git a/src/cairo-surface.c b/src/cairo-surface.c
index 596ca250d..86df1272e 100644
--- a/src/cairo-surface.c
+++ b/src/cairo-surface.c
@@ -1046,8 +1046,8 @@ _cairo_surface_finish (cairo_surface_t *surface)
  * external resources.  For example, for the Xlib backend it means
  * that cairo will no longer access the drawable, which can be freed.
  * After calling cairo_surface_finish() the only valid operations on a
- * surface are getting and setting user, referencing and
- * destroying, and flushing and finishing it.
+ * surface are checking status, getting and setting user, referencing
+ * and destroying, and flushing and finishing it.
  * Further drawing to the surface will not affect the
  * surface but will instead trigger a %CAIRO_STATUS_SURFACE_FINISHED
  * error.
@@ -1949,7 +1949,7 @@ slim_hidden_def (cairo_surface_get_device_offset);
  * there is currently no way to have more than one fallback resolution
  * in effect on a single page.
  *
- * The default fallback resoultion is 300 pixels per inch in both
+ * The default fallback resolution is 300 pixels per inch in both
  * dimensions.
  *
  * Since: 1.2
@@ -2820,6 +2820,7 @@ _cairo_surface_show_text_glyphs (cairo_surface_t	    *surface,
 				 const cairo_clip_t		*clip)
 {
     cairo_int_status_t status;
+    char *utf8_copy = NULL;
 
     TRACE ((stderr, "%s\n", __FUNCTION__));
     if (unlikely (surface->status))
@@ -2847,6 +2848,10 @@ _cairo_surface_show_text_glyphs (cairo_surface_t	    *surface,
     status = CAIRO_INT_STATUS_UNSUPPORTED;
 
     if (_cairo_scaled_font_has_color_glyphs (scaled_font)) {
+        utf8_copy = malloc (sizeof (char) * utf8_len);
+        memcpy (utf8_copy, utf8, sizeof (char) * utf8_len);
+        utf8 = utf8_copy;
+
         status = composite_color_glyphs (surface, op,
                                          source,
                                          (char *)utf8, &utf8_len,
@@ -2861,6 +2866,8 @@ _cairo_surface_show_text_glyphs (cairo_surface_t	    *surface,
         if (num_glyphs == 0)
             goto DONE;
     }
+    else
+      utf8_copy = NULL;
 
     /* The logic here is duplicated in _cairo_analysis_surface show_glyphs and
      * show_text_glyphs.  Keep in synch. */
@@ -2918,6 +2925,9 @@ DONE:
 	surface->serial++;
     }
 
+    if (utf8_copy)
+        free (utf8_copy);
+
     return _cairo_surface_set_error (surface, status);
 }
 
@@ -2952,6 +2962,7 @@ _cairo_surface_tag (cairo_surface_t	        *surface,
     status = surface->backend->tag (surface, begin, tag_name, attributes,
 				    source, stroke_style,
 				    ctm, ctm_inverse, clip);
+    surface->is_clear = FALSE;
 
     return _cairo_surface_set_error (surface, status);
 }
diff --git a/src/cairo-tor22-scan-converter.c b/src/cairo-tor22-scan-converter.c
index bf44742b0..79c858e4e 100644
--- a/src/cairo-tor22-scan-converter.c
+++ b/src/cairo-tor22-scan-converter.c
@@ -1287,12 +1287,15 @@ glitter_scan_converter_reset(
 			     int xmax, int ymax)
 {
     glitter_status_t status;
+    int max_num_spans;
 
     converter->xmin = 0; converter->xmax = 0;
     converter->ymin = 0; converter->ymax = 0;
 
-    if (xmax - xmin > ARRAY_LENGTH(converter->spans_embedded)) {
-	converter->spans = _cairo_malloc_ab (xmax - xmin,
+    max_num_spans = xmax - xmin + 1;
+
+    if (max_num_spans > ARRAY_LENGTH(converter->spans_embedded)) {
+	converter->spans = _cairo_malloc_ab (max_num_spans,
 					     sizeof (cairo_half_open_span_t));
 	if (unlikely (converter->spans == NULL))
 	    return _cairo_error (CAIRO_STATUS_NO_MEMORY);
diff --git a/src/cairo-xlib-render-compositor.c b/src/cairo-xlib-render-compositor.c
index 0db59a8a6..bce0ff6db 100644
--- a/src/cairo-xlib-render-compositor.c
+++ b/src/cairo-xlib-render-compositor.c
@@ -1074,8 +1074,7 @@ _cairo_xlib_glyph_fini (cairo_scaled_glyph_private_t *glyph_private,
 	    to_free->count = 0;
 	}
 
-	to_free->indices[to_free->count++] =
-	    _cairo_scaled_glyph_index (glyph);
+	to_free->indices[to_free->count++] = glyph->hash_entry.hash;
     }
 
     cairo_list_del (&glyph_private->link);
@@ -1193,7 +1192,7 @@ _cairo_xlib_surface_add_glyph (cairo_xlib_display_t *display,
     cairo_bool_t already_had_glyph_surface;
     cairo_xlib_font_glyphset_t *info;
 
-    glyph_index = _cairo_scaled_glyph_index (glyph);
+    glyph_index = glyph->hash_entry.hash;
 
     /* check to see if we have a pending XRenderFreeGlyph for this glyph */
     info = find_pending_free_glyph (display, font, glyph_index, glyph_surface);
@@ -1570,6 +1569,9 @@ check_composite_glyphs (const cairo_composite_rectangles_t *extents,
  * enough room for padding */
 #define _cairo_sz_xGlyphElt (sz_xGlyphElt + 4)
 
+#define PHASE(x) ((int)(floor (4 * (x + 0.125)) - 4 * floor (x + 0.125)))
+#define POSITION(x) ((int) floor (x + 0.125))
+
 static cairo_int_status_t
 composite_glyphs (void				*surface,
 		  cairo_operator_t		 op,
@@ -1605,9 +1607,15 @@ composite_glyphs (void				*surface,
     op = _render_operator (op),
     _cairo_xlib_surface_ensure_picture (dst);
     for (i = 0; i < num_glyphs; i++) {
+        int xphase, yphase;
 	int this_x, this_y;
 	int old_width;
 
+        xphase = PHASE(glyphs[i].d.x);
+        yphase = PHASE(glyphs[i].d.y);
+
+        glyphs[i].index |= (xphase << 24) | (yphase << 26);
+
 	status = _cairo_scaled_glyph_lookup (info->font,
 					     glyphs[i].index,
 					     CAIRO_SCALED_GLYPH_INFO_METRICS,
@@ -1615,8 +1623,8 @@ composite_glyphs (void				*surface,
 	if (unlikely (status))
 	    return status;
 
-	this_x = _cairo_lround (glyphs[i].d.x);
-	this_y = _cairo_lround (glyphs[i].d.y);
+	this_x = POSITION (glyphs[i].d.x);
+	this_y = POSITION (glyphs[i].d.y);
 
 	/* Send unsent glyphs to the server */
 	if (glyph->dev_private_key != display) {
diff --git a/src/cairo-xml-surface.c b/src/cairo-xml-surface.c
index 35773a2b2..43cb6dddf 100644
--- a/src/cairo-xml-surface.c
+++ b/src/cairo-xml-surface.c
@@ -1007,7 +1007,7 @@ _cairo_xml_emit_scaled_font (cairo_xml_t *xml,
     }
 
     _cairo_xml_indent (xml, -2);
-    _cairo_xml_printf (xml, "<scaled-font>");
+    _cairo_xml_printf (xml, "</scaled-font>");
 
     return status;
 }
diff --git a/src/cairo.h b/src/cairo.h
index 079defd88..96427b425 100644
--- a/src/cairo.h
+++ b/src/cairo.h
@@ -405,8 +405,8 @@ typedef enum _cairo_content {
  *   with red in the upper 5 bits, then green in the middle
  *   6 bits, and blue in the lower 5 bits. (Since 1.2)
  * @CAIRO_FORMAT_RGB30: like RGB24 but with 10bpc. (Since 1.12)
- * @CAIRO_FORMAT_RGB96F: 3 floats, R, G, B. (Since 1.16)
- * @CAIRO_FORMAT_RGBA128F: 4 floats, R, G, B, A. (Since 1.16)
+ * @CAIRO_FORMAT_RGB96F: 3 floats, R, G, B. (Since 1.17.2)
+ * @CAIRO_FORMAT_RGBA128F: 4 floats, R, G, B, A. (Since 1.17.2)
  *
  * #cairo_format_t is used to identify the memory format of
  * image data.
diff --git a/src/cairoint.h b/src/cairoint.h
index 29b844d3a..7c1000556 100644
--- a/src/cairoint.h
+++ b/src/cairoint.h
@@ -428,7 +428,10 @@ _cairo_hash_bytes (unsigned long hash,
 		   const void *bytes,
 		   unsigned int length);
 
-#define _cairo_scaled_glyph_index(g) ((g)->hash_entry.hash)
+/* We use bits 24-27 to store phases for subpixel positions */
+#define _cairo_scaled_glyph_index(g) ((g)->hash_entry.hash & 0xffffff)
+#define _cairo_scaled_glyph_xphase(g) (int)(((g)->hash_entry.hash >> 24) & 3)
+#define _cairo_scaled_glyph_yphase(g) (int)(((g)->hash_entry.hash >> 26) & 3)
 #define _cairo_scaled_glyph_set_index(g, i)  ((g)->hash_entry.hash = (i))
 
 #include "cairo-scaled-font-private.h"
diff --git a/src/meson.build b/src/meson.build
new file mode 100644
index 000000000..f65ab0e8d
--- /dev/null
+++ b/src/meson.build
@@ -0,0 +1,320 @@
+cairo_sources = [
+  'cairo-analysis-surface.c',
+  'cairo-arc.c',
+  'cairo-array.c',
+  'cairo-atomic.c',
+  'cairo-base64-stream.c',
+  'cairo-base85-stream.c',
+  'cairo-bentley-ottmann-rectangular.c',
+  'cairo-bentley-ottmann-rectilinear.c',
+  'cairo-bentley-ottmann.c',
+  'cairo-botor-scan-converter.c',
+  'cairo-boxes-intersect.c',
+  'cairo-boxes.c',
+  'cairo-cache.c',
+  'cairo-clip-boxes.c',
+  'cairo-clip-polygon.c',
+  'cairo-clip-region.c',
+  'cairo-clip-surface.c',
+  'cairo-clip-tor-scan-converter.c',
+  'cairo-clip.c',
+  'cairo-color.c',
+  'cairo-composite-rectangles.c',
+  'cairo-compositor.c',
+  'cairo-contour.c',
+  'cairo-damage.c',
+  'cairo-debug.c',
+  'cairo-default-context.c',
+  'cairo-device.c',
+  'cairo-error.c',
+  'cairo-fallback-compositor.c',
+  'cairo-fixed.c',
+  'cairo-font-face-twin-data.c',
+  'cairo-font-face-twin.c',
+  'cairo-font-face.c',
+  'cairo-font-options.c',
+  'cairo-freed-pool.c',
+  'cairo-freelist.c',
+  'cairo-gstate.c',
+  'cairo-hash.c',
+  'cairo-hull.c',
+  'cairo-image-compositor.c',
+  'cairo-image-info.c',
+  'cairo-image-source.c',
+  'cairo-image-surface.c',
+  'cairo-line.c',
+  'cairo-lzw.c',
+  'cairo-mask-compositor.c',
+  'cairo-matrix.c',
+  'cairo-mempool.c',
+  'cairo-mesh-pattern-rasterizer.c',
+  'cairo-misc.c',
+  'cairo-mono-scan-converter.c',
+  'cairo-mutex.c',
+  'cairo-no-compositor.c',
+  'cairo-observer.c',
+  'cairo-output-stream.c',
+  'cairo-paginated-surface.c',
+  'cairo-path-bounds.c',
+  'cairo-path-fill.c',
+  'cairo-path-fixed.c',
+  'cairo-path-in-fill.c',
+  'cairo-path-stroke-boxes.c',
+  'cairo-path-stroke-polygon.c',
+  'cairo-path-stroke-traps.c',
+  'cairo-path-stroke-tristrip.c',
+  'cairo-path-stroke.c',
+  'cairo-path.c',
+  'cairo-pattern.c',
+  'cairo-pen.c',
+  'cairo-polygon-intersect.c',
+  'cairo-polygon-reduce.c',
+  'cairo-polygon.c',
+  'cairo-raster-source-pattern.c',
+  'cairo-recording-surface.c',
+  'cairo-rectangle.c',
+  'cairo-rectangular-scan-converter.c',
+  'cairo-region.c',
+  'cairo-rtree.c',
+  'cairo-scaled-font.c',
+  'cairo-shape-mask-compositor.c',
+  'cairo-slope.c',
+  'cairo-spans-compositor.c',
+  'cairo-spans.c',
+  'cairo-spline.c',
+  'cairo-stroke-dash.c',
+  'cairo-stroke-style.c',
+  'cairo-surface-clipper.c',
+  'cairo-surface-fallback.c',
+  'cairo-surface-observer.c',
+  'cairo-surface-offset.c',
+  'cairo-surface-snapshot.c',
+  'cairo-surface-subsurface.c',
+  'cairo-surface-wrapper.c',
+  'cairo-surface.c',
+  'cairo-time.c',
+  'cairo-tor-scan-converter.c',
+  'cairo-tor22-scan-converter.c',
+  'cairo-toy-font-face.c',
+  'cairo-traps-compositor.c',
+  'cairo-traps.c',
+  'cairo-tristrip.c',
+  'cairo-unicode.c',
+  'cairo-user-font.c',
+  'cairo-version.c',
+  'cairo-wideint.c',
+  'cairo.c',
+  'cairo-cff-subset.c',
+  'cairo-scaled-font-subsets.c',
+  'cairo-truetype-subset.c',
+  'cairo-type1-fallback.c',
+  'cairo-type1-glyph-names.c',
+  'cairo-type1-subset.c',
+  'cairo-type3-glyph-surface.c',
+  'cairo-pdf-operators.c',
+  'cairo-pdf-shading.c',
+  'cairo-tag-attributes.c',
+  'cairo-deflate-stream.c',
+]
+
+cairo_headers = [
+  'cairo.h',
+  'cairo-deprecated.h',
+]
+
+cairo_feature_sources = {
+  'cairo-png': [
+    'cairo-png.c',
+  ],
+  'cairo-ft': [
+    'cairo-ft-font.c',
+  ],
+
+  'cairo-xlib': [
+    'cairo-xlib-display.c',
+    'cairo-xlib-core-compositor.c',
+    'cairo-xlib-fallback-compositor.c',
+    'cairo-xlib-render-compositor.c',
+    'cairo-xlib-screen.c',
+    'cairo-xlib-source.c',
+    'cairo-xlib-surface.c',
+    'cairo-xlib-surface-shm.c',
+    'cairo-xlib-visual.c',
+    'cairo-xlib-xcb-surface.c',
+  ],
+  'cairo-xcb': [
+    'cairo-xcb-connection.c',
+    'cairo-xcb-connection-core.c',
+    'cairo-xcb-connection-render.c',
+    'cairo-xcb-connection-shm.c',
+    'cairo-xcb-screen.c',
+    'cairo-xcb-shm.c',
+    'cairo-xcb-surface.c',
+    'cairo-xcb-surface-core.c',
+    'cairo-xcb-surface-render.c',
+    'cairo-xcb-resources.c',
+  ],
+  'cairo-qt': [
+    'cairo-qt-surface.cpp',
+  ],
+  'cairo-quartz': [
+    'cairo-quartz-surface.c',
+  ],
+  'cairo-quartz-image': [
+    'cairo-quartz-image-surface.c',
+  ],
+  'cairo-quartz-font': [
+    'cairo-quartz-font.c',
+  ],
+  'cairo-win32': [
+    'win32/cairo-win32-debug.c',
+    'win32/cairo-win32-device.c',
+    'win32/cairo-win32-gdi-compositor.c',
+    'win32/cairo-win32-system.c',
+    'win32/cairo-win32-surface.c',
+    'win32/cairo-win32-display-surface.c',
+    'win32/cairo-win32-printing-surface.c',
+  ],
+  'cairo-win32-font': [
+    'win32/cairo-win32-font.c',
+  ],
+  'cairo-drm': [
+    'drm/cairo-drm.c',
+    'drm/cairo-drm-bo.c',
+    'drm/cairo-drm-surface.c',
+    'drm/cairo-drm-intel.c',
+    'drm/cairo-drm-intel-debug.c',
+    'drm/cairo-drm-intel-surface.c',
+    'drm/cairo-drm-i915-surface.c',
+    'drm/cairo-drm-i915-glyphs.c',
+    'drm/cairo-drm-i915-shader.c',
+    'drm/cairo-drm-i915-spans.c',
+    'drm/cairo-drm-i965-surface.c',
+    'drm/cairo-drm-i965-glyphs.c',
+    'drm/cairo-drm-i965-shader.c',
+    'drm/cairo-drm-i965-spans.c',
+    'drm/cairo-drm-intel-brw-eu.c',
+    'drm/cairo-drm-intel-brw-eu-emit.c',
+    'drm/cairo-drm-intel-brw-eu-util.c',
+    'drm/cairo-drm-radeon.c',
+    'drm/cairo-drm-radeon-surface.c',
+  ],
+  'cairo-gl': [
+    'cairo-gl-composite.c',
+    'cairo-gl-device.c',
+    'cairo-gl-dispatch.c',
+    'cairo-gl-glyphs.c',
+    'cairo-gl-gradient.c',
+    'cairo-gl-info.c',
+    'cairo-gl-msaa-compositor.c',
+    'cairo-gl-operand.c',
+    'cairo-gl-shaders.c',
+    'cairo-gl-source.c',
+    'cairo-gl-spans-compositor.c',
+    'cairo-gl-surface.c',
+    'cairo-gl-traps-compositor.c',
+  ],
+  'cairo-cogl': [
+    'cairo-cogl-surface.c',
+    'cairo-cogl-gradient.c',
+  ],
+  'cairo-directfb': [
+    'cairo-directfb-surface.c',
+  ],
+  'cairo-vg': [
+    'cairo-vg-surface.c',
+  ],
+  'cairo-script': [
+    'cairo-script-surface.c',
+  ],
+  'cairo-ps': [
+    'cairo-ps-surface.c',
+  ],
+  'cairo-pdf': [
+    'cairo-pdf-surface.c',
+    'cairo-pdf-interchange.c',
+    'cairo-tag-stack.c',
+  ],
+  'cairo-svg': [
+    'cairo-svg-surface.c',
+  ],
+  'cairo-egl': [
+    'cairo-egl-context.c',
+  ],
+  'cairo-glx': [
+    'cairo-glx-context.c',
+  ],
+  'cairo-wgl': [
+    'cairo-wgl-context.c',
+  ],
+  'cairo-xml': [
+    'cairo-xml-surface.c',
+  ],
+  'cairo-tee': [
+    'cairo-tee-surface.c',
+  ],
+}
+
+cairo_feature_headers = {
+  'cairo-ps': ['cairo-ps.h'],
+  'cairo-pdf': ['cairo-pdf.h'],
+  'cairo-svg': ['cairo-svg.h'],
+  'cairo-ft': ['cairo-ft.h'],
+  'cairo-xlib': ['cairo-xlib.h'],
+  'cairo-xlib-xrender': ['cairo-xlib-xrender.h'],
+  'cairo-xcb': ['cairo-xcb.h'],
+  'cairo-qt': ['cairo-qt.h'],
+  'cairo-quartz': ['cairo-quartz.h'],
+  'cairo-quartz-image': ['cairo-quartz-image.h'],
+  'cairo-win32': ['cairo-win32.h'],
+  'cairo-gl': ['cairo-gl.h'],
+  'cairo-directfb': ['cairo-directfb.h'],
+  'cairo-drm': ['cairo-drm.h'],
+  'cairo-script': ['cairo-script.h'],
+  'cairo-tee': ['cairo-tee.h'],
+  'cairo-xml': ['cairo-xml.h'],
+  'cairo-vg': ['cairo-vg.h'],
+  'cairo-cogl': ['cairo-cogl.h'],
+}
+
+cairo_no_warn_c_args = cc.get_supported_arguments([
+  '-Wno-attributes',
+  '-Wno-unused-but-set-variable',
+  '-Wno-missing-field-initializers',
+  '-Wno-unused-parameter',
+  '-Wno-long-long',
+])
+
+foreach feature: built_features
+  source_key = feature.get('source-key', feature.get('name'))
+  cairo_sources += cairo_feature_sources.get(source_key, [])
+  cairo_headers += cairo_feature_headers.get(source_key, [])
+endforeach
+
+incsrc = include_directories('.')
+
+libcairo = library('cairo', cairo_sources,
+  dependencies: deps,
+  c_args: cairo_no_warn_c_args + pthread_c_args + ['-DHAVE_CONFIG_H'],
+  cpp_args: cairo_no_warn_c_args + pthread_c_args + ['-DHAVE_CONFIG_H'],
+  link_args: extra_link_args,
+  soversion: '2',
+  version: '2.' + ''.join(meson.project_version().split('.')) + '.0',
+  install: true,
+  include_directories: incbase,
+)
+
+cairo_headers += [configure_file(output: 'cairo-features.h', configuration: feature_conf)]
+
+libcairo_dep = declare_dependency(link_with: libcairo,
+  include_directories: incbase)
+
+pkgmod.generate(libcairo,
+  description: 'Multi-platform 2D graphics library',
+  subdirs: [meson.project_name()],
+  version: meson.project_version(),
+)
+
+install_headers(cairo_headers, subdir: 'cairo')
+
+libcairo_dep = declare_dependency(link_with: libcairo, include_directories: incsrc)
diff --git a/subprojects/.gitignore b/subprojects/.gitignore
new file mode 100644
index 000000000..0cd778d45
--- /dev/null
+++ b/subprojects/.gitignore
@@ -0,0 +1,11 @@
+/expat-2.2.5
+/freetype2
+/glib
+/gperf
+/fontconfig
+/libffi
+/proxy-libintl
+/zlib-*
+/packagecache
+/pixman
+/libpng*
diff --git a/subprojects/expat.wrap b/subprojects/expat.wrap
new file mode 100644
index 000000000..0b7c53e54
--- /dev/null
+++ b/subprojects/expat.wrap
@@ -0,0 +1,10 @@
+[wrap-file]
+directory = expat-2.2.5
+
+source_url = https://github.com/libexpat/libexpat/releases/download/R_2_2_5/expat-2.2.5.tar.bz2
+source_filename = expat-2.2.5.tar.bz2
+source_hash = d9dc32efba7e74f788fcc4f212a43216fc37cf5f23f4c2339664d473353aedf6
+
+patch_url = https://wrapdb.mesonbuild.com/v1/projects/expat/2.2.5/4/get_zip
+patch_filename = expat-2.2.5-4-wrap.zip
+patch_hash = 25748839be2bbdd2ff586d1a05aa6fc37aeada75c78416df6e8347a6321abaac
diff --git a/subprojects/fontconfig.wrap b/subprojects/fontconfig.wrap
new file mode 100644
index 000000000..632933d70
--- /dev/null
+++ b/subprojects/fontconfig.wrap
@@ -0,0 +1,5 @@
+[wrap-git]
+directory=fontconfig
+url=https://gitlab.freedesktop.org/fontconfig/fontconfig.git
+push-url=git@gitlab.freedesktop.org:fontconfig/fontconfig.git
+revision=master
diff --git a/subprojects/freetype2.wrap b/subprojects/freetype2.wrap
new file mode 100644
index 000000000..3151539c8
--- /dev/null
+++ b/subprojects/freetype2.wrap
@@ -0,0 +1,5 @@
+[wrap-git]
+directory=freetype2
+url=https://github.com/centricular/freetype2.git
+push-url=git@github.com:centricular/freetype2.git
+revision=meson
diff --git a/subprojects/glib.wrap b/subprojects/glib.wrap
new file mode 100644
index 000000000..3964b1c25
--- /dev/null
+++ b/subprojects/glib.wrap
@@ -0,0 +1,5 @@
+[wrap-git]
+directory=glib
+url=https://gitlab.gnome.org/GNOME/glib.git
+push-url=git@gitlab.gnome.org:GNOME/glib.git
+revision=2.64.4
diff --git a/subprojects/gperf.wrap b/subprojects/gperf.wrap
new file mode 100644
index 000000000..748973312
--- /dev/null
+++ b/subprojects/gperf.wrap
@@ -0,0 +1,5 @@
+[wrap-git]
+directory=gperf
+url=https://gitlab.freedesktop.org/tpm/gperf.git
+push-url=https://gitlab.freedesktop.org/tpm/gperf.git
+revision=meson
diff --git a/subprojects/libffi.wrap b/subprojects/libffi.wrap
new file mode 100644
index 000000000..6dea9ebed
--- /dev/null
+++ b/subprojects/libffi.wrap
@@ -0,0 +1,4 @@
+[wrap-git]
+directory=libffi
+url=https://gitlab.freedesktop.org/gstreamer/meson-ports/libffi.git
+revision=meson
diff --git a/subprojects/libpng.wrap b/subprojects/libpng.wrap
new file mode 100644
index 000000000..30774eb72
--- /dev/null
+++ b/subprojects/libpng.wrap
@@ -0,0 +1,10 @@
+[wrap-file]
+directory = libpng-1.6.35
+
+source_url = https://github.com/glennrp/libpng/archive/v1.6.35.tar.gz
+source_filename = libpng-1.6.35.tar.gz
+source_hash = 6d59d6a154ccbb772ec11772cb8f8beb0d382b61e7ccc62435bf7311c9f4b210
+
+patch_url = https://wrapdb.mesonbuild.com/v1/projects/libpng/1.6.35/5/get_zip
+patch_filename = libpng-1.6.35-5-wrap.zip
+patch_hash = da42b18e8d75a88615bdbc1c7bbf1f739ae19f63a8e70d96c90bc448326ae6b7
diff --git a/subprojects/pixman.wrap b/subprojects/pixman.wrap
new file mode 100644
index 000000000..71d585829
--- /dev/null
+++ b/subprojects/pixman.wrap
@@ -0,0 +1,5 @@
+[wrap-git]
+directory=pixman
+url=https://gitlab.freedesktop.org/pixman/pixman.git
+push-url=git@gitlab.freedesktop.org:pixman/pixman.git
+revision=master
diff --git a/subprojects/proxy-libintl.wrap b/subprojects/proxy-libintl.wrap
new file mode 100644
index 000000000..b53c8f7c3
--- /dev/null
+++ b/subprojects/proxy-libintl.wrap
@@ -0,0 +1,4 @@
+[wrap-git]
+directory=proxy-libintl
+url=https://github.com/frida/proxy-libintl.git
+revision=0.1
diff --git a/subprojects/zlib.wrap b/subprojects/zlib.wrap
new file mode 100644
index 000000000..ff9ab6680
--- /dev/null
+++ b/subprojects/zlib.wrap
@@ -0,0 +1,10 @@
+[wrap-file]
+directory = zlib-1.2.11
+
+source_url = https://zlib.net/fossils/zlib-1.2.11.tar.gz
+source_filename = zlib-1.2.11.tar.gz
+source_hash = c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1
+
+patch_url = https://github.com/mesonbuild/zlib/releases/download/1.2.11-3/zlib.zip
+patch_filename = zlib-1.2.11-3-wrap.zip
+patch_hash = f07dc491ab3d05daf00632a0591e2ae61b470615b5b73bcf9b3f061fff65cff0
diff --git a/test/Makefile.am b/test/Makefile.am
index d69012b65..8e271fe9b 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -11,8 +11,9 @@ test_sources += $(pthread_test_sources)
 endif
 
 if CAIRO_HAS_FT_FONT
-if CAIRO_HAS_FC_FONT
 test_sources += $(ft_font_test_sources)
+if CAIRO_HAS_FC_FONT
+test_sources += $(fc_font_test_sources)
 endif
 endif
 
diff --git a/test/Makefile.sources b/test/Makefile.sources
index c47131faf..7eb73647f 100644
--- a/test/Makefile.sources
+++ b/test/Makefile.sources
@@ -26,6 +26,7 @@ test_sources = \
 	bilevel-image.c					\
 	bug-40410.c					\
 	bug-51910.c					\
+	bug-75705.c					\
 	bug-84115.c					\
 	bug-bo-rectangular.c				\
 	bug-bo-collins.c				\
@@ -144,7 +145,6 @@ test_sources = \
 	font-face-get-type.c				\
 	font-matrix-translation.c			\
 	font-options.c					\
-	font-variations.c				\
 	glyph-cache-pressure.c				\
 	get-and-set.c					\
 	get-clip.c					\
@@ -356,6 +356,7 @@ test_sources = \
 	text-glyph-range.c				\
 	text-pattern.c					\
 	text-rotate.c					\
+	text-subpixel.c					\
 	text-transform.c				\
 	text-unhinted-metrics.c				\
 	text-zero-len.c					\
@@ -398,6 +399,9 @@ pthread_test_sources =					\
 	$(NULL)
 
 ft_font_test_sources = \
+	font-variations.c
+
+fc_font_test_sources = \
 	bitmap-font.c \
 	ft-font-create-for-ft-face.c \
 	ft-show-glyphs-positioning.c \
diff --git a/test/any2ppm.c b/test/any2ppm.c
index 7eb582c04..8d8d2f2cf 100644
--- a/test/any2ppm.c
+++ b/test/any2ppm.c
@@ -85,13 +85,18 @@
 #include <fcntl.h>
 #endif
 
-#if HAVE_UNISTD_H && HAVE_SIGNAL_H && HAVE_SYS_STAT_H && HAVE_SYS_SOCKET_H && HAVE_SYS_POLL_H && HAVE_SYS_UN_H
+#if HAVE_UNISTD_H && HAVE_SIGNAL_H && HAVE_SYS_STAT_H && HAVE_SYS_SOCKET_H && (HAVE_POLL_H || HAVE_SYS_POLL_H) && HAVE_SYS_UN_H
 #include <signal.h>
 #include <sys/stat.h>
 #include <sys/socket.h>
-#include <sys/poll.h>
 #include <sys/un.h>
 
+#if defined(HAVE_POLL_H)
+#include <poll.h>
+#elif defined(HAVE_SYS_POLL_H)
+#include <sys/poll.h>
+#endif
+
 #define SOCKET_PATH "./.any2ppm"
 #define TIMEOUT 60000 /* 60 seconds */
 
@@ -438,6 +443,7 @@ _rsvg_render_page (const char *filename,
     if (handle == NULL)
 	return error->message; /* XXX g_error_free */
 
+    rsvg_handle_set_dpi (handle, 72.0);
     rsvg_handle_get_dimensions (handle, &dimensions);
     surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32,
 					  dimensions.width,
@@ -875,10 +881,6 @@ main (int argc, char **argv)
 #endif
 #endif
 
-#if CAIRO_CAN_TEST_SVG_SURFACE
-    rsvg_set_default_dpi (72.0);
-#endif
-
 #if defined(_WIN32) && !defined (__CYGWIN__)
     _setmode (1, _O_BINARY);
 #endif
diff --git a/test/bitmap-font.c b/test/bitmap-font.c
index 525bafb2a..f9d753954 100644
--- a/test/bitmap-font.c
+++ b/test/bitmap-font.c
@@ -27,7 +27,9 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
+#endif
 
 #include <cairo-ft.h>
 #include <fontconfig/fontconfig.h>
@@ -73,6 +75,10 @@ check_font_extents (const cairo_test_context_t *ctx, cairo_t *cr, const char *co
     return CAIRO_TEST_SUCCESS;
 }
 
+#if !defined(S_ISREG) && defined(S_IFMT) && defined(S_IFREG)
+#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
+#endif
+
 static cairo_test_status_t
 draw (cairo_t *cr, int width, int height)
 {
diff --git a/test/bug-75705.c b/test/bug-75705.c
new file mode 100644
index 000000000..e140ff993
--- /dev/null
+++ b/test/bug-75705.c
@@ -0,0 +1,32 @@
+#include "cairo-test.h"
+
+static cairo_test_status_t
+draw (cairo_t *cr, int width, int height)
+{
+    double dsh[2] = {1,3};
+
+    cairo_set_source_rgba (cr, 0, 0, 0, 1);
+    cairo_paint (cr);
+
+    cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
+
+    cairo_move_to (cr, 3, 3);
+    /* struct glitter_scan_converter spans_embedded array size is 64 */
+    cairo_line_to (cr, 65+3, 3);
+
+    cairo_set_antialias (cr, CAIRO_ANTIALIAS_FAST);
+    cairo_set_tolerance (cr, 1);
+
+    cairo_set_dash (cr, dsh, 2, 0);
+    cairo_set_line_width (cr, 2);
+
+    cairo_stroke (cr);
+    return CAIRO_TEST_SUCCESS;
+}
+
+CAIRO_TEST (bug_75705,
+	    "Bug 75705 (exercise tor22-scan-converter)",
+	    "dash, stroke, antialias", /* keywords */
+	    NULL, /* requirements */
+	    72, 8,
+	    NULL, draw)
diff --git a/test/cairo-test-runner.c b/test/cairo-test-runner.c
index f9e7d4712..6d4134ad9 100644
--- a/test/cairo-test-runner.c
+++ b/test/cairo-test-runner.c
@@ -36,10 +36,10 @@
 #include <pixman.h> /* for version information */
 
 #define SHOULD_FORK HAVE_FORK && HAVE_WAITPID
-#if SHOULD_FORK
 #if HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#if SHOULD_FORK
 #if HAVE_SIGNAL_H
 #include <signal.h>
 #endif
@@ -164,11 +164,13 @@ static cairo_bool_t
 is_running_under_debugger (void)
 {
 #if HAVE_UNISTD_H && HAVE_LIBGEN_H && __linux__
-    char buf[1024];
+    char buf[1024] = { 0 };
+    char buf2[1024] = { 0 };
 
     sprintf (buf, "/proc/%d/exe", getppid ());
-    if (readlink (buf, buf, sizeof (buf)) != -1 &&
-	strncmp (basename (buf), "gdb", 3) == 0)
+    if (readlink (buf, buf2, sizeof (buf2)) != -1 &&
+	buf2[1023] == 0 &&
+	strncmp (basename (buf2), "gdb", 3) == 0)
     {
 	return TRUE;
     }
diff --git a/test/cairo-test-trace.c b/test/cairo-test-trace.c
index 5badc4377..4eee5d30b 100644
--- a/test/cairo-test-trace.c
+++ b/test/cairo-test-trace.c
@@ -79,14 +79,23 @@
 #include <sys/stat.h>
 #include <sys/socket.h>
 #include <sys/mman.h>
-#include <sys/poll.h>
 #include <sys/un.h>
 #include <errno.h>
 #include <assert.h>
+#include <unistd.h>
+
 #if CAIRO_HAS_REAL_PTHREAD
 #include <pthread.h>
 #endif
 
+#if defined(HAVE_POLL_H)
+#include <poll.h>
+#elif defined(HAVE_SYS_POLL_H)
+#include <sys/poll.h>
+#else
+#error No poll.h equivalent found
+#endif
+
 #if HAVE_FCFINI
 #include <fontconfig/fontconfig.h>
 #endif
@@ -906,7 +915,7 @@ write_result (const char *trace, struct slave *slave)
     static int index;
     char *filename;
 
-    xasprintf (&filename, "%s-%s-pass-%d-%d-%d.png",
+    xasprintf (&filename, "%s-%s-pass-%d-%ld-%ld.png",
 	       trace, slave->target->name, ++index,
 	       slave->start_line, slave->end_line);
     cairo_surface_write_to_png (slave->image, filename);
@@ -1175,7 +1184,7 @@ test_run (void *base,
 	    if (write_results) write_result (trace, &slaves[1]);
 	    if (write_traces && slaves[0].is_recording) {
 		char buf[80];
-		snprintf (buf, sizeof (buf), "%d", slaves[0].image_serial);
+		snprintf (buf, sizeof (buf), "%ld", slaves[0].image_serial);
 		write_trace (trace, buf, &slaves[0]);
 	    }
 
@@ -1203,7 +1212,7 @@ test_run (void *base,
 	    image = 0;
 	}
     }
-done:
+
     ret = TRUE;
 
 out:
diff --git a/test/cairo-test.c b/test/cairo-test.c
index dbfbf7e34..230579f6e 100644
--- a/test/cairo-test.c
+++ b/test/cairo-test.c
@@ -1662,6 +1662,16 @@ cairo_test_get_context (cairo_t *cr)
     return cairo_get_user_data (cr, &_cairo_test_context_key);
 }
 
+cairo_t *
+cairo_test_create (cairo_surface_t *surface,
+		   const cairo_test_context_t *ctx)
+{
+    cairo_t *cr = cairo_create (surface);
+    cairo_set_user_data (cr, &_cairo_test_context_key,
+			 (void*) ctx, NULL);
+    return cr;
+}
+
 cairo_surface_t *
 cairo_test_create_surface_from_png (const cairo_test_context_t *ctx,
 	                            const char *filename)
diff --git a/test/cairo-test.h b/test/cairo-test.h
index 7e9605f61..6169c5371 100644
--- a/test/cairo-test.h
+++ b/test/cairo-test.h
@@ -58,7 +58,9 @@ typedef unsigned __int64 uint64_t;
 #define _USE_MATH_DEFINES
 
 #include <float.h>
+#if _MSC_VER <= 1600
 #define isnan(x) _isnan(x)
+#endif
 
 #endif
 
@@ -317,6 +319,10 @@ cairo_test_get_reference_image (cairo_test_context_t *ctx,
 cairo_bool_t
 cairo_test_mkdir (const char *path);
 
+cairo_t *
+cairo_test_create (cairo_surface_t *surface,
+		   const cairo_test_context_t *ctx);
+
 CAIRO_END_DECLS
 
 #endif
diff --git a/test/make-cairo-test-constructors.py b/test/make-cairo-test-constructors.py
new file mode 100644
index 000000000..329763ccd
--- /dev/null
+++ b/test/make-cairo-test-constructors.py
@@ -0,0 +1,37 @@
+# IMPORTANT: Keep in sync with boilerplate/make-cairo-boilerplate-constructors.py!
+import argparse
+import sys
+import re
+
+if __name__=='__main__':
+    parser = argparse.ArgumentParser()
+    parser.add_argument('output')
+    parser.add_argument('input', nargs='+')
+    args = parser.parse_args()
+
+    test_names = []
+
+    match_test_line = re.compile(r'^CAIRO_TEST.*')
+    match_test_name = re.compile(r'^CAIRO_TEST.*\((.*),.*')
+
+    for fname in args.input:
+        with open(fname, 'r') as f:
+            for l in f.readlines():
+                if match_test_line.match(l):
+                    test_names.append(match_test_name.match(l).group(1))
+
+    with open(args.output, 'w') as f:
+        f.write('/* WARNING: Autogenerated file - see %s! */\n\n' % sys.argv[0])
+        f.write('#include "cairo-test-private.h"\n\n')
+        f.write('void _cairo_test_runner_register_tests (void);\n\n')
+
+        for test_name in test_names:
+            f.write('extern void _register_%s (void);\n' % test_name)
+
+        f.write('void\n')
+        f.write('_cairo_test_runner_register_tests (void)\n')
+        f.write('{\n')
+
+        for test_name in test_names:
+            f.write('    _register_%s ();\n' % test_name)
+        f.write('}\n')
diff --git a/test/meson.build b/test/meson.build
new file mode 100644
index 000000000..0e2e23673
--- /dev/null
+++ b/test/meson.build
@@ -0,0 +1,627 @@
+test_sources = [
+  'a1-bug.c',
+  'a1-clip.c',
+  'a1-fill.c',
+  'a1-image-sample.c',
+  'a1-mask.c',
+  'a1-mask-sample.c',
+  'a1-sample.c',
+  'a1-traps-sample.c',
+  'a1-rasterisation.c',
+  'a8-clear.c',
+  'a8-mask.c',
+  'aliasing.c',
+  'alpha-similar.c',
+  'arc-direction.c',
+  'arc-infinite-loop.c',
+  'arc-looping-dash.c',
+  'api-special-cases.c',
+  'big-line.c',
+  'big-empty-box.c',
+  'big-empty-triangle.c',
+  'big-little-box.c',
+  'big-little-triangle.c',
+  'bug-spline.c',
+  'big-trap.c',
+  'bilevel-image.c',
+  'bug-40410.c',
+  'bug-51910.c',
+  'bug-84115.c',
+  'bug-bo-rectangular.c',
+  'bug-bo-collins.c',
+  'bug-bo-ricotz.c',
+  'bug-source-cu.c',
+  'bug-extents.c',
+  'bug-seams.c',
+  'caps.c',
+  'checkerboard.c',
+  'caps-joins.c',
+  'caps-joins-alpha.c',
+  'caps-joins-curve.c',
+  'caps-tails-curve.c',
+  'caps-sub-paths.c',
+  'clear.c',
+  'clear-source.c',
+  'clip-all.c',
+  'clip-complex-bug61592.c',
+  'clip-complex-shape.c',
+  'clip-contexts.c',
+  'clip-disjoint.c',
+  'clip-disjoint-hatching.c',
+  'clip-disjoint-quad.c',
+  'clip-device-offset.c',
+  'clip-double-free.c',
+  'clip-draw-unbounded.c',
+  'clip-empty.c',
+  'clip-empty-group.c',
+  'clip-empty-save.c',
+  'clip-fill.c',
+  'clip-fill-no-op.c',
+  'clip-fill-rule.c',
+  'clip-fill-rule-pixel-aligned.c',
+  'clip-group-shapes.c',
+  'clip-image.c',
+  'clip-intersect.c',
+  'clip-mixed-antialias.c',
+  'clip-nesting.c',
+  'clip-operator.c',
+  'clip-push-group.c',
+  'clip-polygons.c',
+  'clip-rectilinear.c',
+  'clip-shape.c',
+  'clip-stroke.c',
+  'clip-stroke-no-op.c',
+  'clip-text.c',
+  'clip-twice.c',
+  'clip-twice-rectangle.c',
+  'clip-unbounded.c',
+  'clip-zero.c',
+  'clipped-group.c',
+  'clipped-surface.c',
+  'close-path.c',
+  'close-path-current-point.c',
+  'composite-integer-translate-source.c',
+  'composite-integer-translate-over.c',
+  'composite-integer-translate-over-repeat.c',
+  'copy-disjoint.c',
+  'copy-path.c',
+  'coverage.c',
+  'create-for-stream.c',
+  'create-from-broken-png-stream.c',
+  'create-from-png.c',
+  'create-from-png-stream.c',
+  'culled-glyphs.c',
+  'curve-to-as-line-to.c',
+  'dash-caps-joins.c',
+  'dash-curve.c',
+  'dash-infinite-loop.c',
+  'dash-no-dash.c',
+  'dash-offset.c',
+  'dash-offset-negative.c',
+  'dash-scale.c',
+  'dash-state.c',
+  'dash-zero-length.c',
+  'degenerate-arc.c',
+  'degenerate-arcs.c',
+  'degenerate-curve-to.c',
+  'degenerate-dash.c',
+  'degenerate-linear-gradient.c',
+  'degenerate-path.c',
+  'degenerate-pen.c',
+  'degenerate-radial-gradient.c',
+  'degenerate-rel-curve-to.c',
+  'degenerate-solid-dash.c',
+  'drunkard-tails.c',
+  'device-offset.c',
+  'device-offset-fractional.c',
+  'device-offset-positive.c',
+  'device-offset-scale.c',
+  'error-setters.c',
+  'extend-pad.c',
+  'extend-pad-border.c',
+  'extend-pad-similar.c',
+  'extend-reflect.c',
+  'extend-reflect-similar.c',
+  'extend-repeat.c',
+  'extend-repeat-similar.c',
+  'extended-blend.c',
+  'fallback.c',
+  'fill-alpha.c',
+  'fill-alpha-pattern.c',
+  'fill-and-stroke.c',
+  'fill-and-stroke-alpha.c',
+  'fill-and-stroke-alpha-add.c',
+  'fill-degenerate-sort-order.c',
+  'fill-disjoint.c',
+  'fill-empty.c',
+  'fill-image.c',
+  'fill-missed-stop.c',
+  'fill-rule.c',
+  'filter-bilinear-extents.c',
+  'filter-nearest-offset.c',
+  'filter-nearest-transformed.c',
+  'finer-grained-fallbacks.c',
+  'font-face-get-type.c',
+  'font-matrix-translation.c',
+  'font-options.c',
+  #'font-variations.c',
+  'glyph-cache-pressure.c',
+  'get-and-set.c',
+  'get-clip.c',
+  'get-group-target.c',
+  'get-path-extents.c',
+  'gradient-alpha.c',
+  'gradient-constant-alpha.c',
+  'gradient-zero-stops.c',
+  'gradient-zero-stops-mask.c',
+  'group-clip.c',
+  'group-paint.c',
+  'group-state.c',
+  'group-unaligned.c',
+  'half-coverage.c',
+  'halo.c',
+  'hatchings.c',
+  'horizontal-clip.c',
+  'huge-linear.c',
+  'huge-radial.c',
+  'image-surface-source.c',
+  'image-bug-710072.c',
+  'implicit-close.c',
+  'infinite-join.c',
+  'in-fill-empty-trapezoid.c',
+  'in-fill-trapezoid.c',
+  'invalid-matrix.c',
+  'inverse-text.c',
+  'inverted-clip.c',
+  'joins.c',
+  'joins-loop.c',
+  'joins-star.c',
+  'joins-retrace.c',
+  'large-clip.c',
+  'large-font.c',
+  'large-source.c',
+  'large-source-roi.c',
+  'large-twin-antialias-mixed.c',
+  'leaky-dash.c',
+  'leaky-dashed-rectangle.c',
+  'leaky-dashed-stroke.c',
+  'leaky-polygon.c',
+  'line-width.c',
+  'line-width-large-overlap.c',
+  'line-width-overlap.c',
+  'line-width-scale.c',
+  'line-width-tolerance.c',
+  'line-width-zero.c',
+  'linear-gradient.c',
+  'linear-gradient-extend.c',
+  'linear-gradient-large.c',
+  'linear-gradient-one-stop.c',
+  'linear-gradient-reflect.c',
+  'linear-gradient-subset.c',
+  'linear-step-function.c',
+  'linear-uniform.c',
+  'long-dashed-lines.c',
+  'long-lines.c',
+  'map-to-image.c',
+  'mask.c',
+  'mask-alpha.c',
+  'mask-ctm.c',
+  'mask-glyphs.c',
+  'mask-surface-ctm.c',
+  'mask-transformed-image.c',
+  'mask-transformed-similar.c',
+  'mesh-pattern.c',
+  'mesh-pattern-accuracy.c',
+  'mesh-pattern-conical.c',
+  'mesh-pattern-control-points.c',
+  'mesh-pattern-fold.c',
+  'mesh-pattern-overlap.c',
+  'mesh-pattern-transformed.c',
+  'mime-data.c',
+  'mime-surface-api.c',
+  'miter-precision.c',
+  'move-to-show-surface.c',
+  'negative-stride-image.c',
+  'new-sub-path.c',
+  'nil-surface.c',
+  'operator.c',
+  'operator-alpha.c',
+  'operator-alpha-alpha.c',
+  'operator-clear.c',
+  'operator-source.c',
+  'outline-tolerance.c',
+  'over-above-source.c',
+  'over-around-source.c',
+  'over-below-source.c',
+  'over-between-source.c',
+  'overlapping-boxes.c',
+  'overlapping-glyphs.c',
+  'overlapping-dash-caps.c',
+  'paint.c',
+  'paint-clip-fill.c',
+  'paint-repeat.c',
+  'paint-source-alpha.c',
+  'paint-with-alpha.c',
+  'paint-with-alpha-group-clip.c',
+  'partial-clip-text.c',
+  'partial-coverage.c',
+  'pass-through.c',
+  'path-append.c',
+  'path-currentpoint.c',
+  'path-stroke-twice.c',
+  'path-precision.c',
+  'pattern-get-type.c',
+  'pattern-getters.c',
+  'pdf-isolated-group.c',
+  'pixman-downscale.c',
+  'pixman-rotate.c',
+  'png.c',
+  'push-group.c',
+  'push-group-color.c',
+  'push-group-path-offset.c',
+  'radial-gradient.c',
+  'radial-gradient-extend.c',
+  'radial-outer-focus.c',
+  'random-clips.c',
+  'random-intersections-eo.c',
+  'random-intersections-nonzero.c',
+  'random-intersections-curves-eo.c',
+  'random-intersections-curves-nz.c',
+  'raster-source.c',
+  'record.c',
+  'record1414x.c',
+  'record2x.c',
+  'record90.c',
+  'recordflip.c',
+  'record-extend.c',
+  'record-neg-extents.c',
+  'record-mesh.c',
+  'record-replay-extend.c',
+  'recording-ink-extents.c',
+  'recording-surface-pattern.c',
+  'recording-surface-extend.c',
+  'rectangle-rounding-error.c',
+  'rectilinear-fill.c',
+  'rectilinear-grid.c',
+  'rectilinear-miter-limit.c',
+  'rectilinear-dash.c',
+  'rectilinear-dash-scale.c',
+  'rectilinear-stroke.c',
+  'reflected-stroke.c',
+  'rel-path.c',
+  'rgb24-ignore-alpha.c',
+  'rotate-image-surface-paint.c',
+  'rotate-stroke-box.c',
+  'rotated-clip.c',
+  'rounded-rectangle-fill.c',
+  'rounded-rectangle-stroke.c',
+  'sample.c',
+  'scale-down-source-surface-paint.c',
+  'scale-offset-image.c',
+  'scale-offset-similar.c',
+  'scale-source-surface-paint.c',
+  'scaled-font-zero-matrix.c',
+  'stroke-ctm-caps.c',
+  'stroke-clipped.c',
+  'stroke-image.c',
+  'stroke-open-box.c',
+  'select-font-face.c',
+  'select-font-no-show-text.c',
+  'self-copy.c',
+  'self-copy-overlap.c',
+  'self-intersecting.c',
+  'set-source.c',
+  'show-glyphs-advance.c',
+  'show-glyphs-many.c',
+  'show-text-current-point.c',
+  'shape-general-convex.c',
+  'shape-sierpinski.c',
+  'simple.c',
+  'skew-extreme.c',
+  'smask.c',
+  'smask-fill.c',
+  'smask-image-mask.c',
+  'smask-mask.c',
+  'smask-paint.c',
+  'smask-stroke.c',
+  'smask-text.c',
+  'smp-glyph.c',
+  'solid-pattern-cache-stress.c',
+  'source-clip.c',
+  'source-clip-scale.c',
+  'source-surface-scale-paint.c',
+  'spline-decomposition.c',
+  'stride-12-image.c',
+  'stroke-pattern.c',
+  'subsurface.c',
+  'subsurface-image-repeat.c',
+  'subsurface-repeat.c',
+  'subsurface-reflect.c',
+  'subsurface-pad.c',
+  'subsurface-modify-child.c',
+  'subsurface-modify-parent.c',
+  'subsurface-outside-target.c',
+  'subsurface-scale.c',
+  'subsurface-similar-repeat.c',
+  'surface-finish-twice.c',
+  'surface-pattern.c',
+  'surface-pattern-big-scale-down.c',
+  'surface-pattern-operator.c',
+  'surface-pattern-scale-down.c',
+  'surface-pattern-scale-down-extend.c',
+  'surface-pattern-scale-up.c',
+  'text-antialias.c',
+  'text-antialias-subpixel.c',
+  'text-cache-crash.c',
+  'text-glyph-range.c',
+  'text-pattern.c',
+  'text-rotate.c',
+  'text-transform.c',
+  'text-unhinted-metrics.c',
+  'text-zero-len.c',
+  'thin-lines.c',
+  'tighten-bounds.c',
+  'tiger.c',
+  'toy-font-face.c',
+  'transforms.c',
+  'translate-show-surface.c',
+  'trap-clip.c',
+  'twin.c',
+  'twin-antialias-gray.c',
+  'twin-antialias-mixed.c',
+  'twin-antialias-none.c',
+  'twin-antialias-subpixel.c',
+  'unaligned-box.c',
+  'unantialiased-shapes.c',
+  'unbounded-operator.c',
+  'unclosed-strokes.c',
+  'user-data.c',
+  'user-font.c',
+  'user-font-mask.c',
+  'user-font-proxy.c',
+  'user-font-rescale.c',
+  'world-map.c',
+  'white-in-noop.c',
+  'xcb-huge-image-shm.c',
+  'xcb-huge-subimage.c',
+  'xcb-stress-cache.c',
+  'xcb-snapshot-assert.c',
+  'xcomposite-projection.c',
+  'xlib-expose-event.c',
+  'zero-alpha.c',
+  'zero-mask.c',
+]
+
+test_pthread_sources = [
+  'pthread-same-source.c',
+  'pthread-show-text.c',
+  'pthread-similar.c',
+]
+
+test_ft_font_sources = [
+  'bitmap-font.c',
+  'ft-font-create-for-ft-face.c',
+  'ft-show-glyphs-positioning.c',
+  'ft-show-glyphs-table.c',
+  'ft-text-vertical-layout-type1.c',
+  'ft-text-vertical-layout-type3.c',
+  'ft-text-antialias-none.c',
+]
+
+test_gl_sources = [
+  'gl-device-release.c',
+  'gl-oversized-surface.c',
+  'gl-surface-source.c',
+]
+
+test_egl_sources = [
+  'egl-oversized-surface.c',
+  'egl-surface-source.c',
+]
+
+test_quartz_sources = [
+  'quartz-surface-source.c',
+]
+
+test_pdf_sources = [
+  'pdf-features.c',
+  'pdf-mime-data.c',
+  'pdf-surface-source.c',
+  'pdf-tagged-text.c',
+]
+
+test_ps_sources = [
+  'ps-eps.c',
+  'ps-features.c',
+  'ps-surface-source.c',
+]
+
+test_svg_sources = [
+  'svg-surface.c',
+  'svg-clip.c',
+  'svg-surface-source.c',
+]
+
+test_xcb_sources = [
+  'xcb-surface-source.c',
+]
+
+test_xlib_sources = [
+  'xlib-surface.c',
+  'xlib-surface-source.c',
+]
+
+test_xlib_xrender_sources = [
+  'get-xrender-format.c',
+]
+
+test_multi_page_sources = [
+  'multi-page.c',
+  'mime-unique-id.c',
+]
+
+test_fallback_resolution_sources = [
+  'fallback-resolution.c',
+]
+
+cairo_test_suite_sources = [
+  'buffer-diff.c',
+  'cairo-test.c',
+  'cairo-test-runner.c',
+]
+
+cairo_test_trace_sources = [
+  'cairo-test-trace.c',
+  'buffer-diff.c',
+]
+
+imagediff_sources = [
+  'imagediff.c',
+  'buffer-diff.c',
+]
+
+png_flatten_sources = [
+  'png-flatten.c',
+]
+
+pdf2png_sources = [
+  'pdf2png.c',
+]
+
+svg2png_sources = [
+  'svg2png.c',
+]
+
+ps2png_sources = [
+  'ps2png.c',
+]
+
+build_any2ppm = false
+has_multipage_surfaces = false
+add_fallback_resolution = false
+
+if conf.get('HAVE_REAL_PTHREAD', 0) == 1
+  test_sources += test_pthread_sources
+endif
+
+if feature_conf.get('CAIRO_HAS_FT_FONT', 0) == 1 and feature_conf.get('CAIRO_HAS_FC_FONT', 0) == 1
+  test_sources += test_ft_font_sources
+endif
+
+if feature_conf.get('CAIRO_HAS_QUARTZ_SURFACE', 0) == 1
+  test_sources += test_quartz_sources
+endif
+
+if feature_conf.get('CAIRO_HAS_PDF_SURFACE', 0) == 1
+  test_sources += test_pdf_sources
+  has_multipage_surfaces = true
+  add_fallback_resolution = true
+  build_any2ppm = true
+endif
+
+if feature_conf.get('CAIRO_HAS_PS_SURFACE', 0) == 1
+  test_sources += test_ps_sources
+  has_multipage_surfaces = true
+  add_fallback_resolution = true
+  build_any2ppm = true
+endif
+
+if feature_conf.get('CAIRO_HAS_SVG_SURFACE', 0) == 1
+  test_sources += test_svg_sources
+  build_any2ppm = true
+  add_fallback_resolution = true
+endif
+
+if feature_conf.get('CAIRO_HAS_XCB_SURFACE', 0) == 1
+  test_sources += test_xcb_sources
+endif
+
+if feature_conf.get('CAIRO_HAS_XLIB_SURFACE', 0) == 1
+  test_sources += test_xlib_sources
+endif
+
+if feature_conf.get('CAIRO_HAS_XLIB_XRENDER_SURFACE', 0) == 1
+  test_sources += test_xlib_xrender_sources
+endif
+
+if feature_conf.get('CAIRO_HAS_EGL_FUNCTIONS', 0) == 1
+  test_sources += test_egl_sources
+endif
+
+if has_multipage_surfaces
+  test_sources += test_multi_page_sources
+endif
+
+if add_fallback_resolution
+  test_sources += test_fallback_resolution_sources
+endif
+
+if feature_conf.get('CAIRO_HAS_SCRIPT_SURFACE', 0) == 1
+  build_any2ppm = true
+endif
+
+cairo_test_constructors = custom_target('cairo-test-constructors.c',
+  input: files(test_sources),
+  output: 'cairo-test-constructors.c',
+  command: [python3, files('make-cairo-test-constructors.py')[0], '@OUTPUT@', '@INPUT@'])
+
+incpdiff = include_directories('pdiff')
+
+test_depends = []
+
+subdir('pdiff')
+
+if conf.get('CAIRO_CAN_TEST_PDF_SURFACE', 0) == 1
+  exe = executable('pdf2png', pdf2png_sources,
+    dependencies: deps + test_deps,
+  )
+endif
+
+if conf.get('CAIRO_CAN_TEST_SVG_SURFACE', 0) == 1
+  exe = executable('svg2png', svg2png_sources,
+    dependencies: deps + test_deps,
+  )
+endif
+
+if conf.get('CAIRO_HAS_SPECTRE', 0) == 1
+  exe = executable('ps2png', ps2png_sources,
+    dependencies: deps + test_deps,
+  )
+endif
+
+if build_any2ppm
+  any2ppm_exe = executable('any2ppm', 'any2ppm.c',
+    c_args: ['-DHAVE_CONFIG_H'],
+    include_directories: [incbase, incsrc, inccairoscript],
+    link_with: [libcairo, libcairoscript],
+    dependencies: deps + test_deps,
+  )
+  test_depends += [any2ppm_exe]
+endif
+
+if have_shm
+  cairo_test_trace_exe = executable('cairo-test-trace', cairo_test_trace_sources,
+  include_directories: [incbase, incsrc, incboilerplate, incpdiff, inccairoscript, inccairomissing],
+  c_args: ['-DHAVE_CONFIG_H'] + pthread_c_args,
+  link_with: [libcairo, libcairoboilerplate, libpdiff, libcairoscript, libcairomissing],
+  link_args: extra_link_args,
+  dependencies: deps + test_deps + [rt_dep])
+endif
+
+exe = executable('cairo-test-suite', [cairo_test_suite_sources, test_sources, cairo_test_constructors],
+  include_directories: [incbase, incsrc, incboilerplate, incpdiff],
+  c_args: ['-DHAVE_CONFIG_H'],
+  link_with: [libcairo, libcairoboilerplate, libpdiff],
+  link_args: extra_link_args,
+  dependencies: deps + test_deps,
+)
+
+env = environment()
+
+env.set('srcdir', meson.current_source_dir())
+
+test('cairo', exe,
+  timeout: 60 * 60,
+  env: env,
+  workdir: meson.current_build_dir(),
+  depends: test_depends)
diff --git a/test/pdiff/meson.build b/test/pdiff/meson.build
new file mode 100644
index 000000000..6400b95c2
--- /dev/null
+++ b/test/pdiff/meson.build
@@ -0,0 +1,21 @@
+libpdiff_sources = [
+  'lpyramid.c',
+  'pdiff.c',
+]
+
+perceptualdiff_sources = [
+  'args.c',
+  'perceptualdiff.c',
+]
+
+libpdiff = static_library('pdiff', libpdiff_sources,
+  c_args: ['-DHAVE_CONFIG_H'],
+  include_directories: [incbase, incsrc],
+  dependencies: deps,
+  link_with: [libcairo],
+)
+
+perceptualdiff = executable('perceptualdiff', perceptualdiff_sources,
+  c_args: ['-DHAVE_CONFIG_H'],
+  include_directories: [incbase, incsrc],
+  link_with: [libpdiff])
diff --git a/test/raster-source.c b/test/raster-source.c
index 5a7646e8a..ee2a570c3 100644
--- a/test/raster-source.c
+++ b/test/raster-source.c
@@ -34,6 +34,8 @@
 #define WIDTH 200
 #define HEIGHT 80
 
+static char *png_filename = NULL;
+
 /* Lazy way of determining PNG dimensions... */
 static void
 png_dimensions (const char *filename,
@@ -84,15 +86,26 @@ release (cairo_pattern_t *pattern, void *closure, cairo_surface_t *image)
     cairo_surface_destroy (image);
 }
 
+static void
+free_filename(void)
+{
+    free (png_filename);
+}
+
 static cairo_test_status_t
 draw (cairo_t *cr, int width, int height)
 {
-    const char *png_filename = "png.png";
     cairo_pattern_t *png, *red;
     cairo_content_t content;
     int png_width, png_height;
     int i, j;
 
+    if (png_filename == NULL) {
+      const cairo_test_context_t *ctx = cairo_test_get_context (cr);
+      xasprintf (&png_filename, "%s/png.png", ctx->srcdir);
+      atexit (free_filename);
+    }
+
     png_dimensions (png_filename, &content, &png_width, &png_height);
 
     png = cairo_pattern_create_raster_source ((void*)png_filename,
diff --git a/test/record.c b/test/record.c
index 774c13316..bc5e1f72e 100644
--- a/test/record.c
+++ b/test/record.c
@@ -346,7 +346,7 @@ record_create (cairo_t *target)
     cairo_t *cr;
 
     surface = cairo_recording_surface_create (cairo_surface_get_content (cairo_get_target (target)), NULL);
-    cr = cairo_create (surface);
+    cr = cairo_test_create (surface, cairo_test_get_context (target));
     cairo_surface_destroy (surface);
 
     return cr;
diff --git a/test/record1414x.c b/test/record1414x.c
index 029e5a4d6..c38857c1f 100644
--- a/test/record1414x.c
+++ b/test/record1414x.c
@@ -339,7 +339,7 @@ record_create (cairo_t *target)
     cairo_t *cr;
 
     surface = cairo_recording_surface_create (cairo_surface_get_content (cairo_get_target (target)), NULL);
-    cr = cairo_create (surface);
+    cr = cairo_test_create (surface, cairo_test_get_context (target));
     cairo_surface_destroy (surface);
 
     return cr;
diff --git a/test/record2x.c b/test/record2x.c
index 7fe037732..caca0e603 100644
--- a/test/record2x.c
+++ b/test/record2x.c
@@ -335,7 +335,7 @@ record_create (cairo_t *target)
     cairo_t *cr;
 
     surface = cairo_recording_surface_create (cairo_surface_get_content (cairo_get_target (target)), NULL);
-    cr = cairo_create (surface);
+    cr = cairo_test_create (surface, cairo_test_get_context (target));
     cairo_surface_destroy (surface);
 
     return cr;
diff --git a/test/record90.c b/test/record90.c
index 95ba3b1b1..aeec5af81 100644
--- a/test/record90.c
+++ b/test/record90.c
@@ -335,7 +335,7 @@ record_create (cairo_t *target)
     cairo_t *cr;
 
     surface = cairo_recording_surface_create (cairo_surface_get_content (cairo_get_target (target)), NULL);
-    cr = cairo_create (surface);
+    cr = cairo_test_create (surface, cairo_test_get_context (target));
     cairo_surface_destroy (surface);
 
     return cr;
diff --git a/test/recordflip.c b/test/recordflip.c
index e923c8a2a..495fe9dd6 100644
--- a/test/recordflip.c
+++ b/test/recordflip.c
@@ -333,7 +333,7 @@ record_create (cairo_t *target)
     cairo_t *cr;
 
     surface = cairo_recording_surface_create (cairo_surface_get_content (cairo_get_target (target)), NULL);
-    cr = cairo_create (surface);
+    cr = cairo_test_create (surface, cairo_test_get_context (target));
     cairo_surface_destroy (surface);
 
     return cr;
diff --git a/test/reference/bug-75705.ref.png b/test/reference/bug-75705.ref.png
new file mode 100644
index 000000000..c0ac5ff64
Binary files /dev/null and b/test/reference/bug-75705.ref.png differ
diff --git a/test/svg2png.c b/test/svg2png.c
index 24bdbfa91..92c6366aa 100644
--- a/test/svg2png.c
+++ b/test/svg2png.c
@@ -52,12 +52,11 @@ int main (int argc, char *argv[])
 
     error = NULL;
 
-    rsvg_set_default_dpi (72.0);
-
     handle = rsvg_handle_new_from_file (filename, &error);
     if (!handle)
 	FAIL (error->message);
 
+    rsvg_handle_set_dpi (handle, 72.0);
     rsvg_handle_get_dimensions (handle, &dimensions);
 
     surface = cairo_image_surface_create (CAIRO_FORMAT_RGB24,
@@ -81,9 +80,6 @@ int main (int argc, char *argv[])
     if (status)
 	FAIL (cairo_status_to_string (status));
 
-    if (!rsvg_handle_close (handle, &error))
-	FAIL (error->message);
-
     g_object_unref (handle);
     return 0;
 }
diff --git a/test/text-subpixel.c b/test/text-subpixel.c
new file mode 100644
index 000000000..3ea63b950
--- /dev/null
+++ b/test/text-subpixel.c
@@ -0,0 +1,68 @@
+/*
+ * Copyright  2019 Matthias Clasen
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of
+ * Red Hat, Inc. not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior
+ * permission. Red Hat, Inc. makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * RED HAT, INC. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL RED HAT, INC. BE LIABLE FOR ANY SPECIAL,
+ * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+ * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author: Adrian Johnson <ajohnson@redneon.com>
+ */
+
+#include "cairo-test.h"
+
+#define WIDTH  300
+#define HEIGHT 200
+
+static cairo_test_status_t
+draw (cairo_t *cr, int width, int height)
+{
+    cairo_font_options_t *font_options;
+    double size, y;
+
+    cairo_set_source_rgb (cr, 1, 1, 1);
+    cairo_paint (cr);
+
+    cairo_select_font_face (cr, CAIRO_TEST_FONT_FAMILY "DejaVu Sans Mono",
+			    CAIRO_FONT_SLANT_NORMAL,
+			    CAIRO_FONT_WEIGHT_NORMAL);
+
+    font_options = cairo_font_options_create();
+    cairo_get_font_options (cr, font_options);
+    cairo_font_options_set_hint_metrics (font_options, CAIRO_HINT_METRICS_OFF);
+    cairo_font_options_set_hint_style (font_options, CAIRO_HINT_STYLE_NONE);
+    cairo_set_font_options (cr, font_options);
+    cairo_font_options_destroy (font_options);
+
+    y = 0.0;
+    cairo_set_source_rgb (cr, 0, 0, 0);
+    for (size = 10.0; size <= 40.0; size += 3.3) {
+	cairo_set_font_size (cr, size);
+	y += size + 2.3;
+	cairo_move_to (cr, 5, y);
+	cairo_show_text (cr, "aaaaaaaaaa");
+    }
+
+    return CAIRO_TEST_SUCCESS;
+}
+
+CAIRO_TEST (text_subpixel_positioning,
+	    "Test subpixel positioning",
+	    "text, font", /* keywords */
+	    NULL, /* requirements */
+	    WIDTH, HEIGHT,
+	    NULL, draw)
diff --git a/util/cairo-fdr/meson.build b/util/cairo-fdr/meson.build
new file mode 100644
index 000000000..3cb66c678
--- /dev/null
+++ b/util/cairo-fdr/meson.build
@@ -0,0 +1,11 @@
+cairo_fdr_sources = [
+  'fdr.c',
+]
+
+libcairofdr = library('cairo-fdr', cairo_fdr_sources,
+  include_directories: [incbase, incsrc],
+  c_args: ['-DHAVE_CONFIG_H'],
+  dependencies: deps,
+  install: true,
+  install_dir: join_paths(get_option('prefix'), get_option('libdir'), 'cairo'),
+)
diff --git a/util/cairo-gobject/meson.build b/util/cairo-gobject/meson.build
new file mode 100644
index 000000000..895ba03d7
--- /dev/null
+++ b/util/cairo-gobject/meson.build
@@ -0,0 +1,25 @@
+cairo_gobject_sources = [
+  'cairo-gobject-enums.c',
+  'cairo-gobject-structs.c',
+]
+
+cairo_gobject_headers = [
+  'cairo-gobject.h',
+]
+
+libcairogobject = library('cairo-gobject', cairo_gobject_sources,
+  c_args: ['-DHAVE_CONFIG_H'],
+  include_directories: [incbase, incsrc],
+  dependencies: [glib_dep, gobject_dep],
+  link_with: [libcairo],
+  soversion: '2',
+  version: '2.' + ''.join(meson.project_version().split('.')) + '.0',
+  install: true,
+)
+
+incgobject = include_directories('.')
+
+libcairogobject_dep = declare_dependency(link_with: libcairogobject,
+  include_directories: [incbase, incgobject])
+
+install_headers(cairo_gobject_headers, subdir: 'cairo')
diff --git a/util/cairo-missing/meson.build b/util/cairo-missing/meson.build
new file mode 100644
index 000000000..db328fb1c
--- /dev/null
+++ b/util/cairo-missing/meson.build
@@ -0,0 +1,11 @@
+cairo_missing_sources = [
+  'strndup.c',
+  'getline.c',
+]
+
+inccairomissing = include_directories('.')
+
+libcairomissing = static_library('cairo-missing', cairo_missing_sources,
+  c_args: ['-DHAVE_CONFIG_H'],
+  include_directories: [incbase, incsrc],
+)
diff --git a/util/cairo-script/meson.build b/util/cairo-script/meson.build
new file mode 100644
index 000000000..a782ec63f
--- /dev/null
+++ b/util/cairo-script/meson.build
@@ -0,0 +1,66 @@
+cairoscript_interpreter_sources = [
+  'cairo-script-file.c',
+  'cairo-script-hash.c',
+  'cairo-script-interpreter.c',
+  'cairo-script-objects.c',
+  'cairo-script-operators.c',
+  'cairo-script-scanner.c',
+  'cairo-script-stack.c',
+]
+
+cairoscript_interpreter_headers = [
+  'cairo-script-interpreter.h',
+]
+
+csi_replay_sources = [
+  'csi-replay.c',
+]
+
+csi_exec_sources = [
+  'csi-exec.c',
+]
+
+csi_trace_sources = [
+  'csi-trace.c',
+]
+
+libcairoscript = library('cairo-script-interpreter',
+  cairoscript_interpreter_sources,
+  c_args: ['-DHAVE_CONFIG_H'],
+  include_directories: [incbase, incsrc],
+  dependencies: deps,
+  link_with: [libcairo],
+  soversion: '2',
+  version: '2.' + ''.join(meson.project_version().split('.')) + '.0',
+  install: true,
+)
+
+inccairoscript = include_directories('.')
+
+libcairoscript_dep = declare_dependency(link_with: libcairoscript,
+  include_directories: [incbase, inccairoscript])
+
+csi_replay_exe = executable('csi-replay', csi_replay_sources,
+  c_args: ['-DHAVE_CONFIG_H'],
+  include_directories: [incbase, incsrc],
+  link_with: [libcairo, libcairoscript],
+  dependencies: deps,
+)
+
+csi_exec_exe = executable('csi-exec', csi_exec_sources,
+  c_args: ['-DHAVE_CONFIG_H'],
+  include_directories: [incbase, incsrc],
+  link_with: [libcairo, libcairoscript],
+  dependencies: deps,
+)
+
+if feature_conf.get('CAIRO_HAS_SCRIPT_SURFACE', 0) == 1 and conf.get('HAVE_LIBGEN_H', 0) == 1
+  csi_trace_exe = executable('csi-trace', csi_trace_sources,
+    c_args: ['-DHAVE_CONFIG_H'],
+    include_directories: [incbase, incsrc],
+    link_with: [libcairo, libcairoscript],
+    dependencies: deps,
+  )
+endif
+
+install_headers(cairoscript_interpreter_headers, subdir: 'cairo')
diff --git a/util/cairo-sphinx/meson.build b/util/cairo-sphinx/meson.build
new file mode 100644
index 000000000..cf560aefd
--- /dev/null
+++ b/util/cairo-sphinx/meson.build
@@ -0,0 +1,26 @@
+libcairo_sphinx_sources = [
+  'fdr.c',
+]
+
+cairo_sphinx_sources = [
+  'sphinx.c',
+]
+
+libcairosphinx = library('cairo-sphinx', libcairo_sphinx_sources,
+  include_directories: [incbase, incsrc],
+  c_args: ['-DHAVE_CONFIG_H'],
+  dependencies: deps,
+  install: true,
+  install_dir: join_paths(get_option('prefix'), get_option('libdir'), 'cairo'),
+)
+
+libdir = join_paths(get_option('prefix'), get_option('libdir'))
+
+cairosphinx_exe = executable('cairo-sphinx', cairo_sphinx_sources,
+  include_directories: [incbase, incsrc, inccairoscript, incboilerplate],
+  c_args: ['-DHAVE_CONFIG_H', '-DLIBDIR="@0@"'.format(libdir)] + pthread_c_args,
+  dependencies: deps + [glib_dep, rt_dep],
+  link_with: [libcairo, libcairosphinx, libcairoscript, libcairoboilerplate],
+  link_args: extra_link_args,
+  install: true,
+)
diff --git a/util/cairo-sphinx/sphinx.c b/util/cairo-sphinx/sphinx.c
index 238d40064..5c5fcee77 100644
--- a/util/cairo-sphinx/sphinx.c
+++ b/util/cairo-sphinx/sphinx.c
@@ -15,7 +15,6 @@
 #include <sys/stat.h>
 #include <sys/mman.h>
 #include <sys/socket.h>
-#include <sys/poll.h>
 #include <sys/un.h>
 #include <unistd.h>
 #include <fcntl.h>
@@ -24,6 +23,14 @@
 #include <assert.h>
 #include <pthread.h>
 
+#if defined(HAVE_POLL_H)
+#include <poll.h>
+#elif defined(HAVE_SYS_POLL_H)
+#include <sys/poll.h>
+#else
+#error No poll.h equivalent found
+#endif
+
 #include <cairo.h>
 #include <cairo-script.h>
 #include <cairo-script-interpreter.h>
diff --git a/util/cairo-trace/meson.build b/util/cairo-trace/meson.build
new file mode 100644
index 000000000..e836f98cf
--- /dev/null
+++ b/util/cairo-trace/meson.build
@@ -0,0 +1,34 @@
+cairo_trace_sources = [
+  'trace.c',
+]
+
+if conf.get('CAIRO_HAS_SYMBOL_LOOKUP', 0) == 1
+  cairo_trace_sources += ['lookup-symbol.c']
+endif
+
+shared_lib_ext = libcairo.full_path().split('.')[-1]
+
+libcairotrace = library('cairo-trace', cairo_trace_sources,
+  include_directories: [incbase, incsrc],
+  dependencies: deps,
+  link_args: extra_link_args,
+  c_args: ['-DSHARED_LIB_EXT="@0@"'.format(shared_lib_ext), '-DHAVE_CONFIG_H'] + pthread_c_args,
+  install: true,
+  install_dir: join_paths(get_option('prefix'), get_option('libdir'), 'cairo'),
+)
+
+trace_conf = configuration_data()
+trace_conf.set('prefix', get_option('prefix'))
+trace_conf.set('exec_prefix', get_option('prefix'))
+trace_conf.set('libdir', get_option('prefix') / get_option('libdir'))
+trace_conf.set('CAIRO_VERSION_MAJOR', meson.project_version().split('.')[0])
+trace_conf.set('CAIRO_VERSION_MINOR', meson.project_version().split('.')[1])
+trace_conf.set('CAIRO_VERSION_MICRO', meson.project_version().split('.')[2])
+trace_conf.set('SHLIB_EXT', shared_lib_ext)
+
+configure_file(input: 'cairo-trace.in',
+  output: 'cairo-trace',
+  configuration: trace_conf,
+  install: true,
+  install_dir: join_paths(get_option('prefix'), get_option('bindir')),
+)
diff --git a/util/cairo-trace/trace.c b/util/cairo-trace/trace.c
index 28ec11941..bb618b5d9 100644
--- a/util/cairo-trace/trace.c
+++ b/util/cairo-trace/trace.c
@@ -784,7 +784,7 @@ static cairo_bool_t
 _init_logfile (void)
 {
     static cairo_bool_t initialized;
-    char buf[4096];
+    char buf[4105];
     const char *filename;
     const char *env;
 
diff --git a/util/meson.build b/util/meson.build
new file mode 100644
index 000000000..6982ad758
--- /dev/null
+++ b/util/meson.build
@@ -0,0 +1,65 @@
+subdir('cairo-missing')
+
+cairo_utils = []
+
+if feature_conf.get('CAIRO_HAS_GOBJECT_FUNCTIONS', 0) == 1
+  subdir('cairo-gobject')
+endif
+
+if feature_conf.get('CAIRO_HAS_INTERPRETER', 0) == 1
+  subdir('cairo-script')
+endif
+
+if conf.get('CAIRO_HAS_TRACE', 0) == 1
+  subdir('cairo-trace')
+
+  if (conf.get('CAIRO_HAS_DLSYM', 0) == 1 and
+      feature_conf.get('CAIRO_HAS_SCRIPT_SURFACE', 0) == 1 and
+      feature_conf.get('CAIRO_HAS_TEE_SURFACE', 0) == 1)
+    subdir('cairo-fdr')
+  endif
+endif
+
+if (glib_dep.found() and
+    png_dep.found() and
+    host_machine.system() != 'windows' and
+    conf.get('CAIRO_HAS_DLSYM', 0) == 1 and
+    feature_conf.get('CAIRO_HAS_SCRIPT_SURFACE', 0) == 1 and
+    feature_conf.get('CAIRO_HAS_TEE_SURFACE', 0) == 1)
+  subdir('cairo-sphinx')
+endif
+
+if gtk_dep.found()
+  cairo_utils += [
+    ['show-contour.c', {'deps': [gtk_dep]}],
+    ['show-traps.c', {'deps': [gtk_dep]}],
+    ['show-edges.c', {'deps': [gtk_dep]}],
+    ['show-polygon.c', {'deps': [gtk_dep]}],
+    ['show-events.c', {'deps': [gtk_dep]}],
+    ['font-view.c', {'deps': [gtk_dep]}],
+  ]
+endif
+
+if feature_conf.get('CAIRO_HAS_INTERPRETER', 0) == 1
+  expat_dep = dependency('expat', fallback: ['expat', 'expat_dep'])
+  cairo_utils += [
+    ['trace-to-xml.c', {'deps': [expat_dep]}],
+    ['xml-to-trace.c', {'deps': [expat_dep]}],
+  ]
+endif
+
+foreach util : cairo_utils
+  exe_name = util[0].split('.')[0]
+  util_deps = util.get(1, {}).get('deps', [])
+  executable(exe_name, util[0],
+    include_directories: [incbase, incsrc, inccairoscript],
+    dependencies: deps + util_deps,
+    link_with: [libcairo, libcairoscript],
+  )
+endforeach
+
+if cc.has_header_symbol('malloc.h', '__malloc_hook')
+  libmallocstats = library('malloc-stats', 'malloc-stats.c')
+endif
+
+# backtrace-symbols does not build
